@top Schema { (statement? newline)* statement? }

@tokens {
  Export { "::"}
  Pointer { "*" }
  Nullable { "?" }
  OpenBrace { "{" }
  CloseBrace { "}" }
  OpenBracket { "[" }
  CloseBracket { "]" }
  RightArrow { "->" }
  LeftArrow { "<-" }
  URI { "<>" }

  newline { "\n" }
  space { (" " | "\t")+ }
  Comment { "#" ![\n]* }
  identifier { std.asciiLetter (std.asciiLetter | std.digit)* }

  hexDig { $[0-9A-Fa-f] }
  subDelims { $[!$&'()*+,;=] }
  unreserved { $[A-Za-z0-9\-._~] }
  pctEncoded { "%" hexDig hexDig }
  decOctet { "25" $[0-5] | "2" $[0-4] std.digit | $[01]? std.digit std.digit? }
  ipv4address { decOctet "." decOctet "." decOctet "." decOctet }
  h16 { hexDig (hexDig (hexDig hexDig?)?)? }
  ls32 { h16 ":" h16 | ipv4address }
  ipv6address {
                                                                                    h16 ":" h16 ":" h16 ":" h16 ":" h16 ":" h16 ":" ls32
    |                                                                          "::" h16 ":" h16 ":" h16 ":" h16 ":" h16 ":" ls32
    | h16?                                                                     "::" h16 ":" h16 ":" h16 ":" h16 ":" ls32
    | (h16 (":" h16)?)?                                                        "::" h16 ":" h16 ":" h16 ":" ls32
    | (h16 (":" h16 (":" h16)?)?)?                                             "::" h16 ":" h16 ":" ls32
    | (h16 (":" h16 (":" h16 (":" h16)?)?)?)?                                  "::" h16 ":" ls32
    | (h16 (":" h16 (":" h16 (":" h16 (":" h16)?)?)?)?)?                       "::" ls32
    | (h16 (":" h16 (":" h16 (":" h16 (":" h16 (":" h16)?)?)?)?)?)?            "::" h16
    | (h16 (":" h16 (":" h16 (":" h16 (":" h16 (":" h16 (":" h16)?)?)?)?)?)?)? "::"
  }
  ipvFuture { $[Vv] hexDig+ "." (unreserved | subDelims | ":")+ }
  ipLiteral { "[" (ipv6address | ipvFuture) "]" }
  regName { (unreserved | pctEncoded | subDelims)* }
  host { ipLiteral | ipv4address | regName }
  userinfo { (unreserved | pctEncoded | subDelims | ":")* }
  authority { (userinfo "@")? host (":" std.digit+)? }
  pchar { unreserved | pctEncoded | subDelims | ":" | "@" }
  scheme { std.asciiLetter $[A-Za-z0-9+\-.]* }
  absoluteURI { scheme ":" ("//" authority | "/"? pchar+) ("/" pchar*)* }
  component<delimiter> { delimiter (pchar | $[/?])* }
  uri { absoluteURI component<"?">? component<"#">? }
  Term { identifier ":" unreserved+ | "<" uri ">" }
  NamespaceURI { absoluteURI $[/?#] }

  @precedence { Term identifier }
}

@skip { space | Comment }

delimited<element> { (newline element?)* newline }

expression[@isGroup=Expression] {
  Variable | Optional | Reference | Literal | URI | Product | Coproduct
}

Variable { identifier }

Optional { Nullable expression }

Reference { Pointer Term }

Literal { Term }

Product { OpenBrace delimited<Component>? CloseBrace }
Component { Term RightArrow expression }

Coproduct { OpenBracket delimited<Option>? CloseBracket }
Option { Term (LeftArrow expression)? }

statement { Namespace | Type | Class | Edge }

NamespaceName { identifier }

Namespace { @specialize[@name=namespace]<identifier, "namespace"> NamespaceName NamespaceURI }

TypeName { identifier }

Type { @specialize[@name=type]<identifier, "type"> TypeName expression }

Class { @specialize[@name=class]<identifier, "class"> Term Export expression }

Edge {
  @specialize[@name=edge]<identifier, "edge"> Term Export (Term "=>" Term | Term "=/" expression "/=>" Term)
}
