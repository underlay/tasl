{"version":3,"sources":["webpack://@underlay/tasl-codemirror/./lib/config.js","webpack://@underlay/tasl-codemirror/./lib/error.js","webpack://@underlay/tasl-codemirror/./lib/index.js","webpack://@underlay/tasl-codemirror/./lib/lint.js","webpack://@underlay/tasl-codemirror/./lib/syntax.js","webpack://@underlay/tasl-codemirror/./node_modules/@codemirror/next/autocomplete/dist/index.js","webpack://@underlay/tasl-codemirror/./node_modules/@codemirror/next/basic-setup/dist/index.js","webpack://@underlay/tasl-codemirror/./node_modules/@codemirror/next/closebrackets/dist/index.js","webpack://@underlay/tasl-codemirror/./node_modules/@codemirror/next/commands/dist/index.js","webpack://@underlay/tasl-codemirror/./node_modules/@codemirror/next/comment/dist/index.js","webpack://@underlay/tasl-codemirror/./node_modules/@codemirror/next/fold/dist/index.js","webpack://@underlay/tasl-codemirror/./node_modules/@codemirror/next/gutter/dist/index.js","webpack://@underlay/tasl-codemirror/./node_modules/@codemirror/next/highlight/dist/index.js","webpack://@underlay/tasl-codemirror/./node_modules/@codemirror/next/history/dist/index.js","webpack://@underlay/tasl-codemirror/./node_modules/@codemirror/next/language/dist/index.js","webpack://@underlay/tasl-codemirror/./node_modules/@codemirror/next/lint/dist/index.js","webpack://@underlay/tasl-codemirror/./node_modules/@codemirror/next/matchbrackets/dist/index.js","webpack://@underlay/tasl-codemirror/./node_modules/@codemirror/next/panel/dist/index.js","webpack://@underlay/tasl-codemirror/./node_modules/@codemirror/next/rangeset/dist/index.js","webpack://@underlay/tasl-codemirror/./node_modules/@codemirror/next/rectangular-selection/dist/index.js","webpack://@underlay/tasl-codemirror/./node_modules/@codemirror/next/search/dist/index.js","webpack://@underlay/tasl-codemirror/./node_modules/@codemirror/next/state/dist/index.js","webpack://@underlay/tasl-codemirror/./node_modules/@codemirror/next/text/dist/index.js","webpack://@underlay/tasl-codemirror/./node_modules/@codemirror/next/tooltip/dist/index.js","webpack://@underlay/tasl-codemirror/./node_modules/@codemirror/next/view/dist/index.js","webpack://@underlay/tasl-codemirror/./node_modules/@underlay/apg/lib/index.js","webpack://@underlay/tasl-codemirror/./node_modules/@underlay/apg/lib/instance/index.js","webpack://@underlay/tasl-codemirror/./node_modules/@underlay/apg/lib/instance/instance.js","webpack://@underlay/tasl-codemirror/./node_modules/@underlay/apg/lib/instance/utils.js","webpack://@underlay/tasl-codemirror/./node_modules/@underlay/apg/lib/mapping/apply.js","webpack://@underlay/tasl-codemirror/./node_modules/@underlay/apg/lib/mapping/delta.js","webpack://@underlay/tasl-codemirror/./node_modules/@underlay/apg/lib/mapping/index.js","webpack://@underlay/tasl-codemirror/./node_modules/@underlay/apg/lib/mapping/map.js","webpack://@underlay/tasl-codemirror/./node_modules/@underlay/apg/lib/mapping/mapping.js","webpack://@underlay/tasl-codemirror/./node_modules/@underlay/apg/lib/mapping/utils.js","webpack://@underlay/tasl-codemirror/./node_modules/@underlay/apg/lib/schema/index.js","webpack://@underlay/tasl-codemirror/./node_modules/@underlay/apg/lib/schema/schema.js","webpack://@underlay/tasl-codemirror/./node_modules/@underlay/apg/lib/schema/utils.js","webpack://@underlay/tasl-codemirror/./node_modules/@underlay/apg/lib/utils.js","webpack://@underlay/tasl-codemirror/./node_modules/@underlay/namespaces/lib/index.js","webpack://@underlay/tasl-codemirror/./node_modules/@underlay/namespaces/lib/rdf.js","webpack://@underlay/tasl-codemirror/./node_modules/@underlay/namespaces/lib/ul.js","webpack://@underlay/tasl-codemirror/./node_modules/@underlay/namespaces/lib/xsd.js","webpack://@underlay/tasl-codemirror/./node_modules/@underlay/tasl-lezer/grammar/tasl.js","webpack://@underlay/tasl-codemirror/./node_modules/@underlay/tasl-lezer/lib/index.js","webpack://@underlay/tasl-codemirror/./node_modules/@underlay/tasl-lezer/lib/parse.js","webpack://@underlay/tasl-codemirror/./node_modules/@underlay/tasl-lezer/lib/stdlib.js","webpack://@underlay/tasl-codemirror/./node_modules/@underlay/tasl-lezer/lib/utils.js","webpack://@underlay/tasl-codemirror/./node_modules/crelt/index.es.js","webpack://@underlay/tasl-codemirror/./node_modules/lezer-tree/src/tree.ts","webpack://@underlay/tasl-codemirror/./node_modules/lezer/src/stack.ts","webpack://@underlay/tasl-codemirror/./node_modules/lezer/src/token.ts","webpack://@underlay/tasl-codemirror/./node_modules/lezer/src/decode.ts","webpack://@underlay/tasl-codemirror/./node_modules/lezer/src/parse.ts","webpack://@underlay/tasl-codemirror/./node_modules/style-mod/src/style-mod.js","webpack://@underlay/tasl-codemirror/./node_modules/w3c-keyname/index.es.js","webpack://@underlay/tasl-codemirror/webpack/bootstrap","webpack://@underlay/tasl-codemirror/webpack/runtime/define property getters","webpack://@underlay/tasl-codemirror/webpack/runtime/hasOwnProperty shorthand","webpack://@underlay/tasl-codemirror/webpack/runtime/make namespace object","webpack://@underlay/tasl-codemirror/./demo/index.js"],"names":["readOnlyConfig","EditorView","lineNumbers","defaultHighlightStyle","highlightSelectionMatches","syntax","editableConfig","basicSetup","keymap","defaultKeymap","commentKeymap","key","preventDefault","run","indentMore","indentLess","errorUnit","Schema","lintView","state","cursor","syntaxTree","slice","from","to","doc","sliceString","error","node","message","LintError","parseState","namespaces","references","types","defaultTypes","schema","diagnostics","name","firstChild","push","severity","errors","type","isError","namespace","term","getChild","uriPattern","namespacePattern","identifier","prefix","expression","getType","uri","getURI","terms","getChildren","uris","map","length","sourceNode","labelNode","targetNode","source","label","target","components","ul","head","reportChildErrors","nextSibling","Object","entries","filter","_","base","sorted","sort","a","c","b","d","defaultNamespaces","fromEntries","makeLinter","onChange","linter","view","props","undefined","parseURI","e","value","datatype","component","options","option","Error","parent","LezerLanguage","parser","indentNodeProp","Product","continuedIndent","except","Coproduct","foldNodeProp","subtree","styleTags","Comment","tags","Prefix","TypeName","Variable","Term","Uri","Literal","Pointer","Optional","edge","list","keyword","languageData","closeBrackets","brackets","indentOnInput","commentTokens","line","initialValue","extensions","EditorState","document","getElementById","openLintPanel","focus"],"mappings":"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ACA;AACA;AACA,qBAAqB,kCAAkC;AACvD;AACA;AACA;AACA;AACA,SAAS,SAAS;AAClB;AACA;AACA;AACA,yBAAyB,oBAAoB,KAAK,OAAO,GAAG,kBAAkB;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,kDAAkD;AACxE,wBAAwB;AACxB,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,oBAAoB;AAC3C,uBAAuB,kEAAW,qBAAqB,oEAAa;AACpE;AACA;AACA,6BAA6B,kEAAW;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,sCAAsC;AACnD;AACA;AACA;AACA,wBAAwB,kEAAW;AACnC,8CAA8C,oEAAa;AAC3D,gEAAgE,oEAAa;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,sBAAsB;AACjF,2BAA2B,kEAAW;AACtC;AACA;AACA,qBAAqB,oEAAa;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mFAAmF,yBAAyB;AAC5G,uBAAuB,kEAAW;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,oEAAa;AACtC;AACA;AACA;AACA;AACA,iBAAiB,oEAAa;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,oEAAa,CAAC,kEAAW;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,yBAAyB,gEAAY;AACrC;AACA,eAAe,qEAAa;AAC5B;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA,CAAC;;AAED;AACA,kBAAkB,uEAAoB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,qCAAqC,gBAAgB;AACrD,sCAAsC,eAAe;AACrD,8BAA8B,0BAA0B;AACxD,6BAA6B,0BAA0B;AACvD;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,oBAAoB;AACpB,KAAK;AACL;AACA,oBAAoB;AACpB,KAAK;AACL;AACA,oBAAoB;AACpB,KAAK;AACL;AACA,oBAAoB;AACpB,KAAK;AACL;AACA,oBAAoB;AACpB,KAAK;AACL;AACA,oBAAoB;AACpB,KAAK;AACL;AACA,oBAAoB;AACpB,KAAK;AACL;AACA,oBAAoB;AACpB,KAAK;AACL;AACA,oBAAoB,wBAAwB;AAC5C,KAAK;AACL;AACA,oBAAoB;AACpB,KAAK;AACL;AACA,oBAAoB;AACpB;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,4BAA4B,cAAc;AAC1C,aAAa,oBAAoB;AACjC;AACA;AACA;AACA,yBAAyB,iEAAU;AACnC;AACA;AACA,6BAA6B,iEAAU;AACvC,aAAa,gBAAgB;AAC7B,uBAAuB,kBAAkB;AACzC;AACA;AACA;AACA;AACA;AACA,6BAA6B,iEAAU;AACvC;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,iEAAU;AAC5C;AACA;AACA;AACA;AACA;AACA,yBAAyB,iEAAU;AACnC;AACA,yBAAyB,iEAAU;AACnC;AACA;AACA;AACA;AACA,oBAAoB,iEAAU;AAC9B,SAAS,OAAO;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA,gBAAgB;AAChB;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,oBAAoB;AACjC;AACA;AACA;AACA;AACA,2CAA2C,wBAAwB;AACnE;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,aAAa,kBAAkB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE,KAAK;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,gEAAa;AAC3D;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,iCAAiC;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,6FAA6F,qBAAqB,2CAA2C;AAC7J;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,6CAA6C;AAChE,iBAAiB,gDAAgD;AACjE;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,8BAA8B;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,cAAc;AAC/B;AACA,kCAAkC,yEAAqB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,aAAa;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,sEAAkB;AAChD,8BAA8B,sEAAkB;AAChD,wBAAwB,sEAAkB;AAC1C,2BAA2B,+EAA+E;AAC1G,CAAC;AACD,0BAA0B,sEAAkB;AAC5C,wBAAwB,qEAAiB;AACzC,cAAc,gCAAgC,EAAE;AAChD,uBAAuB,yBAAyB,EAAE;AAClD;AACA,QAAQ,0EAAoB;AAC5B,QAAQ,oFAAiC;AACzC;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0EAA0E,SAAS;AACnF;AACA;AACA;AACA;AACA,uBAAuB,0CAA0C;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,0CAA0C;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,0CAA0C;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,uEAAoB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,yEAAqB;AAC3D;AACA,SAAS;AACT,uBAAuB,yBAAyB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,mEAAY;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,yEAAqB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,gCAAgC,0CAA0C;AAC1E,YAAY,mEAAY;AACxB,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,yBAAyB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,uCAAuC;AACvE;AACA,CAAC;AACD;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,oCAAoC,2CAA2C;AAC/E;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,UAAU;AACzC,0CAA0C,iEAAU;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,8BAA8B,gBAAgB,UAAU,MAAM;AAC9D;AACA,+BAA+B,mBAAmB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,0BAA0B;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,oEAAiB,EAAE,2BAA2B,6DAAU;AAC1E;AACA;AACA,6BAA6B,iEAAU;AACvC;AACA;AACA,uBAAuB,cAAc;AACrC,KAAK,EAAE;AACP,iBAAiB,kEAAe,EAAE,QAAQ,iEAAU,kBAAkB;AACtE;AACA;AACA;AACA;AACA,oBAAoB,iEAAc;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,sEAAkB;AACpC,yBAAyB,oCAAoC;AAC7D,CAAC;AACD,oBAAoB,sEAAkB;AACtC,qBAAqB,qEAAiB;AACtC,cAAc,aAAa,EAAE;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,kBAAkB,8EAA2B,4BAA4B,kEAAe;AACxF,CAAC;AACD;AACA,WAAW,0EAAsB,+CAA+C,yEAAqB;AACrG;AACA;AACA;AACA;AACA,oBAAoB,MAAM,KAAK,GAAG,MAAM,KAAK,KAAK,GAAG,MAAM,KAAK,OAAO,GAAG;AAC1E;AACA,aAAa,oCAAoC;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,EAAE,QAAQ,cAAc;AACxD;AACA;AACA;AACA;AACA,aAAa,eAAe;AAC5B,oBAAoB,WAAW,mBAAmB,2DAAO,QAAQ;AACjE;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA,aAAa,kBAAkB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,uBAAuB,kBAAkB;AACzC;AACA;AACA;AACA,2BAA2B,8BAA8B;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,6DAA6D;AAClE,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,gEAAY;AAClC,mBAAmB,qDAAqD;AACxE,CAAC;AACD,yBAAyB,iEAAa,CAAC,iEAAc;AACrD;AACA;AACA;AACA;AACA,yCAAyC,gBAAgB,2BAA2B;AACpF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wEAAwE,oBAAoB;AAC5F,aAAa,QAAQ;AACrB,wBAAwB;AACxB,qDAAqD,qEAAiB;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,4BAA4B;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;;AAEA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,kEAAQ;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,yCAAyC;AAC9C,KAAK,sCAAsC;AAC3C,KAAK,uDAAuD;AAC5D,KAAK,sDAAsD;AAC3D,KAAK,8DAA8D;AACnE,KAAK,6DAA6D;AAClE,KAAK;AACL;AACA,4BAA4B,iEAAa,CAAC,kEAAe;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE2T;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACtrCjN;AACvD;AACE;AACA;AACa;AACH;AACL;AACJ;AACI;AACO;AACmB;AACF;AACD;AACxB;AACqB;AACX;AAChB;;AAEnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,oEAAW;AACf,IAAI,4EAAqB;AACzB,IAAI,iEAAO;AACX,IAAI,iEAAU;AACd,IAAI,oEAAa;AACjB,IAAI,0FAAsC;AAC1C,IAAI,wEAAa;AACjB,IAAI,8EAAqB;AACzB,IAAI,+EAAe;AACnB,IAAI,6EAAa;AACjB,IAAI,8EAAc;AAClB,IAAI,6FAAoB;AACxB,IAAI,0EAAmB;AACvB,IAAI,kFAAyB;AAC7B,IAAI,4DAAS;AACb,WAAW,+EAAmB;AAC9B,WAAW,oEAAa;AACxB,WAAW,iEAAY;AACvB,WAAW,mEAAa;AACxB,WAAW,6DAAU;AACrB,WAAW,oEAAa;AACxB,WAAW,4EAAgB;AAC3B,WAAW,8DAAU;AACrB;AACA;;AAEsB;;;;;;;;;;;;;;;;;;;;;;;AC/E6B;AACmE;AACrD;AACiB;AAC3B;;AAEvD;AACA,2BAA2B;AAC3B,gBAAgB,KAAK;AACrB;AACA,2BAA2B,sEAAkB;AAC7C;AACA,+CAA+C,sEAAkB;AACjE;AACA;AACA,CAAC;AACD,0BAA0B,sEAAkB;AAC5C,yBAAyB,8BAA8B;AACvD,CAAC;AACD,wCAAwC,iEAAU;AAClD;AACA;AACA;AACA,qBAAqB,qEAAiB;AACtC,cAAc,QAAQ,qEAAc,CAAC,EAAE;AACvC;AACA;AACA;AACA;AACA;AACA,wBAAwB,qEAAc;AACtC;AACA;AACA;AACA;AACA,sCAAsC,6DAA6D;AACnG;AACA,sCAAsC,uCAAuC;AAC7E;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,6EAA0B;AACtC;AACA,8BAA8B;AAC9B;AACA,mBAAmB,2BAA2B;AAC9C;AACA;AACA,WAAW,oEAAa;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,oEAAa,CAAC,kEAAW;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,kBAAkB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA,kFAAkF,kEAAW;AAC7F,4BAA4B,WAAW,iEAAiE;AACxG,+BAA+B,0EAAsB;AACrD,qCAAqC,4EAAwB;AAC7D;AACA;AACA,gBAAgB;AAChB,KAAK;AACL;AACA,wCAAwC,uBAAuB;AAC/D;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,kEAAW;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,yBAAyB,oEAAa,CAAC,kEAAW;AAClD;AACA;AACA;AACA,WAAW,oEAAa,CAAC,kEAAW;AACpC;AACA;AACA;AACA;AACA,oBAAoB,YAAY,iCAAiC,GAAG,gCAAgC;AACpG;AACA,uBAAuB,yEAAqB;AAC5C;AACA;AACA,oBAAoB,WAAW,yCAAyC;AACxE;AACA,uBAAuB,0EAAsB;AAC7C,gBAAgB;AAChB,KAAK;AACL;AACA;AACA,qBAAqB,4EAAwB;AAC7C,KAAK;AACL;AACA;AACA;AACA;AACA,mBAAmB,0EAAsB;AACzC;AACA,KAAK;AACL;AACA,mBAAmB,0EAAsB;AACzC;AACA,8CAA8C,OAAO;AACrD,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,YAAY,kCAAkC,GAAG,gCAAgC;AACrG;AACA,uBAAuB,yEAAqB;AAC5C;AACA;AACA;AACA,wBAAwB,WAAW,mCAAmC;AACtE;AACA,2BAA2B,0EAAsB;AACjD;AACA;AACA;AACA,wBAAwB,QAAQ,0EAAsB;AACtD;AACA;AACA;AACA;AACA;AACA,oBAAoB,WAAW,mDAAmD;AAClF;AACA,uBAAuB,0EAAsB;AAC7C;AACA,qDAAqD,qEAAiB;AACtE;AACA,qEAAqE,qEAAiB;AACtF,wBAAwB,WAAW,mCAAmC;AACtE;AACA,2BAA2B,0EAAsB;AACjD;AACA,gBAAgB;AAChB,KAAK;AACL;AACA;AACA,qBAAqB,4EAAwB;AAC7C,KAAK;AACL;AACA;AACA,eAAe,qEAAU;AACzB;AACA;;AAEkF;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC7ME;AACoB;AACtD;AACa;AACgE;AACzF;;AAEtC;AACA,WAAW,0EAAsB;AACjC;AACA;AACA,yBAAyB,+CAA+C,4EAAwB,uBAAuB;AACvH;AACA,kBAAkB,kBAAkB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,0EAAsB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,wEAAwE,gEAAa;AACrF;AACA,yEAAyE,gEAAa;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0EAA0E,gEAAa;AACvF;AACA,2EAA2E,gEAAa;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA,cAAc,qEAAU;AACxB,gCAAgC,yDAAiB,GAAG,yDAAiB;AACrE;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,6EAAa,uBAAuB,6EAAa;AACvF;AACA;AACA;AACA,WAAW,0EAAsB;AACjC;AACA;AACA,8GAA8G,gEAAa;AAC3H;AACA,+GAA+G,gEAAa;AAC5H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,0EAAsB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,0EAAsB;AAC7E;AACA,qDAAqD,0EAAsB;AAC3E;AACA;AACA,uBAAuB,6EAAa;AACpC,eAAe,6EAAa;AAC5B,kCAAkC,6EAAa;AAC/C,iDAAiD,6EAAa;AAC9D;AACA;AACA;AACA;AACA,wBAAwB,yEAAqB,uBAAuB,0EAAsB;AAC1F,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,kBAAkB;AAClD;AACA;AACA,gCAAgC,kBAAkB;AAClD;AACA;AACA;AACA,eAAe,yEAAqB;AACpC,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wEAAwE,gEAAa;AACrF;AACA,yEAAyE,gEAAa;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0EAA0E,gEAAa;AACvF;AACA,2EAA2E,gEAAa;AACxF;AACA;AACA;AACA;AACA;AACA,gHAAgH,gEAAa;AAC7H;AACA,iHAAiH,gEAAa;AAC9H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,0EAAsB;AAC/E;AACA,uDAAuD,0EAAsB;AAC7E;AACA,yBAAyB,kBAAkB;AAC3C,4BAA4B,YAAY;AACxC;AACA;AACA;AACA,uBAAuB,kBAAkB;AACzC,4BAA4B,2BAA2B;AACvD;AACA;AACA;AACA,yBAAyB,kBAAkB;AAC3C,4BAA4B,+CAA+C;AAC3E;AACA;AACA;AACA,uBAAuB,kBAAkB;AACzC,4BAA4B,8DAA8D;AAC1F;AACA;AACA;AACA,oBAAoB,kBAAkB;AACtC,2BAA2B,aAAa,oCAAoC,eAAe,4EAAwB,uBAAuB;AAC1I;AACA;AACA;AACA,qBAAqB,kBAAkB;AACvC,iDAAiD,WAAW,KAAK,yEAAqB;AACtF,2BAA2B,gBAAgB,mEAAe,uBAAuB,4EAAwB,uBAAuB;AAChI;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,kBAAkB;AAC/C;AACA;AACA,sBAAsB,qEAAU;AAChC;AACA;AACA;AACA;AACA,eAAe,yEAAqB;AACpC,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,kBAAkB;AAC9C;AACA;AACA,wBAAwB,mEAAe;AACvC;AACA,wBAAwB,mEAAe,EAAE,0EAAsB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,QAAQ;AACjB,aAAa,WAAW;AACxB;AACA;AACA;AACA;AACA;AACA,6BAA6B,QAAQ,IAAI,WAAW,WAAW,SAAS,0EAAsB;AAC9F,KAAK;AACL;AACA;AACA,4BAA4B,oCAAoC,4EAAwB,YAAY;AACpG;AACA;AACA;AACA,SAAS,QAAQ;AACjB;AACA;AACA;AACA;AACA,kBAAkB,kEAAW,yCAAyC,wEAAa,WAAW,wEAAa;AAC3G,uBAAuB,kDAAkD;AACzE;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,oEAAa,CAAC,kEAAW;AACnD;AACA;AACA;AACA,iBAAiB,uEAAgB;AACjC;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,QAAQ;AACjB,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,uEAAgB;AACnC;AACA;AACA;AACA;AACA;AACA,uBAAuB,sEAAkB;AACzC;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA,mCAAmC,kBAAkB;AACrD;AACA,0DAA0D;AAC1D;AACA;AACA;AACA;AACA,8BAA8B,gDAAgD;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,UAAU;AACrC;AACA;AACA;AACA;AACA,oBAAoB,kBAAkB;AACtC;AACA,gBAAgB,WAAW,yCAAyC,0DAAO,YAAY;AACvF,mBAAmB,0EAAsB;AACzC,KAAK;AACL,oCAAoC,oCAAoC,4EAAwB,WAAW;AAC3G;AACA;AACA;AACA,yBAAyB,kBAAkB;AAC3C;AACA;AACA,oBAAoB;AACpB;AACA,gDAAgD,uEAAgB;AAChE,4CAA4C,uEAAgB;AAC5D,gBAAgB,WAAW,gFAAgF;AAC3G,mBAAmB,0EAAsB;AACzC,KAAK;AACL;AACA;AACA,oCAAoC,uBAAuB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,uCAAuC;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,kCAAkC,GAAG,4DAA4D;AAC3H;AACA,0BAA0B,sCAAsC,GAAG,0DAA0D;AAC7H;AACA;AACA;AACA,2BAA2B,gCAAgC;AAC3D;AACA;AACA;AACA,qBAAqB,kBAAkB;AACvC;AACA,uBAAuB,kBAAkB;AACzC;AACA;AACA;AACA;AACA,0BAA0B,oFAAoF;AAC9G;AACA,0BAA0B,kFAAkF;AAC5G;AACA,2BAA2B,gCAAgC;AAC3D;AACA;AACA;AACA,qBAAqB,kBAAkB;AACvC;AACA,uBAAuB,kBAAkB;AACzC;AACA;AACA,SAAS,QAAQ,iEAAiE,WAAW;AAC7F;AACA;AACA;AACA;AACA,gBAAgB;AAChB,KAAK;AACL;AACA,mBAAmB,2CAA2C;AAC9D;AACA;AACA;AACA,wBAAwB,kBAAkB;AAC1C,oEAAoE,uBAAuB;AAC3F;AACA;AACA;AACA,qBAAqB,EAAE;AACvB,gBAAgB;AAChB,kBAAkB,qEAAU;AAC5B;AACA;AACA,qCAAqC,yDAAiB;AACtD,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,kBAAkB;AACnD,wCAAwC,WAAW;AACnD;AACA,qBAAqB,oEAAa,SAAS,sDAAsD;AACjG,qBAAqB,yEAAc;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,WAAW;AACzB;AACA;AACA,0BAA0B,uEAAY;AACtC;AACA,wBAAwB,uEAAY;AACpC,gBAAgB,WAAW,mBAAmB,0DAAO,UAAU;AAC/D,mBAAmB,0EAAsB;AACzC,KAAK;AACL,oCAAoC,uBAAuB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB,mBAAmB,yEAAqB;AACxC,KAAK;AACL;AACA;AACA;AACA;AACA,0BAA0B,kBAAkB;AAC5C;AACA,sBAAsB,oEAAa,SAAS;AAC5C;AACA;AACA,SAAS,EAAE;AACX;AACA,qBAAqB,yEAAc;AACnC;AACA;AACA;AACA,mBAAmB,uEAAY;AAC/B;AACA;AACA,0BAA0B,4DAA4D;AACtF;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,kBAAkB;AACvC;AACA,sBAAsB,sCAAsC,iEAAU,GAAG;AACzE,KAAK;AACL;AACA;AACA;AACA;AACA,qBAAqB,kBAAkB;AACvC;AACA;AACA;AACA;AACA,kBAAkB,kEAAW;AAC7B,qBAAqB,uEAAY,0BAA0B,wEAAa;AACxE;AACA;AACA,sBAAsB,mFAAmF;AACzG,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,4DAA4D;AACjE,KAAK,8DAA8D;AACnE,KAAK,wDAAwD;AAC7D,KAAK,4DAA4D;AACjE,KAAK,8DAA8D;AACnE,KAAK,0DAA0D;AAC/D,KAAK,wCAAwC;AAC7C,KAAK,yCAAyC;AAC9C,KAAK,sCAAsC;AAC3C,KAAK,wCAAwC;AAC7C,KAAK,8CAA8C;AACnD,KAAK,gCAAgC;AACrC,KAAK,qCAAqC;AAC1C,KAAK,mEAAmE;AACxE,KAAK,qEAAqE;AAC1E,KAAK,oCAAoC;AACzC,KAAK,kCAAkC;AACvC,KAAK,qCAAqC;AAC1C,KAAK,kCAAkC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,+DAA+D;AACpE,KAAK,2FAA2F;AAChG,KAAK,qEAAqE;AAC1E,KAAK,kEAAkE;AACvE,KAAK,+FAA+F;AACpG,KAAK,kEAAkE;AACvE,KAAK,yDAAyD;AAC9D,KAAK,iEAAiE;AACtE,KAAK,8DAA8D;AACnE,KAAK,+DAA+D;AACpE,KAAK,+DAA+D;AACpE,KAAK,oEAAoE;AACzE,KAAK,wDAAwD;AAC7D,KAAK,8DAA8D;AACnE,KAAK,kFAAkF;AACvF,KAAK,8DAA8D;AACnE,KAAK,+EAA+E;AACpF,KAAK,yDAAyD;AAC9D,KAAK,4CAA4C;AACjD,KAAK,+BAA+B;AACpC,KAAK,iDAAiD;AACtD,KAAK,wCAAwC;AAC7C,KAAK,uEAAuE;AAC5E,KAAK,gEAAgE;AACrE,qCAAqC,yCAAyC;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,8FAA8F;AACnG,KAAK,kGAAkG;AACvG,KAAK,sCAAsC;AAC3C,KAAK,4CAA4C;AACjD,KAAK,0CAA0C;AAC/C,KAAK,gDAAgD;AACrD,KAAK,wCAAwC;AAC7C,KAAK,gCAAgC;AACrC,KAAK,wCAAwC;AAC7C,KAAK,gCAAgC;AACrC,KAAK,gCAAgC;AACrC,KAAK,0CAA0C;AAC/C,KAAK,sCAAsC;AAC3C,KAAK;AACL;;AAEktC;;;;;;;;;;;;;;;;;;;;;;;AC1rBzpC;;AAEzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,kBAAkB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,mCAAmC;AACxC,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,cAAc;AAChD;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,QAAQ,oDAAoD;AAC5E,oBAAoB,gDAAgD;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB,uFAAuF;AACvF,oBAAoB;AACpB,uEAAuE;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,cAAc;AAC/B;AACA,wBAAwB;AACxB;AACA;AACA,2BAA2B,uCAAuC,GAAG,sCAAsC;AAC3G,uBAAuB,yEAAqB;AAC5C;AACA,SAAS;AACT;AACA;AACA;AACA,gCAAgC,qBAAqB;AACrD;AACA,wCAAwC,cAAc;AACtD,8BAA8B,iEAAiE,GAAG,qEAAqE;AACvK;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,mBAAmB,kBAAkB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA,cAAc,WAAW;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,mBAAmB;AACrD;AACA;AACA;AACA,sCAAsC,8DAA8D;AACpG;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,kCAAkC,mBAAmB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,gDAAgD;AAClF;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEyI;;;;;;;;;;;;;;;;;;;;;;;;;;AC9KlD;AACY;AAC9C;AACU;AACV;;AAErD;AACA;AACA,qCAAqC;AACrC;AACA,mBAAmB,sEAAkB,EAAE,gBAAgB;AACvD,qBAAqB,sEAAkB,EAAE,gBAAgB;AACzD;AACA;AACA,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,qEAAiB;AACnC;AACA,eAAe,kEAAe;AAC9B,KAAK;AACL;AACA;AACA;AACA;AACA,wCAAwC,oDAAoD;AAC5F;AACA,wCAAwC;AACxC,oEAAoE;AACpE;AACA;AACA;AACA;AACA,sCAAsC,OAAO;AAC7C,kDAAkD;AAClD,mCAAmC,EAAE;AACrC;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,KAAK;AACL,kBAAkB,iFAA8B;AAChD,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,sBAAsB,WAAW;AACjC,KAAK;AACL;AACA;AACA;AACA;AACA,0CAA0C;AAC1C,qBAAqB,EAAE;AACvB;AACA;AACA;AACA,wDAAwD;AACxD;AACA;AACA;AACA;AACA,oBAAoB,mEAAQ;AAC5B;AACA,2BAA2B;AAC3B,sDAAsD;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,UAAU;AACjC;AACA;AACA;AACA;AACA,SAAS,QAAQ;AACjB,qBAAqB,wBAAwB;AAC7C,mDAAmD,mEAAQ;AAC3D;AACA;AACA;AACA;AACA;AACA,uBAAuB,gDAAgD;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,+BAA+B,WAAW,GAAG,EAAE;AAC1G,mBAAmB,UAAU;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,uDAAuD;AAC5D,KAAK,yDAAyD;AAC9D,KAAK,kCAAkC;AACvC,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,mBAAmB,gEAAY;AAC/B,qBAAqB,QAAQ,qEAAa,wBAAwB;AAClE,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,qEAAkB,EAAE,2BAA2B,6DAAU;AAC5E,wBAAwB,cAAc;AACtC;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,iEAAU;AAC1C;AACA;AACA;AACA;AACA,mCAAmC,mCAAmC;AACtE;AACA;AACA;AACA;AACA,KAAK,EAAE;AACP;AACA;AACA;AACA;AACA,yBAAyB,iEAAY;AACrC;AACA;AACA;AACA;AACA;AACA,eAAe,+DAA+D;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B,mDAAmD;AACnD;AACA,kBAAkB,uEAAoB;AACtC;AACA;AACA,2BAA2B,kEAAW;AACtC;AACA;AACA;AACA,sDAAsD;AACtD,mCAAmC,EAAE;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,+BAA+B,kEAAW;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,mEAAQ;AAClC;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,KAAK;AACL;AACA;AACA,QAAQ,+DAAM;AACd;AACA,2BAA2B,QAAQ,yFAAyF,qEAAc,CAAC,EAAE;AAC7I;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,uCAAuC,mCAAmC;AAC1E;AACA;AACA,gCAAgC,mEAAQ;AACxC;AACA,uCAAuC,gCAAgC;AACvE;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,kBAAkB,uEAAoB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,CAAC;;AAEwF;;;;;;;;;;;;;;;;;;;;;;AC5QqB;AACtC;AACD;;AAEvE;AACA;AACA;AACA,2BAA2B,iEAAU;AACrC;AACA;AACA;AACA;AACA;AACA,kBAAkB,aAAa;AAC/B;AACA,aAAa,YAAY,4DAAK,iBAAiB;AAC/C;AACA;AACA,iCAAiC,uEAAmB;AACpD;AACA;AACA;AACA;AACA,mBAAmB,qEAAc;AACjC;AACA;AACA;AACA;AACA;AACA,sBAAsB,gEAAY;AAClC;AACA;AACA;AACA,sEAAsE;AACtE;AACA,kBAAkB,uEAAoB;AACtC;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,qBAAqB,gEAAY;AACjC;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,uEAAoB;AACvC;AACA;AACA;AACA,6BAA6B,iEAAU;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,iEAAc;AAChD;AACA;AACA;AACA;AACA;AACA,oCAAoC,iEAAc;AAClD;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,aAAa,iFAA8B;AAC3C;AACA;AACA,2CAA2C,gEAAa,IAAI,8BAA8B,IAAI;AAC9F,KAAK;AACL,CAAC;AACD,uBAAuB,2CAA2C;AAClE;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,oEAAa;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,iEAAU;AACvC,4BAA4B,iEAAU;AACtC;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,iEAAiE;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,yBAAyB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,cAAc;AACjC;AACA;AACA;AACA;AACA;AACA,0BAA0B,gEAAY;AACtC,yBAAyB,gEAAY;AACrC;AACA,eAAe,qEAAa,UAAU,2CAA2C,EAAE;AACnF;AACA,6CAA6C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,eAAe,oCAAoC;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,4CAA4C,EAAE;AACjE;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEyE;;;;;;;;;;;;;;;;;;;;;;;;;;AC7VnC;AACE;AACmC;AACtB;AACE;AACK;;AAE5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,kBAAkB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,gDAAQ;AACjC,2BAA2B,gEAAY;AACvC,uBAAuB,6CAA6C;AACpE,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,+CAA+C;AAChE;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,0DAAmB;AACzC,iDAAiD,UAAU,YAAY;AACvE;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,kDAAW;AACrC;AACA;AACA;AACA;AACA,YAAY,4EAAyB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,iEAAa,CAAC,oEAAiB;AACvD;AACA,CAAC;AACD;AACA;AACA;AACA,oBAAoB,qEAAU;AAC9B;AACA;AACA;AACA,mBAAmB,qEAAU;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,kEAAe;AAClC,0BAA0B,sEAAe;AACzC,kBAAkB,WAAW;AAC7B;AACA,wFAAwF,kEAAe,EAAE,eAAe;AACxH,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,mDAAmD,QAAQ;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,QAAQ;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD;AACrD,iCAAiC,GAAG;AACpC;AACA,wBAAwB,GAAG;AAC3B,yBAAyB,GAAG;AAC5B,wBAAwB,GAAG;AAC3B,mBAAmB,GAAG;AACtB,mBAAmB,GAAG;AACtB,mBAAmB,GAAG;AACtB,mBAAmB,GAAG;AACtB,mBAAmB,GAAG;AACtB,mBAAmB,GAAG;AACtB,mBAAmB,GAAG;AACtB,mBAAmB,GAAG;AACtB,mBAAmB,GAAG;AACtB,mBAAmB,GAAG;AACtB,mBAAmB,GAAG;AACtB,mBAAmB,GAAG;AACtB,sBAAsB,GAAG;AACzB,mBAAmB;;AAEmE;;;;;;;;;;;;;;;;;;;;;;;;;;ACtmB0B;AAC7D;;AAEnD,oBAAoB,qEAAiB;AACrC;AACA;AACA;AACA;AACA;AACA,uBAAuB,qEAAiB;AACxC;AACA;AACA;AACA;AACA;AACA,wBAAwB,gEAAY;AACpC,sBAAsB,gEAAY;AAClC;AACA,eAAe,qEAAa;AAC5B;AACA;AACA,SAAS,GAAG,8CAA8C;AAC1D;AACA,CAAC;AACD,qBAAqB,qEAAiB;AACtC;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,4EAAwB;AAClD;AACA;AACA,iCAAiC,oEAAgB,6BAA6B,yEAAqB;AACnG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,4BAA4B;AAC5B;AACA;AACA;AACA,QAAQ,8EAA2B;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,sBAAsB,kBAAkB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,mBAAmB;AAC1C;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4EAA4E;AAC5E;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,0EAAsB;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,mCAAmC;AAChF,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,aAAa;AAC1D;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,gDAAgD;AACrD,KAAK,oEAAoE;AACzE,KAAK,yDAAyD;AAC9D,KAAK;AACL;;AAEmI;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACnT/D;AACV;AACwC;AAC/C;;AAEnD;AACA;AACA,6BAA6B,gDAAQ;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,gEAAY;AACvB;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,wFAAoC;AACjD,kCAAkC,yEAAqB,WAAW,QAAQ,yBAAyB,EAAE,EAAE;AACvG;AACA;AACA;AACA,YAAY,+EAA2B;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,gCAAgC;AACrD;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,WAAW;AAC5C;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,yBAAyB,aAAa;AACtC;AACA;AACA,kBAAkB,0DAAO;AACzB,qGAAqG,sEAAkB,EAAE,MAAM,OAAO,kDAAU,GAAG,2BAA2B;AAC9K;AACA,2CAA2C;AAC3C;AACA;AACA;AACA;AACA,iBAAiB,qEAAiB;AAClC;AACA,yFAAyF,kDAAU,GAAG,gCAAgC;AACtI;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,oBAAoB,sEAAkB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,8BAA8B;AACvD;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,kDAAU;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,kDAAU;AACnC;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA,yDAAyD,4DAAoB;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,4DAAoB;AACzE;AACA;AACA;AACA,mBAAmB,4BAA4B;AAC/C;AACA;AACA;AACA;AACA;AACA,aAAa,qCAAqC;AAClD;AACA;AACA;AACA,+EAA+E,yBAAyB;AACxG,wBAAwB,iEAAyB;AACjD,mBAAmB,kDAAU;AAC7B,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA,sCAAsC,WAAW;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,yBAAyB;AAChD,iBAAiB,WAAW;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,WAAW;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,mCAAmC;AAC7E;AACA,2BAA2B,4CAAI,CAAC,qDAAa;AAC7C,aAAa;AACb,2BAA2B,uBAAuB;AAClD;AACA;AACA;AACA;AACA,WAAW,iEAAyB,cAAc,6CAA6C;AAC/F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,UAAU;AAC3B;AACA,oBAAoB,uEAAoB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA,+CAA+C,2BAA2B;AAC1E;AACA;AACA;AACA;AACA,wDAAwD;AACxD;AACA;AACA;AACA;AACA,mBAAmB;AACnB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,kEAAkE;AAClG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,oBAAoB,UAAU,qBAAqB,EAAE;AACrD,CAAC;AACD;AACA,iBAAiB,gEAAY;AAC7B,wBAAwB,+CAA+C,EAAE;AACzE;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+GAA+G,qBAAqB,WAAW,EAAE;AACjJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,sBAAsB,gEAAY;AAClC;AACA;AACA;AACA,mBAAmB,gEAAY;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,UAAU;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,+DAAW;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,kEAAW;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,gDAAQ;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,MAAM;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,yDAAiB;AAC3D;AACA;AACA;AACA;AACA;AACA,sBAAsB,UAAU;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,KAAK;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,mCAAmC;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,oBAAoB,KAAK;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA,WAAW,oFAAgC;AAC3C,4CAA4C,yEAAqB;AACjE;AACA;AACA;AACA;AACA,8BAA8B,OAAO;AACrC;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,kBAAkB,OAAO;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,4DAA4D;AAC1F;AACA,sCAAsC,UAAU;AAChD,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA,oBAAoB,gEAAY;AAChC;AACA;AACA;AACA;AACA,yBAAyB,gDAAQ;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,KAAK;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEwY;;;;;;;;;;;;;;;;;;;;;;;;;AC11BvR;AAChD;AACT;AACa;AAC7C;;AAExB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,OAAO;AACtE;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,wDAAwD;AACxD;AACA,YAAY,iFAA8B;AAC1C,qBAAqB,kBAAkB;AACvC,6EAA6E,kEAAe,GAAG,iEAAc;AAC7G;AACA;AACA,aAAa;AACb,YAAY,8DAAM;AAClB,YAAY,sEAAY;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,sEAAkB;AAC/C,oBAAoB,sEAAkB;AACtC,2BAA2B,sEAAkB;AAC7C,kBAAkB,qEAAiB;AACnC;AACA,6BAA6B,kEAAe;AAC5C,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,iEAAc;AAC3C;AACA,0BAA0B,kEAAe;AACzC,yCAAyC,QAAQ,iEAAU,6BAA6B;AACxF;AACA,yBAAyB;AACzB,0BAA0B,oEAAiB;AAC3C;AACA;AACA,yBAAyB;AACzB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,mBAAmB,sEAAkB,YAAY,MAAM,QAAQ,cAAc,6BAA6B,EAAE;AAC5G,QAAQ,8EAA2B;AACnC,CAAC;AACD,mBAAmB,kEAAe,EAAE,QAAQ,iEAAU,sBAAsB;AAC5E;AACA,SAAS,cAAc;AACvB;AACA,wFAAwF,OAAO;AAC/F;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,MAAM,8CAAG;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB,sDAAsD;AACtD,gBAAgB,gEAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,iCAAiC;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,aAAa,mCAAmC,wBAAwB;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,yCAAyC;AAC9C,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,uEAAoB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,QAAQ;AAC7B;AACA;AACA;AACA;AACA;AACA,iBAAiB,YAAY,CAAC,mEAAY,yBAAyB,EAAE;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,2BAA2B,OAAO;AAClC,2BAA2B,iBAAiB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,8CAAG,QAAQ,QAAQ,iEAAU,uCAAuC,EAAE,8CAAG,UAAU,QAAQ,iEAAU,oBAAoB;AACpI;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA,YAAY,8CAAG;AACf;AACA,eAAe,8CAAG;AAClB,mBAAmB,iEAAU;AAC7B;AACA;AACA,SAAS;AACT,KAAK,wBAAwB,8CAAG,SAAS,QAAQ,iEAAU,sBAAsB;AACjF;AACA,+BAA+B,6DAAU;AACzC;AACA;AACA;AACA;AACA,eAAe,4CAA4C;AAC3D;AACA,eAAe,8CAAG,UAAU,QAAQ,iEAAU,2CAA2C;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA,kEAAkE;AAClE;AACA;AACA,kEAAkE;AAClE;AACA;AACA,2CAA2C;AAC3C;AACA;AACA,2CAA2C;AAC3C;AACA;AACA,2CAA2C;AAC3C;AACA;AACA,uFAAuF;AACvF,qBAAqB,aAAa;AAClC,+BAA+B,iBAAiB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,uBAAuB;AAClD;AACA;AACA;AACA;AACA,oBAAoB,8CAAG;AACvB;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,mBAAmB,8CAAG,mBAAmB,8CAAG;AAC5C;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,uBAAuB;AAC9C;AACA;AACA;AACA;AACA;AACA,aAAa,wBAAwB;AACrC;AACA,2EAA2E,OAAO;AAClF;AACA,2BAA2B,uBAAuB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,6FAA6F;AAC3H,yBAAyB,aAAa;AACtC;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,6CAA6C;AACrE;AACA;AACA,SAAS;AACT;AACA,iBAAiB,eAAe;AAChC,uBAAuB,4BAA4B;AACnD;AACA;AACA;AACA;AACA;AACA,kDAAkD,MAAM;AACxD;AACA,oCAAoC,SAAS,UAAU;AACvD;AACA,kBAAkB,uEAAoB;AACtC;AACA;AACA;AACA;AACA,KAAK;AACL,0BAA0B,+BAA+B;AACzD,4BAA4B,iCAAiC;AAC7D,yBAAyB,+BAA+B;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL,yBAAyB,qCAAqC;AAC9D,2BAA2B,uCAAuC;AAClE,wBAAwB,qCAAqC;AAC7D,0BAA0B,+BAA+B;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,oBAAoB;AACpB,KAAK;AACL;AACA,oBAAoB;AACpB,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,oBAAoB,yBAAyB;AAC7C;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,CAAC;;AAE4F;;;;;;;;;;;;;;;;;;;;ACtgBnB;AACnB;AACoB;AACrC;;AAEtC,kBAAkB,uEAAoB;AACtC,uBAAuB,gBAAgB;AACvC,0BAA0B;AAC1B,CAAC;AACD,wDAAwD;AACxD,8BAA8B,gEAAY;AAC1C;AACA,eAAe,qEAAa;AAC5B;AACA;AACA;AACA,SAAS;AACT;AACA,CAAC;AACD,qBAAqB,kEAAe,EAAE,QAAQ,iEAAU,qBAAqB,qBAAqB,kEAAe,EAAE,QAAQ,iEAAU,wBAAwB;AAC7J,6BAA6B,qEAAiB;AAC9C,cAAc,QAAQ,kEAAe,CAAC,EAAE;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,iEAAc;AAC7B,KAAK;AACL,kBAAkB,8EAA2B;AAC7C,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA,qCAAqC,yDAAiB,GAAG,yDAAiB;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD;AACnD;AACA,eAAe,qEAAU;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C;AACA;AACA;AACA;AACA;AACA,4BAA4B,0BAA0B,mCAAmC;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,0BAA0B,mCAAmC;AAC7F;AACA;AACA,SAAS;AACT,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA,0BAA0B,oDAAoD;AAC9E;AACA;AACA;AACA;AACA,uFAAuF,YAAY;AACnG;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC,wBAAwB,0BAA0B,6CAA6C;AAC/F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,oCAAoC;AAC5D;;AAE0C;;;;;;;;;;;;;;;;;;;ACrI8C;AACzC;;AAE/C,oBAAoB,gEAAY;AAChC;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,gEAAY;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,uEAAoB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,aAAa,iFAA8B,YAAY,qEAAqE;AAC5H,CAAC;AACD;AACA,WAAW,iEAAU,wBAAwB,YAAY;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,iEAAU;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,uEAAoB;AACtC;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,CAAC;;AAEsC;;;;;;;;;;;;;;;;;;;AC7LU;;AAEjD;AACA;AACA;AACA;AACA;AACA,eAAe,sBAAsB;AACrC;AACA,4BAA4B,kCAAkC;AAC9D;AACA;AACA;AACA,+BAA+B,oEAAgB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,oCAAoC;AACtD;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uFAAuF,OAAO;AAC9F;AACA;AACA;AACA;AACA;AACA,uBAAuB,uBAAuB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,iEAAiE;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,2CAA2C;AAChF;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,uBAAuB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,cAAc;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,uBAAuB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,yCAAyC;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,8CAA8C;AACnE,mBAAmB,4CAA4C;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,iBAAiB;AACxC,mCAAmC,uBAAuB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,8CAA8C;AACnE;AACA;AACA;AACA,2CAA2C,QAAQ;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,QAAQ;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,kBAAkB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,wBAAwB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,cAAc;AACjC;AACA;AACA;AACA;AACA;AACA,6CAA6C,OAAO;AACpD;AACA;AACA;AACA;AACA,kCAAkC,YAAY;AAC9C;AACA;AACA;AACA;AACA;AACA,mBAAmB,kBAAkB;AACrC;AACA;AACA;AACA;AACA;AACA;;AAEwD;;;;;;;;;;;;;;;;;;AC7rBC;AACN;AACa;;AAEhE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,cAAc;AAC7C;AACA;AACA,4BAA4B,yEAAqB;AACjD;AACA;AACA;AACA;AACA,+BAA+B,cAAc;AAC7C;AACA,wBAAwB,iEAAU,yCAAyC,iEAAU;AACrF;AACA,4BAA4B,yEAAqB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,qCAAqC;AACxE;AACA;AACA;AACA;AACA;AACA,cAAc,kEAAW;AACzB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,0EAAsB;AAC7C;AACA,uBAAuB,0EAAsB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,oFAAiC;AAC5C;;AAEgC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AChFyE;AACmB;AACvD;AACT;AACpC;AACiC;;AAEzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,yBAAyB;AAChD;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,8BAA8B,iCAAiC,gBAAgB,iEAAU,cAAc;AACvG,gBAAgB,iEAAU,WAAW,eAAe,wBAAwB;AAC5E;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,0EAAsB;AAC7C;AACA,SAAS;AACT;AACA;AACA;AACA,kCAAkC;AAClC;AACA,2BAA2B,kCAAkC;AAC7D;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA,KAAK;AACL;AACA,YAAY;AACZ;AACA,qBAAqB,sEAAkB;AACvC,oBAAoB,qEAAiB;AACrC,cAAc,aAAa,EAAE;AAC7B;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,kBAAkB,sEAAkB;AACpC,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,gEAAQ;AACxB;AACA;AACA,yEAAyE,UAAU,8DAAM,6BAA6B;AACtH;AACA,SAAS;AACT,gBAAgB,gEAAQ;AACxB;AACA;AACA;AACA;AACA;AACA,kBAAkB,uEAAoB;AACtC;AACA;AACA,oBAAoB;AACpB;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,wBAAwB,gEAAY;AACpC;AACA,eAAe,qEAAa;AAC5B;AACA;AACA;AACA,SAAS;AACT;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,uEAAgB;AACnC,kDAAkD,qEAAiB;AACnE;AACA;AACA;AACA;AACA,mBAAmB,uEAAgB;AACnC,gDAAgD,qEAAiB;AACjE;AACA;AACA;AACA;AACA;AACA,kBAAkB,kEAAe,EAAE,QAAQ,iEAAU,oBAAoB;AACzE,sBAAsB,kEAAe,EAAE,QAAQ,iEAAU,yBAAyB;AAClF,yBAAyB,uEAAoB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACA,mBAAmB,kEAAe;AAClC;AACA;AACA;AACA,uBAAuB,kEAAe;AACtC;AACA;AACA;AACA,uBAAuB,kEAAe;AACtC;AACA;AACA;AACA;AACA,uBAAuB,kEAAe;AACtC;AACA;AACA,uBAAuB,kEAAe;AACtC;AACA;AACA;AACA;AACA;AACA,qBAAqB,WAAW;AAChC,sFAAsF,qEAAiB;AACvG,oFAAoF,qEAAiB;AACrG;AACA;AACA;AACA;AACA;AACA,+BAA+B,kEAAe;AAC9C;AACA;AACA;AACA,eAAe,iEAAc;AAC7B;AACA,CAAC;AACD;AACA,CAAC;AACD,qBAAqB,uEAAoB;AACzC,wBAAwB,+BAA+B;AACvD,qCAAqC;AACrC,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,sBAAsB;AACvC;AACA,iBAAiB,sEAAkB;AACnC,oBAAoB,sEAAkB;AACtC,oBAAoB,qEAAiB;AACrC;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,kBAAkB,sEAAkB;AACpC,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,kEAAe,EAAE,QAAQ,iEAAU,iBAAiB,uBAAuB,kEAAe,EAAE,QAAQ,iEAAU,0BAA0B;AAC1J,0BAA0B,uEAAoB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,eAAe;AAC9B;AACA,mBAAmB,kEAAe;AAClC;AACA;AACA,0BAA0B,sEAAe;AACzC;AACA,iBAAiB,WAAW;AAC5B;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,WAAW;AACpB;AACA;AACA;AACA,mBAAmB,aAAa,mCAAmC,wBAAwB;AAC3F;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,QAAQ;AACnD,SAAS,QAAQ;AACjB;AACA;AACA;AACA;AACA,mBAAmB,aAAa,qCAAqC,wBAAwB;AAC7F;AACA;AACA,CAAC;AACD;AACA,4CAA4C,QAAQ;AACpD;AACA;AACA,oBAAoB,yEAAqB;AACzC;AACA;AACA,mBAAmB,YAAY,0EAAsB,UAAU;AAC/D;AACA,CAAC;AACD;AACA,iCAAiC,kBAAkB;AACnD;AACA;AACA;AACA,SAAS,WAAW;AACpB;AACA,yEAAyE,kBAAkB;AAC3F;AACA;AACA;AACA;AACA,oBAAoB,yEAAqB;AACzC;AACA,2BAA2B,gBAAgB,mEAAe,gBAAgB;AAC1E;AACA;AACA;AACA,0CAA0C,QAAQ;AAClD,SAAS,QAAQ;AACjB;AACA;AACA,SAAS,WAAW;AACpB;AACA,sBAAsB,sDAAsD;AAC5E;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,mBAAmB,kDAAkD;AACrE;AACA;AACA;AACA,CAAC;AACD;AACA;AACA,yCAAyC,QAAQ;AACjD;AACA;AACA,aAAa,WAAW;AACxB,sBAAsB,kCAAkC;AACxD;AACA;AACA;AACA,mBAAmB,UAAU;AAC7B;AACA,CAAC;AACD;AACA,SAAS,QAAQ;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,8BAA8B;AACjE;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,gEAAQ;AAC5B;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB,8CAA8C,2BAA2B,EAAE;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,gEAAQ;AACxB;AACA;AACA,mBAAmB,iCAAiC;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,mEAAmE;AACxE,KAAK,8EAA8E;AACnF,KAAK,iFAAiF;AACtF,KAAK,qEAAqE;AAC1E,KAAK,kDAAkD;AACvD,KAAK;AACL;AACA;AACA,wBAAwB,uCAAuC;AAC/D,sBAAsB,8CAAG;AACzB;AACA;AACA;AACA,eAAe,iEAAU;AACzB;AACA;AACA;AACA,KAAK;AACL,uBAAuB,8CAAG;AAC1B;AACA;AACA;AACA,eAAe,iEAAU;AACzB;AACA;AACA;AACA,KAAK;AACL,oBAAoB,8CAAG;AACvB;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,YAAY,uEAAgB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,8CAAG,YAAY,QAAQ,iEAAU,2BAA2B;AAC3E;AACA,gBAAgB,8CAAG,SAAS,qBAAqB;AACjD;AACA;AACA;AACA;AACA,QAAQ,8CAAG;AACX,QAAQ,8CAAG;AACX;AACA;AACA;AACA,QAAQ,8CAAG,YAAY,sFAAsF;AAC7G,QAAQ,8CAAG,SAAS,4BAA4B,wCAAwC;AACxF;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA,SAAS,WAAW;AACpB;AACA;AACA;AACA;AACA,uBAAuB,oBAAoB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,kCAAkC;AACvE;AACA;AACA;AACA;AACA;AACA,gBAAgB,gEAAQ;AACxB;AACA;AACA;AACA;AACA;AACA,oBAAoB,uEAAoB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,KAAK;AACL,6BAA6B,+BAA+B;AAC5D,4BAA4B,+BAA+B;AAC3D,sCAAsC,+BAA+B;AACrE,qCAAqC;AACrC,CAAC;AACD;AACA;AACA,IAAI,iEAAa;AACjB,IAAI,8DAAM;AACV;AACA;;AAEsM;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AChpBzJ;AACA;;AAE7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0BAA0B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,0BAA0B;AACjD;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,0BAA0B;AACjD;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,uFAAuF;AACxG;AACA;AACA,2CAA2C,0BAA0B;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,0BAA0B;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,2EAA2E;AACnG;AACA;AACA;AACA;AACA,oCAAoC,yDAAyD;AAC7F;AACA;AACA,uBAAuB,0BAA0B;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,IAAI,2CAA2C,KAAK;AACjG;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,uCAAuC;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,0BAA0B;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,0CAA0C;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,qBAAqB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,6DAAU;AAC5C,gEAAgE,6DAAU;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,iFAAiF;AACrG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,+DAA+D;AAC/F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,sCAAsC;AACtD;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,uBAAuB,0BAA0B;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8EAA8E,YAAY,aAAa,OAAO;AAC9G;AACA;AACA;AACA;AACA,qBAAqB,0BAA0B;AAC/C;AACA,iEAAiE,KAAK,MAAM,GAAG,qBAAqB,OAAO;AAC3G,wCAAwC,6DAAU,+BAA+B,0DAAO;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,iBAAiB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,6DAAU;AAC5C,8BAA8B,0DAAO;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,6DAAU;AAClC;AACA;AACA;AACA;AACA;AACA,uCAAuC,0BAA0B;AACjE;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,6DAAU;AAC3D,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,WAAW;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,uBAAuB;AACvC,gBAAgB,2CAA2C;AAC3D;AACA,aAAa,WAAW;AACxB,0CAA0C,6DAAU;AACpD;AACA;AACA,aAAa,WAAW;AACxB,kDAAkD,6DAAU;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,6DAA6D;AAC/E;AACA;AACA,gBAAgB,6DAA6D;AAC7E;AACA,iBAAiB,6BAA6B;AAC9C;AACA;AACA;AACA;AACA,iBAAiB,wFAAwF;AACzG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,SAAS,wCAAwC;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,wBAAwB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,oCAAoC;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,mBAAmB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,mBAAmB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,cAAc;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,0BAA0B;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,eAAe;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,sBAAsB;AAC1D;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D,gBAAgB;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,6BAA6B;AAClD;AACA;AACA;AACA;AACA,eAAe,oCAAoC;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,0BAA0B;AACxC;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,qCAAqC;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,4BAA4B;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uEAAuE;AACvE;AACA;AACA,mBAAmB,kBAAkB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,QAAQ;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,QAAQ;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,oCAAoC;AACrC;AACA;AACA;AACA,gCAAgC,WAAW,IAAI,OAAO;AACtD;AACA,WAAW;AACX;AACA;AACA;AACA,mBAAmB,gBAAgB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,qCAAqC;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+HAA+H,kBAAkB;AACjJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,WAAW,+CAA+C;AACvG,qEAAqE;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,uBAAuB;AAC9C;AACA;AACA,2BAA2B,OAAO;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,0DAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA,wCAAwC,uDAAI;AAC5C,cAAc,0DAAO;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,wCAAwC;AAC3D;AACA;AACA,qBAAqB,sDAAsD;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEmO;;;;;;;;;;;;;;;;;;;;;;AC7vDnO;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,mBAAmB;AAClC;AACA;AACA,mBAAmB,mBAAmB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,oCAAoC;AAC/D,4BAA4B,oCAAoC;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,+BAA+B;;AAE7D;AACA;AACA;AACA,mBAAmB,mBAAmB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,mBAAmB;AACtC;AACA,oBAAoB;AACpB;AACA;AACA;AACA,YAAY;AACZ;;AAEA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA,qDAAqD,IAAI,yBAAyB,YAAY;AAC9F;AACA;AACA;AACA;AACA;AACA,wDAAwD,EAAE,MAAM,WAAW;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,qCAAqC;AACxD;AACA;AACA,uCAAuC,8CAA8C;AACrF;AACA,gBAAgB,4BAA4B;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,oBAAoB;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,yBAAyB;AAC1C,oBAAoB,aAAa;AACjC;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,mCAAmC;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,uCAAuC;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,0BAA0B;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,uCAAuC;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,8BAA8B;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,yBAAyB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,8BAA8B;AACnD,gBAAgB,uBAAuB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,4BAA4B;AAC9C;;AAE4G;;;;;;;;;;;;;;;;;;;ACziBtB;AACL;;AAEjF;AACA,sBAAsB,uEAAoB;AAC1C;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,qBAAqB;AAChD;AACA,+BAA+B,0BAA0B;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,iEAAU;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,MAAM;AACxB;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,MAAM;AAChD;AACA;AACA;AACA;AACA;AACA,aAAa,SAAS;AACtB,uBAAuB,8BAA8B;AACrD,2EAA2E,MAAM;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,gEAAa;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,kBAAkB,qBAAqB;AACvC;AACA,CAAC;AACD,kBAAkB,uEAAoB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,gEAAY;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,gEAAa;AACnD;AACA;AACA,gCAAgC,kCAAkC;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,MAAM;AACvB,qDAAqD,qCAAqC;AAC1F;AACA,oCAAoC,kCAAkC;AACtE;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,kCAAkC;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,KAAK;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,kBAAkB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C,qBAAqB,sEAAkB;AACvC,uBAAuB,qEAAiB;AACxC,kBAAkB,aAAa,EAAE;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D,oEAAgB;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,sDAAsD,sBAAsB,yBAAyB,EAAE;AACvG,KAAK;AACL;AACA;AACA,QAAQ,oEAAiB;AACzB;AACA;AACA;;AAE+C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AClPkH;AACzH;AACyB;AACf;AACmD;AACzD;;AAE5C;AACA;AACA,QAAQ,0CAA0C,GAAG,mBAAmB,UAAU,EAAE,EAAE;AACtF;AACA;AACA,sCAAsC,GAAG;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA,kCAAkC,KAAK;AACvC,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,oBAAoB;AAC3D;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA,uBAAuB,KAAK;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA,KAAK;AACL;AACA;AACA,uBAAuB,kBAAkB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,gEAAgE;;AAEtF;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,2DAA2D;AAC5F,gCAAgC,+DAA+D;AAC/F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,aAAa;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,aAAa;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,cAAc;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,0BAA0B;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,QAAQ;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,QAAQ;AAClC;AACA;AACA,uBAAuB,qBAAqB;AAC5C;AACA;AACA,0BAA0B,cAAc;AACxC,yBAAyB,cAAc;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,oBAAoB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,oBAAoB,cAAc;AAClC;AACA;AACA;AACA,eAAe,UAAU;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,yBAAyB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,kCAAkC;AACrD;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD;AACjD;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,sEAAsE;AACvF;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,kBAAkB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,aAAa;AACnC,wBAAwB,uCAAuC;AAC/D;AACA;AACA,mBAAmB,6DAAU;AAC7B;AACA;AACA;AACA;AACA,+DAA+D,6DAAU;AACzE;AACA;AACA;AACA;AACA,uBAAuB,aAAa;AACpC;AACA;AACA,qDAAqD;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,0CAA0C;AAC7D,YAAY;AACZ,yCAAyC;AACzC;AACA;AACA;AACA,sBAAsB,cAAc;AACpC,2BAA2B,aAAa;AACxC,yBAAyB,6DAA6D;AACtF;AACA;AACA;AACA,SAAS,qBAAqB;AAC9B,SAAS,yBAAyB;AAClC;AACA;AACA;AACA;AACA,SAAS,WAAW;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,qBAAqB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,OAAO;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,WAAW;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,0BAA0B;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,cAAc;AAC/B;AACA;AACA;AACA;AACA;AACA,qBAAqB,cAAc;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,WAAW;AACtC;AACA;AACA;AACA,yBAAyB,aAAa;AACtC;AACA,sBAAsB,aAAa;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,8BAA8B;AAC/B;AACA;AACA;AACA,yBAAyB,iEAAU;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,cAAc;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,aAAa;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,kEAAW;AAC1B;AACA;AACA,iBAAiB,+DAA+D;AAChF;AACA;AACA,kBAAkB,qEAAc;AAChC;AACA;AACA,aAAa,aAAa;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,uEAAmB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,oEAAgB,mBAAmB,uEAAmB,GAAG,sEAAkB;AAC3G;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,wEAAwE;AAClG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,2CAA2C;AACpD;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,cAAc,gEAAY,EAAE,kCAAkC;AAC9D,kBAAkB,gEAAY,EAAE,+CAA+C;AAC/E,oBAAoB,0DAAmB;AACvC;AACA;AACA;AACA,uBAAuB,mBAAmB;AAC1C;AACA;AACA,KAAK;AACL;AACA;AACA,eAAe,kDAAW;AAC1B;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,mBAAmB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,yBAAyB,sBAAsB;AAC/C,wBAAwB,sBAAsB;AAC9C;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,4BAA4B,SAAS,UAAU,uBAAuB,YAAY,EAAE;AACpF,6BAA6B,SAAS,UAAU,uBAAuB,YAAY,EAAE;AACrF;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL,4BAA4B,6BAA6B;AACzD,2BAA2B,6BAA6B;AACxD;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA,uBAAuB,0BAA0B;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA,mBAAmB,cAAc;AACjC,gBAAgB,uBAAuB;AACvC;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,eAAe;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gGAAgG,8DAAY;AAC5G;AACA,uBAAuB,aAAa;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,aAAa;AACnC,wBAAwB,uCAAuC;AAC/D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,QAAQ;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,yBAAyB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,OAAO;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,qEAAc;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,8BAA8B;AAC7C,aAAa,yCAAyC;AACtD,oBAAoB,+CAA+C;AACnE;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,8BAA8B;AAC/B;AACA;AACA;AACA;AACA,mBAAmB,gBAAgB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,mCAAmC;AAClD;AACA,oBAAoB,uDAAuD;AAC3E;AACA;AACA;AACA,uBAAuB,kBAAkB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,SAAS;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,SAAS;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,SAAS;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,SAAS;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,SAAS;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,SAAS;AAChC;AACA;AACA;AACA;AACA,+BAA+B,WAAW;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,SAAS;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,uEAAgB;AACpC;AACA;AACA,eAAe,0EAAsB;AACrC;AACA;AACA,eAAe,0EAAsB;AACrC;AACA,eAAe,0EAAsB;AACrC,WAAW,0EAAsB;AACjC;;AAEA;AACA;AACA;AACA,mBAAmB,6DAAU;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,gBAAgB,aAAa;AAC9C;AACA;AACA,uBAAuB,wBAAwB;AAC/C;AACA;AACA;AACA;AACA,+DAA+D;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,yBAAyB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,yCAAyC;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,gCAAgC;AAC9C;AACA,kBAAkB,+BAA+B;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,8BAA8B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,4CAA4C;AAChE,yBAAyB,gFAAgF;AACzG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,mBAAmB;AACnD,mCAAmC,mBAAmB;AACtD;AACA;AACA,wCAAwC,QAAQ;AAChD,iBAAiB,yBAAyB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,gCAAgC;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,iBAAiB,YAAY,GAAG;AAChD;AACA;AACA;AACA;AACA,2BAA2B;AAC3B,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,YAAY,EAAE,sCAAsC,EAAE,iDAAiD;AAC9H;AACA;AACA;AACA,yBAAyB,kBAAkB;AAC3C;AACA;AACA,gBAAgB;AAChB;AACA;AACA,aAAa,kCAAkC;AAC/C;AACA,aAAa,eAAe;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,WAAW;AAC5B;AACA;AACA,aAAa,wBAAwB;AACrC,aAAa,uBAAuB;AACpC;AACA;AACA;AACA,aAAa,wBAAwB;AACrC,wFAAwF,YAAY;AACpG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,eAAe,YAAY,GAAG;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,mCAAmC;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,cAAc;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,0DAA0D;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,WAAW;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,qEAAc;AACtB;AACA;AACA;AACA;AACA;AACA,IAAI,uEAAgB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;;AAEA;AACA,gCAAgC,gEAAY;AAC5C,2BAA2B,gEAAY;AACvC,4BAA4B,gEAAY;AACxC,sBAAsB,gEAAY;AAClC,uBAAuB,gEAAY;AACnC,qBAAqB,gEAAY;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,gEAAY,EAAE,sDAAsD;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,0BAA0B;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,gEAAY;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,sCAAsC;AACnD;AACA;AACA;AACA;AACA;AACA,2DAA2D,yCAAyC;AACpG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,aAAa;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE;AACrE,yBAAyB,gEAAY;AACrC,qEAAqE;AACrE,CAAC;AACD,0BAA0B,gEAAY;AACtC,qEAAqE;AACrE,CAAC;AACD;AACA,oBAAoB,gEAAY;AAChC,oBAAoB,gEAAY;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,mEAAe;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,yDAAyD;AAC1E;;AAEA;AACA;AACA;AACA;AACA,qCAAqC,QAAQ,GAAG;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,cAAc;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,iDAAiD;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,mEAAmE;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,uCAAuC;AAClE;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+EAA+E,6DAAU;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6KAA6K,mEAAe;AAC5L;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,iDAAiD;AAC9F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,wBAAwB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,cAAc;AACvE;AACA;AACA;AACA;AACA,qBAAqB,cAAc;AACnC;AACA;AACA;AACA,qBAAqB,oBAAoB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,WAAW;AACtC,aAAa,MAAM;AACnB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,qEAAc;AACtB,4BAA4B,cAAc,WAAW,EAAE,EAAE;AACzD,qBAAqB;AACrB,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,+CAA+C;AAC1D;AACA;AACA;AACA,IAAI,qEAAc;AAClB,gBAAgB,EAAE;AAClB;AACA;AACA,6BAA6B,sBAAsB;AACnD;AACA;AACA;AACA;AACA,KAAK,MAAM;AACX;AACA,qBAAqB,gBAAgB;AACrC;AACA;AACA,YAAY;AACZ;AACA,uBAAuB,gBAAgB;AACvC;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB,aAAa,WAAW;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,WAAW;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,uBAAuB;AACvC,sBAAsB,kBAAkB;AACxC,kBAAkB,mCAAmC;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,aAAa;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sEAAsE,yEAAqB;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,+DAA+D;AACzG;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA,iBAAiB,yBAAyB;AAC1C,iBAAiB,4CAA4C;AAC7D,iBAAiB,qBAAqB;AACtC,iBAAiB,yBAAyB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,KAAK;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,SAAS;AACtB,cAAc,8BAA8B;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,WAAW;AACrC;AACA,gCAAgC,0BAA0B;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,eAAe;AAC5B;AACA,iBAAiB,WAAW;AAC5B;AACA;AACA,8BAA8B,WAAW;AACzC,iBAAiB,WAAW;AAC5B;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA,8CAA8C,mEAAmE;AACjH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,2BAA2B;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oCAAoC;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,eAAe;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,oBAAoB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,QAAQ;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,mDAAmD;AACjG;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,yDAAyD;AACxE,aAAa,iBAAiB;AAC9B,mBAAmB,cAAc;AACjC,sBAAsB,wBAAwB;AAC9C;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,kCAAkC;AAC9D,4BAA4B,kCAAkC;AAC9D;AACA;AACA;AACA,IAAI,uEAAgB;AACpB;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,0EAAsB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,uEAAgB;AAC/B;AACA,aAAa,uEAAgB;AAC7B;AACA;AACA,mBAAmB,uEAAgB;AACnC;AACA;AACA;AACA;AACA;AACA,mBAAmB,uEAAgB;AACnC;AACA;AACA;AACA;AACA,WAAW,yEAAqB;AAChC;AACA,2BAA2B,aAAa;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,+DAA+D;AAC5F;AACA;AACA,mCAAmC,4DAA4D;AAC/F;AACA;AACA;AACA;AACA,uCAAuC,OAAO;AAC9C;AACA,uBAAuB,kBAAkB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA,mBAAmB,SAAS;AAC5B;AACA;AACA;AACA,uBAAuB,kBAAkB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA,YAAY;AACZ;AACA,4BAA4B,OAAO;AACnC;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,2BAA2B;AAC7C;AACA;AACA;AACA;AACA,kBAAkB,4CAA4C;AAC9D;AACA;AACA;AACA;AACA;AACA,UAAU,eAAe;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC,iDAAiD;AACjD;AACA,mBAAmB,0EAAsB;AACzC;AACA;AACA;AACA,WAAW,0EAAsB;AACjC;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,0EAAsB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,sEAAkB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,0EAAsB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA,oFAAoF,YAAY;AAChG,yCAAyC,oDAAoD;AAC7F;AACA;AACA;AACA,uBAAuB,0EAAsB;AAC7C;AACA;AACA;AACA,SAAS,MAAM;AACf;AACA;AACA,6DAA6D,mBAAmB;AAChF,sBAAsB,kEAAW;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,0EAAsB;AACrC;AACA,eAAe,0EAAsB;AACrC;AACA;AACA;AACA,kEAAkE,sCAAsC;AACxG,eAAe,mBAAmB,GAAG,iEAAU;AAC/C;AACA;AACA;AACA,WAAW,0EAAsB;AACjC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,uFAAmC;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,4EAAwB;AACrD;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,OAAO;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,kBAAkB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,yBAAyB;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,gBAAgB;AAC5D;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,SAAS,QAAQ;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,oFAAoF;AACnH;AACA;AACA;AACA;AACA;AACA,oBAAoB,WAAW,oDAAoD;AACnF,uBAAuB,0EAAsB;AAC7C,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,qBAAqB,4EAAwB;AAC7C;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB,eAAe,0EAAsB;AACrC;AACA,yBAAyB;AACzB;AACA;AACA,UAAU;AACV;AACA;AACA,mBAAmB,yEAAqB;AACxC,aAAa,WAAW;AACxB,eAAe,yEAAqB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,qCAAqC;AACrE;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,yEAAqB,aAAa,yEAAqB;AACnG;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,0EAAsB;AAC7C;AACA;AACA;AACA;AACA,SAAS,aAAa,OAAO,EAAE;AAC/B,SAAS,iBAAiB;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,qCAAqC;AACzE;AACA;AACA;AACA;AACA,SAAS,iBAAiB;AAC1B;AACA,SAAS,qEAAqE;AAC9E,eAAe;AACf;AACA;AACA;AACA;AACA,oBAAoB,wEAAwE;AAC5F,qBAAqB,4EAAwB;AAC7C,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,gBAAgB;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,OAAO;AACzB;AACA;AACA;AACA,6BAA6B,+DAA+D;AAC5F;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA,SAAS,yBAAyB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,4EAAwB;AACjD,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,iCAAiC;AACjC;AACA,+CAA+C;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,IAAI;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,KAAK;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,wBAAwB,cAAc,EAAE;AACjG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,WAAW;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA,cAAc;AACd,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,WAAW;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA,aAAa,iDAAiD;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,0EAAsB;AAC3C;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,oCAAoC,4EAAwB,WAAW;AAClG;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,4EAAwB;AACtD;AACA,uBAAuB,iDAAiD;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,mDAAmD;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,0EAAsB;AAC5D;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,sEAAkB;AACzE;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,6BAA6B;AAC9C;AACA;AACA;AACA;AACA;AACA,oBAAoB,gCAAgC;AACpD;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,qCAAqC;AAC9D;AACA;AACA,kBAAkB,8BAA8B;AAChD;AACA;AACA,qBAAqB,kCAAkC;AACvD;AACA,gEAAgE,+DAAW;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,yBAAyB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,sBAAsB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,gBAAgB,IAAI,mBAAmB;AAC7D;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,QAAQ,wDAAiB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,iCAAiC;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,WAAW;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,0EAAsB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,8CAA8C;AAC/E;AACA;AACA,6BAA6B,+CAA+C;AAC5E;AACA;AACA;AACA,yBAAyB,8CAA8C;AACvE;AACA;AACA;AACA;AACA,wBAAwB,iDAAiD;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,IAAI,0BAA0B;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,0DAAmB;AACxC,sEAAsE,YAAY,GAAG,OAAO;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,iEAAa;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,YAAY,yBAAyB,EAAE;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,mBAAmB,kBAAkB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,kBAAkB;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,sBAAsB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,gEAAY,EAAE,2BAA2B;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,kBAAkB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD;AACzD,8CAA8C;AAC9C,oDAAoD,EAAE;AACtD;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA,2DAA2D,sCAAsC;AACjG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oDAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,6CAAI;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,oCAAoC;AACpC,wBAAwB,gEAAY;AACpC;AACA,eAAe,qEAAa;AAC5B;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA,aAAa,uBAAuB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA,0BAA0B,4CAA4C;AACtE,yBAAyB;AACzB;AACA;AACA;AACA;AACA,4BAA4B,iEAAa;AACzC;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA,gBAAgB,0EAAsB;AACtC,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,0BAA0B;AAC/C;AACA,uBAAuB,uBAAuB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sFAAsF,0EAAsB;AAC5G,8EAA8E,0EAAsB;AACpG;AACA;AACA;AACA,sFAAsF;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,gEAAY;AACtC;AACA,qBAAqB,qEAAa;AAClC;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,WAAW;AAC7B;AACA;AACA;AACA;AACA;AACA,aAAa,MAAM;AACnB,iEAAiE,qBAAqB;AACtF;AACA;AACA,+BAA+B,kEAAW;AAC1C;AACA;AACA;AACA;AACA,kEAAkE,kEAAW;AAC7E,mDAAmD,iFAAiF;AACpI;AACA;AACA;AACA,8EAA8E,8CAA8C;AAC5H;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,gCAAgC;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,cAAc;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,kCAAkC;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,cAAc;AACjC;AACA,YAAY,0DAAmB,6CAA6C,kDAAW;AACvF;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,kCAAkC,cAAc,kCAAkC,EAAE;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,cAAc;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE,4CAA4C;AAC9G;AACA,2BAA2B,wEAAwE;AACnG,KAAK,GAAG,kCAAkC;AAC1C;;AAEA;AACA,gBAAgB;;AAEwR;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACn4LtQ;AACE;AACD;AACR;;;;;;;;;;;;;;;;;;;;ACHiB;AACV;AACP;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACFwD;AAC5E;AACP,8BAA8B,qDAAU;AACxC;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,4DAAiB;AACzB;AACA;AACO;AACP;AACA;AACA;AACA;AACA,qBAAqB,QAAQ;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACO;AACA;AACA;AACP;AACA;AACA;AACA;AACA,qBAAqB,QAAQ;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACO;AACA;AACA;AACP;AACA;AACA;AACA;AACA,qBAAqB,QAAQ;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACO;AACA;AACA;AACP,qBAAqB,cAAc;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,sDAAW;AACjC;AACA;AACA;AACA;AACA,mDAAmD,MAAM;AACzD;AACA;AACA;AACO,kDAAkD,kDAAO;AACzD;AACA;AACA;AACA;AACP;AACA;AACA;AACA;AACA;AACA,qBAAqB,eAAe;AACpC;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA,qBAAqB,kDAAO;AAC5B;AACA;AACA;AACA;AACA,mDAAmD,WAAW;AAC9D;AACA;AACA;AACA,eAAe,sDAAW;AAC1B;AACA;AACO,sDAAsD,sDAAW;AACjE;;;;;;;;;;;;;;;;;;;;AC9IuC;AACJ;AACC;AACpC;AACP,sBAAsB,kDAAO;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,QAAQ,0DAAkB;AAC1B,eAAe,qDAAoB;AACnC;AACA,aAAa,oDAAY;AACzB,eAAe,+CAAc;AAC7B;AACA,aAAa,wDAAgB;AAC7B,eAAe,mDAAkB;AACjC;AACA,aAAa,wDAAgB;AAC7B,YAAY,mDAAkB;AAC9B,yBAAyB,kDAAO;AAChC;AACA;AACA;AACA,2CAA2C,8CAAG;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,0DAAkB;AAC/B,qBAAqB,kDAAO;AAC5B,YAAY,qDAAoB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D,IAAI;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,IAAI;AACjE;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,IAAI;AAC3C;AACA;;;;;;;;;;;;;;;;;;;ACvGqE;AACH;AAC3D;AACA;AACP;AACA,eAAe,wDAAU;AACzB;AACA;AACA,eAAe,4DAAc;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB,eAAe,8DAAgB,EAAE,gBAAgB;AACjD;AACA;AACA,eAAe,4DAAc,CAAC,kDAAO;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,mDAAK;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,4DAAiB;AACzB;AACA;AACA,iCAAiC,QAAQ;AACzC,sBAAsB,kDAAO;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,kEAAgB;AAC3B;;;;;;;;;;;;;;;;;;;ACxE8C;AACM;AACc;AACxB;AACnC;AACP,eAAe,kDAAO;AACtB,oBAAoB,kDAAO;AAC3B,sBAAsB,kDAAO;AAC7B;AACA;AACA;AACA,eAAe,6BAA6B;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,uDAAc,EAAE,eAAe;AAC/E;AACA;AACA,uCAAuC,2BAA2B;AAClE;AACA;AACA;AACA,sBAAsB,kDAAO;AAC7B;AACA;AACA;AACA;AACA;AACA,wBAAwB,0DAAgB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,0DAAkB;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,4DAAkB;AACrC;AACA;AACA;AACA;AACA;AACA,gDAAgD;AAChD,mBAAmB,qBAAqB,6BAA6B;AACrE;AACA,8CAA8C,uDAAc,EAAE,2BAA2B;AACzF;AACA;AACA;AACA;AACA;AACA,mBAAmB,4DAAkB;AACrC;AACA;AACA,aAAa,oDAAY;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,wDAAgB;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,wDAAgB;AAC7B;AACA;AACA;AACA;AACA,uBAAuB,0DAAgB;AACvC;AACA;AACA,aAAa,0DAAkB;AAC/B;AACA;AACA;AACA;AACA;AACA,mBAAmB,4DAAkB;AACrC;AACA;AACA;AACA,QAAQ,4DAAiB;AACzB;AACA;AACA;AACA,sBAAsB,kDAAO;AAC7B;AACA;AACA;AACA;AACA,sEAAsE,IAAI;AAC1E;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC/G0C;AACV;AACL;AACA;AACF;AACE;;;;;;;;;;;;;;;;;;;ACLmB;AACM;AACK;AAClD,yBAAyB,QAAQ,sFAAsF,QAAQ;AAC/H,cAAc,QAAQ;AAC7B;AACA,gBAAgB,kDAAU,QAAQ,sDAAY;AAC9C;AACA;AACA;AACA,YAAY,sDAAc;AAC1B,gBAAgB,0DAAgB;AAChC;AACA;AACA;AACA,eAAe,MAAM;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,QAAQ;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,kDAAO;AACjC;AACA,2CAA2C,QAAQ;AACnD;AACA;AACA;AACA,wBAAwB,sDAAc;AACtC,yBAAyB,0DAAgB;AACzC;AACA;AACA;AACA,YAAY,wDAAgB,EAAE,yBAAyB;AACvD,gBAAgB,4DAAkB;AAClC;AACA;AACA;AACA,QAAQ,4DAAiB;AACzB;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC3E2B;AACA;AACpB,6CAA6C,4BAA4B;AACzE,qDAAqD,oCAAoC;AACzF,4CAA4C,2BAA2B;AACvE,2CAA2C,0BAA0B;AACrE,0CAA0C,yBAAyB;AACnE,wCAAwC,6CAA6C;AACrF,wCAAwC,6CAA6C;AACrF,8CAA8C,6BAA6B;AAC3E;;;;;;;;;;;;;;;;;;;ACVuC;AACuB;AACpB;AAC1C;AACP,8BAA8B,qDAAU;AACxC;AACA;AACA;AACA,eAAe,gBAAgB;AAC/B,YAAY,8DAAmB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,sDAAc,CAAC,kDAAO;AACrC;AACA;AACA,eAAe,wDAAgB,CAAC,kDAAO;AACvC;AACA;AACA,QAAQ,4DAAiB;AACzB;AACA;;;;;;;;;;;;;;;;;;;;;AC5CwC;AACV;AACH;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACFW;AAC/B;AACA,4CAA4C,2BAA2B;AACvE;AACA,iCAAiC,cAAc;AAC/C;AACA,6CAA6C,4BAA4B;AACzE;AACA,+CAA+C,yDAAyD;AACxG;AACA,6BAA6B;AAC7B,oDAAoD,kDAAO;AAC3D,8CAA8C,qDAAqD;AACnG;;;;;;;;;;;;;;;;;;;;ACb+B;AACK;AAC3C;AACA;AACA;AACA,gCAAgC,kDAAO;AACvC;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,kDAAO;AACpC;AACA;AACA;AACA;AACA;AACA;AACO;AACP,sBAAsB,kDAAO;AAC7B;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,kDAAO;AACzB,kBAAkB,kDAAO;AACzB;AACA;AACA;AACA,mCAAmC,8CAAG;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,kDAAO;AACzB,kBAAkB,kDAAO;AACzB;AACA;AACA;AACA,mCAAmC,8CAAG;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,kDAAO;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,kDAAO;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,+CAAc;AAC7B;AACA;AACA,eAAe,iDAAgB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,kDAAO;AACrB,cAAc,kDAAO;AACrB;AACA;AACA;AACA,+BAA+B,8CAAG;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,kDAAO,gBAAgB,kDAAO;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;AC1LA;AACO;AACP;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,8CAA8C,IAAI;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,IAAI;AAClD;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,OAAO;AAC1C,4BAA4B;AAC5B;AACA;AACA,iDAAiD,QAAQ;AACzD,4BAA4B;AAC5B;AACA,aAAa;AACb;AACA,KAAK;AACL,CAAC;;;;;;;;;;;;;;;;;;;;AChE+B;AACA;AACF;AACN;;;;;;;;;;;;;;;;;;;;ACHjB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACAA;;;;;;;;;;;;;;;;ACAP;AAC4B;AACE;AAC9B,yBAAyB;AAClB,eAAe,qDAAkB;AACxC;AACA,2IAA2I,mUAAmU;AAC9c,4FAA4F,yEAAyE;AACrK,YAAY,sFAAsF,+BAA+B,KAAK,qCAAqC;AAC3K;AACA;AACA;AACA,KAAK,iDAAc;AACnB;AACA;AACA;AACA,iCAAiC,GAAG,kDAAkD,IAAI,IAAI,qLAAqL,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KAAK,CAAC,MAAM;YACjC,KAAK,CAAC,CAAC,CAAC,MAAM,CAAC,SAAS,CAAC,KAAK,CAAC,KAAK,oBAAsB;aACzD,CAAC,IAAI,IAAI,IAAI,CAAC,KAAK,GAAG,KAAK,CAAC,KAAK,CAAC;YACrC,IAAI,GAAG,KAAK;KACf;IACD,OAAO,IAAI;AACb;;;;;;;;;;;;;;;;;AC5+BA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,0BAA0B,8DAA8D;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,gBAAgB;;AAEzB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,oEAAoE;AACpE;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT,8GAA8G;AAC9G;AACA;AACA,+FAA+F,wBAAwB;AACvH;;AAEA;AACA;;AAEA;AACA;AACA,cAAc;;AAEd;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,mBAAmB,oBAAoB;AACvC;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,sBAAsB;AACxD;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,qBAAqB,yBAAyB;AAC9C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,kDAAkD;AAClD,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D;AAC3D,IAAI,iBAAiB;AACrB;AACA;AACA;AACA;AACA;AACA,gDAAgD;AAChD,yBAAyB,KAAK;;;;;;;;;;;;;;;;;AC/JvB;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,0EAA0E,GAAG;AAC7E;;AAEA;AACA,eAAe,QAAQ;;AAEvB;AACA,eAAe,SAAS;;AAExB;AACA,gBAAgB,SAAS;AACzB;AACA;AACA;;AAEA;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;UC3HA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;WCtBA;WACA;WACA;WACA;WACA,wCAAwC,yCAAyC;WACjF;WACA;WACA,E;;;;;WCPA,wF;;;;;WCAA;WACA;WACA;WACA,sDAAsD,kBAAkB;WACxE;WACA,+CAA+C,cAAc;WAC7D,E;;;;;;;;;;;;;;;;;;;;;;;;;;;ACNA;AACA;AACA;AACA;AAEA,IAAMC,YAAY,4dAAlB;AA+BA,IAAM1C,MAAM,GAAGF,yDAAU,EAAzB;AACA,IAAM6C,UAAU,gCAAO5H,yDAAP,IAAuBiF,MAAvB,EAAhB;AAEA,IAAMpE,KAAK,GAAGgH,sEAAA,CAAmB;AAChC1G,KAAG,EAAEwG,YAD2B;AAEhCC,YAAU,EAAVA;AAFgC,CAAnB,CAAd;AAKA,IAAM1C,IAAI,GAAG,IAAIvF,6DAAJ,CAAe;AAC3BkB,OAAK,EAALA,KAD2B;AAE3BgF,QAAM,EAAEiC,QAAQ,CAACC,cAAT,CAAwB,QAAxB;AAFmB,CAAf,CAAb;AAKAC,oEAAa,CAAC9C,IAAD,CAAb;AACAA,IAAI,CAAC+C,KAAL,G","file":"index.min.js","sourcesContent":["import { basicSetup } from \"@codemirror/next/basic-setup\";\nimport { defaultKeymap, indentMore, indentLess, } from \"@codemirror/next/commands\";\nimport { EditorView, keymap } from \"@codemirror/next/view\";\nimport { commentKeymap } from \"@codemirror/next/comment\";\nimport { lineNumbers } from \"@codemirror/next/gutter\";\nimport { highlightSelectionMatches } from \"@codemirror/next/search\";\nimport { defaultHighlightStyle } from \"@codemirror/next/highlight\";\nimport { syntax } from \"./syntax.js\";\nexport const readOnlyConfig = [\n    EditorView.editable.of(false),\n    lineNumbers(),\n    defaultHighlightStyle,\n    highlightSelectionMatches(),\n    syntax,\n];\nexport const editableConfig = [\n    basicSetup,\n    syntax,\n    keymap.of([\n        ...defaultKeymap,\n        ...commentKeymap,\n        {\n            key: \"Tab\",\n            preventDefault: true,\n            run: indentMore,\n        },\n        {\n            key: \"Shift-Tab\",\n            preventDefault: true,\n            run: indentLess,\n        },\n    ]),\n];\n","import { Schema } from \"@underlay/apg\";\nexport const errorUnit = Schema.product({});\n","export * from \"./syntax.js\";\nexport * from \"./lint.js\";\nexport * from \"./config.js\";\nexport * from \"./error.js\";\n","import { linter } from \"@codemirror/next/lint\";\nimport { syntaxTree } from \"@codemirror/next/language\";\nimport { Schema } from \"@underlay/apg\";\nimport { ul } from \"@underlay/namespaces\";\nimport { defaultTypes, defaultNamespaces, LintError, namespacePattern, parseURI, uriPattern, } from \"@underlay/tasl-lezer\";\nimport { errorUnit } from \"./error.js\";\nexport function lintView({ state, }) {\n    const cursor = syntaxTree(state).cursor();\n    const slice = ({ from, to }) => state.doc.sliceString(from, to);\n    const error = (node, message) => new LintError(node.from, node.to, slice(node), message);\n    const parseState = {\n        slice,\n        error,\n        namespaces: {},\n        references: [],\n        types: { ...defaultTypes },\n        schema: {},\n    };\n    const diagnostics = [];\n    if (cursor.name === \"Schema\") {\n        cursor.firstChild();\n    }\n    else {\n        diagnostics.push({\n            from: cursor.from,\n            to: cursor.to,\n            message: \"Syntax error: invalid document\",\n            severity: \"error\",\n        });\n        return { errors: 1, state, schema: {}, namespaces: {}, diagnostics };\n    }\n    do {\n        if (cursor.type.isError) {\n        }\n        else if (cursor.type.name === \"Namespace\") {\n            let namespace = \"\";\n            const term = cursor.node.getChild(\"Term\");\n            if (term !== null) {\n                namespace = parseState.slice(term);\n                if (!uriPattern.test(namespace)) {\n                    const { from, to } = term;\n                    const message = `Invalid URI: URIs must match ${uriPattern.source}`;\n                    diagnostics.push({ from, to, message, severity: \"error\" });\n                }\n                else if (!namespacePattern.test(namespace)) {\n                    const { from, to } = term;\n                    const message = \"Invalid namespace: namespaces must end in / or #\";\n                    diagnostics.push({ from, to, message, severity: \"error\" });\n                }\n            }\n            const identifier = cursor.node.getChild(\"Prefix\");\n            if (identifier !== null) {\n                const prefix = parseState.slice(identifier);\n                if (prefix in parseState.namespaces) {\n                    const { from, to } = identifier;\n                    const message = `Duplicate namespace: ${prefix}`;\n                    diagnostics.push({ from, to, message, severity: \"error\" });\n                }\n                else {\n                    parseState.namespaces[prefix] = namespace;\n                }\n            }\n        }\n        else if (cursor.type.name === \"Type\") {\n            const identifier = cursor.node.getChild(\"TypeName\");\n            const expression = cursor.node.getChild(\"Expression\");\n            const type = expression === null\n                ? errorUnit\n                : getType(parseState, diagnostics, expression);\n            if (identifier !== null) {\n                const name = parseState.slice(identifier);\n                if (name in parseState.types) {\n                    const { from, to } = identifier;\n                    const message = `Invalid type declaration: type ${name} has already been declared`;\n                    diagnostics.push({ from, to, message, severity: \"error\" });\n                }\n                else {\n                    parseState.types[name] = type;\n                }\n            }\n        }\n        else if (cursor.type.name === \"Class\") {\n            const term = cursor.node.getChild(\"Term\");\n            if (term !== null) {\n                const uri = getURI(parseState, diagnostics, term);\n                if (uri !== null) {\n                    if (uri in parseState.schema) {\n                        const { from, to } = term;\n                        const message = `Invalid class declaration: class ${uri} has already been declared`;\n                        diagnostics.push({ from, to, message, severity: \"error\" });\n                    }\n                    else {\n                        const expression = cursor.node.getChild(\"Expression\");\n                        parseState.schema[uri] =\n                            expression === null\n                                ? errorUnit\n                                : getType(parseState, diagnostics, expression);\n                    }\n                }\n            }\n        }\n        else if (cursor.type.name === \"Edge\") {\n            const terms = cursor.node.getChildren(\"Term\");\n            const uris = terms.map((uri) => getURI(parseState, diagnostics, uri));\n            if (terms.length === 3 && uris.length === 3) {\n                const [sourceNode, labelNode, targetNode] = terms;\n                const [source, label, target] = uris;\n                if (label in parseState.schema) {\n                    const { from, to } = labelNode;\n                    const message = `Invalid edge declaration: class ${label} has already been declared`;\n                    diagnostics.push({ from, to, message, severity: \"error\" });\n                }\n                if (!(source in parseState.schema)) {\n                    const { from, to } = sourceNode;\n                    parseState.references.push({ from, to, key: source });\n                }\n                if (!(target in parseState.schema)) {\n                    const { from, to } = targetNode;\n                    parseState.references.push({ from, to, key: target });\n                }\n                const components = {\n                    [ul.source]: Schema.reference(source),\n                    [ul.target]: Schema.reference(target),\n                };\n                const expression = cursor.node.getChild(\"Expression\");\n                if (expression !== null) {\n                    components[ul.value] = getType(parseState, diagnostics, expression);\n                }\n                parseState.schema[label] = Schema.product(components);\n            }\n        }\n        else if (cursor.type.name === \"List\") {\n            const term = cursor.node.getChild(\"Term\");\n            const expression = cursor.node.getChild(\"Expression\");\n            const head = expression === null\n                ? errorUnit\n                : getType(parseState, diagnostics, expression);\n            if (term !== null) {\n                const uri = getURI(parseState, diagnostics, term);\n                if (uri in parseState.schema) {\n                    const { from, to } = term;\n                    const message = `Invalid list declaration: class ${uri} has already been declared`;\n                    diagnostics.push({ from, to, message, severity: \"error\" });\n                }\n                parseState.schema[uri] = Schema.coproduct({\n                    [ul.none]: Schema.product({}),\n                    [ul.some]: Schema.coproduct({\n                        [ul.head]: head,\n                        [ul.tail]: Schema.reference(uri),\n                    }),\n                });\n            }\n        }\n        reportChildErrors(diagnostics, cursor);\n    } while (cursor.nextSibling());\n    const namespaces = Object.entries(parseState.namespaces).filter(([_, base]) => base !== null);\n    for (const { from, to, key } of parseState.references) {\n        if (key in parseState.schema) {\n            continue;\n        }\n        else {\n            const message = `Reference error: class ${key} is not defined`;\n            diagnostics.push({ from, to, message, severity: \"error\" });\n        }\n    }\n    const sorted = diagnostics.sort(({ from: a, to: c }, { from: b, to: d }) => a < b ? -1 : b < a ? 1 : c < d ? -1 : d < c ? 1 : 0);\n    return {\n        errors: sorted.length,\n        state: state,\n        schema: parseState.schema,\n        namespaces: { ...defaultNamespaces, ...Object.fromEntries(namespaces) },\n        diagnostics: sorted,\n    };\n}\nexport const makeLinter = (onChange) => linter((view) => {\n    const { diagnostics, ...props } = lintView(view);\n    if (onChange !== undefined) {\n        onChange(props);\n    }\n    return diagnostics;\n});\nfunction getURI(state, diagnostics, node) {\n    try {\n        return parseURI(state, node);\n    }\n    catch (e) {\n        if (e instanceof LintError) {\n            const { from, to, message, value } = e;\n            diagnostics.push({ from, to, message, severity: \"error\" });\n            return value;\n        }\n        else {\n            throw e;\n        }\n    }\n}\n// Variable | Optional | Reference | Unit | Iri | Literal | Product | Coproduct\nfunction getType(state, diagnostics, node) {\n    if (node.name === \"Variable\") {\n        const value = state.slice(node);\n        if (value in state.types) {\n            return state.types[value];\n        }\n        else {\n            const { from, to } = node;\n            const message = `Type ${value} is not defined`;\n            diagnostics.push({ from, to, message, severity: \"error\" });\n            return errorUnit;\n        }\n    }\n    else if (node.name === \"Optional\") {\n        const expression = node.getChild(\"Expression\");\n        const type = expression === null ? errorUnit : getType(state, diagnostics, expression);\n        return Schema.coproduct({ [ul.none]: Schema.product({}), [ul.some]: type });\n    }\n    else if (node.name === \"Reference\") {\n        const term = node.getChild(\"Term\");\n        if (term === null) {\n            return errorUnit;\n        }\n        const key = getURI(state, diagnostics, term);\n        if (!(key in state.schema)) {\n            const { from, to } = term;\n            state.references.push({ from, to, key });\n        }\n        return Schema.reference(key);\n    }\n    else if (node.name === \"Uri\") {\n        return Schema.uri();\n    }\n    else if (node.name === \"Literal\") {\n        const term = node.getChild(\"Term\");\n        if (term === null) {\n            return errorUnit;\n        }\n        const datatype = getURI(state, diagnostics, term);\n        return Schema.literal(datatype);\n    }\n    else if (node.name === \"Product\") {\n        const components = {};\n        for (const component of node.getChildren(\"Component\")) {\n            const term = component.getChild(\"Term\");\n            if (term === null) {\n                continue;\n            }\n            const key = getURI(state, diagnostics, term);\n            if (key in components) {\n                const { from, to } = term;\n                const message = `Duplicate product component key`;\n                diagnostics.push({ from, to, message, severity: \"error\" });\n            }\n            const expression = component.getChild(\"Expression\");\n            components[key] =\n                expression === null\n                    ? errorUnit\n                    : getType(state, diagnostics, expression);\n        }\n        return Schema.product(components);\n    }\n    else if (node.name === \"Coproduct\") {\n        const options = {};\n        for (const option of node.getChildren(\"Option\")) {\n            const term = option.getChild(\"Term\");\n            if (term === null) {\n                continue;\n            }\n            const key = getURI(state, diagnostics, term);\n            if (key in options) {\n                const { from, to } = term;\n                const message = `Duplicate coproduct option key`;\n                diagnostics.push({ from, to, message, severity: \"error\" });\n            }\n            const expression = option.getChild(\"Expression\");\n            options[key] =\n                expression === null\n                    ? Schema.product({})\n                    : getType(state, diagnostics, expression);\n        }\n        return Schema.coproduct(options);\n    }\n    else {\n        throw new Error(\"Unexpected Expression node\");\n    }\n}\nfunction reportChildErrors(diagnostics, cursor) {\n    if (cursor.type.isError) {\n        const { from, to } = cursor;\n        const message = `Syntax error: unexpected or missing token (that's all we know)`;\n        diagnostics.push({ from, to, message, severity: \"error\" });\n    }\n    if (cursor.firstChild()) {\n        do {\n            reportChildErrors(diagnostics, cursor);\n        } while (cursor.nextSibling());\n        cursor.parent();\n    }\n}\n","import { continuedIndent, indentNodeProp, foldNodeProp, LezerLanguage, } from \"@codemirror/next/language\";\nimport { styleTags, tags } from \"@codemirror/next/highlight\";\nimport { parser } from \"@underlay/tasl-lezer/grammar/tasl.js\";\nexport const syntax = LezerLanguage.define({\n    parser: parser.configure({\n        props: [\n            indentNodeProp.add({\n                Product: continuedIndent({ except: /^\\s*\\}/ }),\n                Coproduct: continuedIndent({ except: /^\\s*\\]/ }),\n            }),\n            foldNodeProp.add({\n                Product(subtree) {\n                    return { from: subtree.from + 1, to: subtree.to - 1 };\n                },\n                Coproduct(subtree) {\n                    return { from: subtree.from + 1, to: subtree.to - 1 };\n                },\n            }),\n            styleTags({\n                Comment: tags.comment,\n                Prefix: tags.namespace,\n                TypeName: tags.typeName,\n                Variable: tags.typeName,\n                Term: tags.name,\n                \"Class/Term\": tags.className,\n                \"Edge/Term\": tags.className,\n                \"Product/Term\": tags.propertyName,\n                \"Coproduct/Term\": tags.propertyName,\n                Uri: tags.string,\n                Literal: tags.string,\n                \"Literal/Term\": tags.string,\n                \"Reference/Term\": tags.className,\n                Pointer: tags.operator,\n                Optional: tags.operator,\n                \"{ }\": tags.bracket,\n                \"[ ]\": tags.bracket,\n                \"->\": tags.separator,\n                \"<-\": tags.separator,\n                \";\": tags.separator,\n                \"Namespace/Uri\": tags.namespace,\n                namespace: tags.keyword,\n                type: tags.keyword,\n                class: tags.keyword,\n                edge: tags.keyword,\n                list: tags.keyword,\n            }),\n        ],\n    }),\n    languageData: {\n        closeBrackets: { brackets: [\"[\", \"{\", \"<\"] },\n        indentOnInput: /^\\s*[\\}\\]]$/,\n        commentTokens: { line: \"#\" },\n    },\n});\n","import { showTooltip, tooltips } from '@codemirror/next/tooltip';\nimport { Facet, combineConfig, StateEffect, StateField, Transaction, Text, EditorSelection, Prec, CharCategory } from '@codemirror/next/state';\nimport { EditorView, Direction, themeClass, ViewPlugin, logException, Decoration, WidgetType, keymap } from '@codemirror/next/view';\nimport { syntaxTree, indentUnit } from '@codemirror/next/language';\nimport { codePointAt, codePointSize, fromCodePoint } from '@codemirror/next/text';\n\n/// An instance of this is passed to completion source functions.\nclass CompletionContext {\n    /// Create a new completion context. (Mostly useful for testing\n    /// completion sources—in the editor, the extension will create\n    /// these for you.)\n    constructor(\n    /// The editor state that the completion happens in.\n    state, \n    /// The position at which the completion is happening.\n    pos, \n    /// Indicates whether completion was activated explicitly, or\n    /// implicitly by typing. The usual way to respond to this is to\n    /// only return completions when either there is part of a\n    /// completable entity before the cursor, or `explicit` is true.\n    explicit) {\n        this.state = state;\n        this.pos = pos;\n        this.explicit = explicit;\n        /// @internal\n        this.abortListeners = [];\n    }\n    /// Get the extent, content, and (if there is a token) type of the\n    /// token before `this.pos`.\n    tokenBefore(types) {\n        let token = syntaxTree(this.state).resolve(this.pos, -1);\n        while (token && types.indexOf(token.name) < 0)\n            token = token.parent;\n        return token ? { from: token.from, to: this.pos,\n            text: this.state.sliceDoc(token.from, this.pos),\n            type: token.type } : null;\n    }\n    /// Get the match of the given expression directly before the\n    /// cursor.\n    matchBefore(expr) {\n        let line = this.state.doc.lineAt(this.pos);\n        let start = Math.max(line.from, this.pos - 250);\n        let str = line.text.slice(start - line.from, this.pos - line.from);\n        let found = str.search(ensureAnchor(expr, false));\n        return found < 0 ? null : { from: start + found, to: this.pos, text: str.slice(found) };\n    }\n    /// Yields true when the query has been aborted. Can be useful in\n    /// asynchronous queries to avoid doing work that will be ignored.\n    get aborted() { return this.abortListeners == null; }\n    /// Allows you to register abort handlers, which will be called when\n    /// the query is\n    /// [aborted](#autocomplete.CompletionContext.aborted).\n    addEventListener(type, listener) {\n        if (type == \"abort\" && this.abortListeners)\n            this.abortListeners.push(listener);\n    }\n}\nfunction toSet(chars) {\n    let flat = Object.keys(chars).join(\"\");\n    let words = /\\w/.test(flat);\n    if (words)\n        flat = flat.replace(/\\w/g, \"\");\n    return `[${words ? \"\\\\w\" : \"\"}${flat.replace(/[^\\w\\s]/g, \"\\\\$&\")}]`;\n}\nfunction prefixMatch(options) {\n    let first = Object.create(null), rest = Object.create(null);\n    for (let { label } of options) {\n        first[label[0]] = true;\n        for (let i = 1; i < label.length; i++)\n            rest[label[i]] = true;\n    }\n    let source = toSet(first) + toSet(rest) + \"*$\";\n    return [new RegExp(\"^\" + source), new RegExp(source)];\n}\n/// Given a a fixed array of options, return an autocompleter that\n/// completes them.\nfunction completeFromList(list) {\n    let options = list.map(o => typeof o == \"string\" ? { label: o } : o);\n    let [span, match] = options.every(o => /^\\w+$/.test(o.label)) ? [/\\w*$/, /\\w+$/] : prefixMatch(options);\n    return (context) => {\n        let token = context.matchBefore(match);\n        return token || context.explicit ? { from: token ? token.from : context.pos, options, span } : null;\n    };\n}\n/// Wrap the given completion source so that it will not fire when the\n/// cursor is in a syntax node with one of the given names.\nfunction ifNotIn(nodes, source) {\n    return (context) => {\n        for (let pos = syntaxTree(context.state).resolve(context.pos, -1); pos; pos = pos.parent)\n            if (nodes.indexOf(pos.name) > -1)\n                return null;\n        return source(context);\n    };\n}\nclass Option {\n    constructor(completion, source, match) {\n        this.completion = completion;\n        this.source = source;\n        this.match = match;\n    }\n}\nfunction cur(state) { return state.selection.main.head; }\n// Make sure the given regexp has a $ at its end and, if `start` is\n// true, a ^ at its start.\nfunction ensureAnchor(expr, start) {\n    var _a;\n    let { source } = expr;\n    let addStart = start && source[0] != \"^\", addEnd = source[source.length - 1] != \"$\";\n    if (!addStart && !addEnd)\n        return expr;\n    return new RegExp(`${addStart ? \"^\" : \"\"}(?:${source})${addEnd ? \"$\" : \"\"}`, (_a = expr.flags) !== null && _a !== void 0 ? _a : (expr.ignoreCase ? \"i\" : \"\"));\n}\nfunction applyCompletion(view, option) {\n    let apply = option.completion.apply || option.completion.label;\n    let result = option.source;\n    if (typeof apply == \"string\") {\n        view.dispatch({\n            changes: { from: result.from, to: result.to, insert: apply },\n            selection: { anchor: result.from + apply.length }\n        });\n    }\n    else {\n        apply(view, option.completion, result.from, result.to);\n    }\n}\nconst SourceCache = new WeakMap();\nfunction asSource(source) {\n    if (!Array.isArray(source))\n        return source;\n    let known = SourceCache.get(source);\n    if (!known)\n        SourceCache.set(source, known = completeFromList(source));\n    return known;\n}\n\n// A pattern matcher for fuzzy completion matching. Create an instance\n// once for a pattern, and then use that to match any number of\n// completions.\nclass FuzzyMatcher {\n    constructor(pattern) {\n        this.pattern = pattern;\n        this.chars = [];\n        this.folded = [];\n        // Buffers reused by calls to `match` to track matched character\n        // positions.\n        this.any = [];\n        this.precise = [];\n        this.byWord = [];\n        for (let p = 0; p < pattern.length;) {\n            let char = codePointAt(pattern, p), size = codePointSize(char);\n            this.chars.push(char);\n            let part = pattern.slice(p, p + size), upper = part.toUpperCase();\n            this.folded.push(codePointAt(upper == part ? part.toLowerCase() : upper, 0));\n            p += size;\n        }\n        this.astral = pattern.length != this.chars.length;\n    }\n    // Matches a given word (completion) against the pattern (input).\n    // Will return null for no match, and otherwise an array that starts\n    // with the match score, followed by any number of `from, to` pairs\n    // indicating the matched parts of `word`.\n    //\n    // The score is a number that is more negative the worse the match\n    // is. See `Penalty` above.\n    match(word) {\n        if (this.pattern.length == 0)\n            return [0];\n        if (word.length < this.pattern.length)\n            return null;\n        let { chars, folded, any, precise, byWord } = this;\n        // For single-character queries, only match when they occur right\n        // at the start\n        if (chars.length == 1) {\n            let first = codePointAt(word, 0);\n            return first == chars[0] ? [0, 0, codePointSize(first)]\n                : first == folded[0] ? [-200 /* CaseFold */, 0, codePointSize(first)] : null;\n        }\n        let direct = word.indexOf(this.pattern);\n        if (direct == 0)\n            return [0, 0, this.pattern.length];\n        let len = chars.length, anyTo = 0;\n        if (direct < 0) {\n            for (let i = 0, e = Math.min(word.length, 200); i < e && anyTo < len;) {\n                let next = codePointAt(word, i);\n                if (next == chars[anyTo] || next == folded[anyTo])\n                    any[anyTo++] = i;\n                i += codePointSize(next);\n            }\n            // No match, exit immediately\n            if (anyTo < len)\n                return null;\n        }\n        let preciseTo = 0;\n        let byWordTo = 0, byWordFolded = false;\n        let adjacentTo = 0, adjacentStart = -1, adjacentEnd = -1;\n        for (let i = 0, e = Math.min(word.length, 200), prevType = 0 /* NonWord */; i < e && byWordTo < len;) {\n            let next = codePointAt(word, i);\n            if (direct < 0) {\n                if (preciseTo < len && next == chars[preciseTo])\n                    precise[preciseTo++] = i;\n                if (adjacentTo < len) {\n                    if (next == chars[adjacentTo] || next == folded[adjacentTo]) {\n                        if (adjacentTo == 0)\n                            adjacentStart = i;\n                        adjacentEnd = i;\n                        adjacentTo++;\n                    }\n                    else {\n                        adjacentTo = 0;\n                    }\n                }\n            }\n            let ch, type = next < 0xff\n                ? (next >= 48 && next <= 57 || next >= 97 && next <= 122 ? 2 /* Lower */ : next >= 65 && next <= 90 ? 1 /* Upper */ : 0 /* NonWord */)\n                : ((ch = fromCodePoint(next)) != ch.toLowerCase() ? 1 /* Upper */ : ch != ch.toUpperCase() ? 2 /* Lower */ : 0 /* NonWord */);\n            if (type == 1 /* Upper */ || prevType == 0 /* NonWord */ && type != 0 /* NonWord */ &&\n                (this.chars[byWordTo] == next || (this.folded[byWordTo] == next && (byWordFolded = true))))\n                byWord[byWordTo++] = i;\n            prevType = type;\n            i += codePointSize(next);\n        }\n        if (byWordTo == len && byWord[0] == 0)\n            return this.result(-100 /* ByWord */ + (byWordFolded ? -200 /* CaseFold */ : 0), byWord, word);\n        if (adjacentTo == len && adjacentStart == 0)\n            return [-200 /* CaseFold */, 0, adjacentEnd];\n        if (direct > -1)\n            return [-700 /* NotStart */, direct, direct + this.pattern.length];\n        if (adjacentTo == len)\n            return [-200 /* CaseFold */ + -700 /* NotStart */, adjacentStart, adjacentEnd];\n        if (byWordTo == len)\n            return this.result(-100 /* ByWord */ + (byWordFolded ? -200 /* CaseFold */ : 0) + -700 /* NotStart */, byWord, word);\n        return chars.length == 2 ? null : this.result((any[0] ? -700 /* NotStart */ : 0) + -200 /* CaseFold */ + -1100 /* Gap */, any, word);\n    }\n    result(score, positions, word) {\n        let result = [score], i = 1;\n        for (let pos of positions) {\n            let to = pos + (this.astral ? codePointSize(codePointAt(word, pos)) : 1);\n            if (i > 1 && result[i - 1] == pos)\n                result[i - 1] = to;\n            else {\n                result[i++] = pos;\n                result[i++] = to;\n            }\n        }\n        return result;\n    }\n}\n\nconst completionConfig = Facet.define({\n    combine(configs) {\n        return combineConfig(configs, {\n            activateOnTyping: true,\n            override: null,\n            maxRenderedOptions: 100,\n            defaultKeymap: true\n        }, {\n            defaultKeymap: (a, b) => a && b\n        });\n    }\n});\n\nconst MaxInfoWidth = 300;\nconst baseTheme = EditorView.baseTheme({\n    \"$tooltip.autocomplete\": {\n        \"& > ul\": {\n            fontFamily: \"monospace\",\n            overflowY: \"auto\",\n            whiteSpace: \"nowrap\",\n            maxHeight: \"10em\",\n            listStyle: \"none\",\n            margin: 0,\n            padding: 0,\n            \"& > li\": {\n                cursor: \"pointer\",\n                padding: \"1px 1em 1px 3px\",\n                lineHeight: 1.2\n            },\n            \"& > li[aria-selected]\": {\n                background_fallback: \"#bdf\",\n                backgroundColor: \"Highlight\",\n                color_fallback: \"white\",\n                color: \"HighlightText\"\n            }\n        }\n    },\n    \"$completionListIncompleteTop:before, $completionListIncompleteBottom:after\": {\n        content: '\"···\"',\n        opacity: 0.5,\n        display: \"block\",\n        textAlign: \"center\"\n    },\n    \"$tooltip.completionInfo\": {\n        position: \"absolute\",\n        padding: \"3px 9px\",\n        width: \"max-content\",\n        maxWidth: MaxInfoWidth + \"px\",\n    },\n    \"$tooltip.completionInfo.left\": { right: \"100%\" },\n    \"$tooltip.completionInfo.right\": { left: \"100%\" },\n    \"$$light $snippetField\": { backgroundColor: \"#ddd\" },\n    \"$$dark $snippetField\": { backgroundColor: \"#333\" },\n    \"$snippetFieldPosition\": {\n        verticalAlign: \"text-top\",\n        width: 0,\n        height: \"1.15em\",\n        margin: \"0 -0.7px -.7em\",\n        borderLeft: \"1.4px dotted #888\"\n    },\n    $completionMatchedText: {\n        textDecoration: \"underline\"\n    },\n    $completionDetail: {\n        marginLeft: \"0.5em\",\n        fontStyle: \"italic\"\n    },\n    $completionIcon: {\n        fontSize: \"90%\",\n        width: \".8em\",\n        display: \"inline-block\",\n        textAlign: \"center\",\n        paddingRight: \".6em\",\n        opacity: \"0.6\"\n    },\n    \"$completionIcon.function, $completionIcon.method\": {\n        \"&:after\": { content: \"'ƒ'\" }\n    },\n    \"$completionIcon.class\": {\n        \"&:after\": { content: \"'○'\" }\n    },\n    \"$completionIcon.interface\": {\n        \"&:after\": { content: \"'◌'\" }\n    },\n    \"$completionIcon.variable\": {\n        \"&:after\": { content: \"'𝑥'\" }\n    },\n    \"$completionIcon.constant\": {\n        \"&:after\": { content: \"'𝐶'\" }\n    },\n    \"$completionIcon.type\": {\n        \"&:after\": { content: \"'𝑡'\" }\n    },\n    \"$completionIcon.enum\": {\n        \"&:after\": { content: \"'∪'\" }\n    },\n    \"$completionIcon.property\": {\n        \"&:after\": { content: \"'□'\" }\n    },\n    \"$completionIcon.keyword\": {\n        \"&:after\": { content: \"'🔑\\uFE0E'\" } // Disable emoji rendering\n    },\n    \"$completionIcon.namespace\": {\n        \"&:after\": { content: \"'▢'\" }\n    },\n    \"$completionIcon.text\": {\n        \"&:after\": { content: \"'abc'\", fontSize: \"50%\", verticalAlign: \"middle\" }\n    }\n});\n\nfunction createListBox(options, id, range) {\n    const ul = document.createElement(\"ul\");\n    ul.id = id;\n    ul.setAttribute(\"role\", \"listbox\");\n    ul.setAttribute(\"aria-expanded\", \"true\");\n    for (let i = range.from; i < range.to; i++) {\n        let { completion, match } = options[i];\n        const li = ul.appendChild(document.createElement(\"li\"));\n        li.id = id + \"-\" + i;\n        let icon = li.appendChild(document.createElement(\"div\"));\n        icon.className = themeClass(\"completionIcon\" + (completion.type ? \".\" + completion.type : \"\"));\n        icon.setAttribute(\"aria-hidden\", \"true\");\n        let labelElt = li.appendChild(document.createElement(\"span\"));\n        labelElt.className = themeClass(\"completionLabel\");\n        let { label, detail } = completion, off = 0;\n        for (let j = 1; j < match.length;) {\n            let from = match[j++], to = match[j++];\n            if (from > off)\n                labelElt.appendChild(document.createTextNode(label.slice(off, from)));\n            let span = labelElt.appendChild(document.createElement(\"span\"));\n            span.appendChild(document.createTextNode(label.slice(from, to)));\n            span.className = themeClass(\"completionMatchedText\");\n            off = to;\n        }\n        if (off < label.length)\n            labelElt.appendChild(document.createTextNode(label.slice(off)));\n        if (detail) {\n            let detailElt = li.appendChild(document.createElement(\"span\"));\n            detailElt.className = themeClass(\"completionDetail\");\n            detailElt.textContent = detail;\n        }\n        li.setAttribute(\"role\", \"option\");\n    }\n    if (range.from)\n        ul.classList.add(themeClass(\"completionListIncompleteTop\"));\n    if (range.to < options.length)\n        ul.classList.add(themeClass(\"completionListIncompleteBottom\"));\n    return ul;\n}\nfunction createInfoDialog(option) {\n    let dom = document.createElement(\"div\");\n    dom.className = themeClass(\"tooltip.completionInfo\");\n    let { info } = option.completion;\n    if (typeof info == \"string\")\n        dom.textContent = info;\n    else\n        dom.appendChild(info(option.completion));\n    return dom;\n}\nfunction rangeAroundSelected(total, selected, max) {\n    if (total <= max)\n        return { from: 0, to: total };\n    if (selected <= (total >> 1)) {\n        let off = Math.floor(selected / max);\n        return { from: off * max, to: (off + 1) * max };\n    }\n    let off = Math.floor((total - selected) / max);\n    return { from: total - (off + 1) * max, to: total - off * max };\n}\nclass CompletionTooltip {\n    constructor(view, stateField) {\n        this.view = view;\n        this.stateField = stateField;\n        this.info = null;\n        this.placeInfo = {\n            read: () => this.measureInfo(),\n            write: (pos) => this.positionInfo(pos),\n            key: this\n        };\n        let cState = view.state.field(stateField);\n        let { options, selected } = cState.open;\n        let config = view.state.facet(completionConfig);\n        this.range = rangeAroundSelected(options.length, selected, config.maxRenderedOptions);\n        this.dom = document.createElement(\"div\");\n        this.dom.addEventListener(\"mousedown\", (e) => {\n            for (let dom = e.target, match; dom && dom != this.dom; dom = dom.parentNode) {\n                if (dom.nodeName == \"LI\" && (match = /-(\\d+)$/.exec(dom.id)) && +match[1] < options.length) {\n                    applyCompletion(view, options[+match[1]]);\n                    e.preventDefault();\n                    return;\n                }\n            }\n        });\n        this.list = this.dom.appendChild(createListBox(options, cState.id, this.range));\n        this.list.addEventListener(\"scroll\", () => {\n            if (this.info)\n                this.view.requestMeasure(this.placeInfo);\n        });\n    }\n    mount() { this.updateSel(); }\n    update(update) {\n        if (update.state.field(this.stateField) != update.startState.field(this.stateField))\n            this.updateSel();\n    }\n    positioned() {\n        if (this.info)\n            this.view.requestMeasure(this.placeInfo);\n    }\n    updateSel() {\n        let cState = this.view.state.field(this.stateField), open = cState.open;\n        if (open.selected < this.range.from || open.selected >= this.range.to) {\n            this.range = rangeAroundSelected(open.options.length, open.selected, this.view.state.facet(completionConfig).maxRenderedOptions);\n            this.list.remove();\n            this.list = this.dom.appendChild(createListBox(open.options, cState.id, this.range));\n            this.list.addEventListener(\"scroll\", () => {\n                if (this.info)\n                    this.view.requestMeasure(this.placeInfo);\n            });\n        }\n        if (this.updateSelectedOption(open.selected)) {\n            if (this.info) {\n                this.info.remove();\n                this.info = null;\n            }\n            let option = open.options[open.selected];\n            if (option.completion.info) {\n                this.info = this.dom.appendChild(createInfoDialog(option));\n                this.view.requestMeasure(this.placeInfo);\n            }\n        }\n    }\n    updateSelectedOption(selected) {\n        let set = null;\n        for (let opt = this.list.firstChild, i = this.range.from; opt; opt = opt.nextSibling, i++) {\n            if (i == selected) {\n                if (!opt.hasAttribute(\"aria-selected\")) {\n                    opt.setAttribute(\"aria-selected\", \"true\");\n                    set = opt;\n                }\n            }\n            else {\n                if (opt.hasAttribute(\"aria-selected\"))\n                    opt.removeAttribute(\"aria-selected\");\n            }\n        }\n        if (set)\n            scrollIntoView(this.list, set);\n        return set;\n    }\n    measureInfo() {\n        let sel = this.dom.querySelector(\"[aria-selected]\");\n        if (!sel)\n            return null;\n        let rect = this.dom.getBoundingClientRect();\n        let top = sel.getBoundingClientRect().top - rect.top;\n        if (top < 0 || top > this.list.clientHeight - 10)\n            return null;\n        let left = this.view.textDirection == Direction.RTL;\n        let spaceLeft = rect.left, spaceRight = innerWidth - rect.right;\n        if (left && spaceLeft < Math.min(MaxInfoWidth, spaceRight))\n            left = false;\n        else if (!left && spaceRight < Math.min(MaxInfoWidth, spaceLeft))\n            left = true;\n        return { top, left };\n    }\n    positionInfo(pos) {\n        if (this.info && pos) {\n            this.info.style.top = pos.top + \"px\";\n            this.info.classList.toggle(\"cm-tooltip-completionInfo-left\", pos.left);\n            this.info.classList.toggle(\"cm-tooltip-completionInfo-right\", !pos.left);\n        }\n    }\n}\n// We allocate a new function instance every time the completion\n// changes to force redrawing/repositioning of the tooltip\nfunction completionTooltip(stateField) {\n    return (view) => new CompletionTooltip(view, stateField);\n}\nfunction scrollIntoView(container, element) {\n    let parent = container.getBoundingClientRect();\n    let self = element.getBoundingClientRect();\n    if (self.top < parent.top)\n        container.scrollTop -= parent.top - self.top;\n    else if (self.bottom > parent.bottom)\n        container.scrollTop += self.bottom - parent.bottom;\n}\n\nconst MaxOptions = 300;\n// Used to pick a preferred option when two options with the same\n// label occur in the result.\nfunction score(option) {\n    return (option.boost || 0) * 100 + (option.apply ? 10 : 0) + (option.info ? 5 : 0) +\n        (option.type ? 1 : 0);\n}\nfunction sortOptions(active, state) {\n    let options = [];\n    for (let a of active)\n        if (a.hasResult()) {\n            let matcher = new FuzzyMatcher(state.sliceDoc(a.from, a.to)), match;\n            for (let option of a.result.options)\n                if (match = matcher.match(option.label)) {\n                    if (option.boost != null)\n                        match[0] += option.boost;\n                    options.push(new Option(option, a, match));\n                }\n        }\n    options.sort(cmpOption);\n    let result = [], prev = null;\n    for (let opt of options.sort(cmpOption)) {\n        if (result.length == MaxOptions)\n            break;\n        if (!prev || prev.label != opt.completion.label || prev.detail != opt.completion.detail)\n            result.push(opt);\n        else if (score(opt.completion) > score(prev))\n            result[result.length - 1] = opt;\n        prev = opt.completion;\n    }\n    return result;\n}\nclass CompletionDialog {\n    constructor(options, attrs, tooltip, timestamp, selected) {\n        this.options = options;\n        this.attrs = attrs;\n        this.tooltip = tooltip;\n        this.timestamp = timestamp;\n        this.selected = selected;\n    }\n    setSelected(selected, id) {\n        return selected == this.selected || selected >= this.options.length ? this\n            : new CompletionDialog(this.options, makeAttrs(id, selected), this.tooltip, this.timestamp, selected);\n    }\n    static build(active, state, id, prev) {\n        let options = sortOptions(active, state);\n        if (!options.length)\n            return null;\n        let selected = 0;\n        if (prev) {\n            let selectedValue = prev.options[prev.selected].completion;\n            for (let i = 0; i < options.length && !selected; i++) {\n                if (options[i].completion == selectedValue)\n                    selected = i;\n            }\n        }\n        return new CompletionDialog(options, makeAttrs(id, selected), [{\n                pos: active.reduce((a, b) => b.hasResult() ? Math.min(a, b.from) : a, 1e8),\n                style: \"autocomplete\",\n                create: completionTooltip(completionState)\n            }], prev ? prev.timestamp : Date.now(), selected);\n    }\n    map(changes) {\n        return new CompletionDialog(this.options, this.attrs, [Object.assign(Object.assign({}, this.tooltip[0]), { pos: changes.mapPos(this.tooltip[0].pos) })], this.timestamp, this.selected);\n    }\n}\nclass CompletionState {\n    constructor(active, id, open) {\n        this.active = active;\n        this.id = id;\n        this.open = open;\n    }\n    static start() {\n        return new CompletionState(none, \"cm-ac-\" + Math.floor(Math.random() * 2e6).toString(36), null);\n    }\n    update(tr) {\n        let { state } = tr, conf = state.facet(completionConfig);\n        let sources = conf.override ||\n            state.languageDataAt(\"autocomplete\", cur(state)).map(asSource);\n        let active = sources.map(source => {\n            let value = this.active.find(s => s.source == source) || new ActiveSource(source, 0 /* Inactive */, false);\n            return value.update(tr, conf);\n        });\n        if (active.length == this.active.length && active.every((a, i) => a == this.active[i]))\n            active = this.active;\n        let open = tr.selection || active.some(a => a.hasResult() && tr.changes.touchesRange(a.from, a.to)) ||\n            !sameResults(active, this.active) ? CompletionDialog.build(active, state, this.id, this.open)\n            : this.open && tr.docChanged ? this.open.map(tr.changes) : this.open;\n        for (let effect of tr.effects)\n            if (effect.is(setSelectedEffect))\n                open = open && open.setSelected(effect.value, this.id);\n        return active == this.active && open == this.open ? this : new CompletionState(active, this.id, open);\n    }\n    get tooltip() { return this.open ? this.open.tooltip : none; }\n    get attrs() { return this.open ? this.open.attrs : baseAttrs; }\n}\nfunction sameResults(a, b) {\n    if (a == b)\n        return true;\n    for (let iA = 0, iB = 0;;) {\n        while (iA < a.length && !a[iA].hasResult)\n            iA++;\n        while (iB < b.length && !b[iB].hasResult)\n            iB++;\n        let endA = iA == a.length, endB = iB == b.length;\n        if (endA || endB)\n            return endA == endB;\n        if (a[iA++].result != b[iB++].result)\n            return false;\n    }\n}\nfunction makeAttrs(id, selected) {\n    return {\n        \"aria-autocomplete\": \"list\",\n        \"aria-activedescendant\": id + \"-\" + selected,\n        \"aria-owns\": id\n    };\n}\nconst baseAttrs = { \"aria-autocomplete\": \"list\" }, none = [];\nfunction cmpOption(a, b) {\n    let dScore = b.match[0] - a.match[0];\n    if (dScore)\n        return dScore;\n    let lA = a.completion.label, lB = b.completion.label;\n    return lA < lB ? -1 : lA == lB ? 0 : 1;\n}\nclass ActiveSource {\n    constructor(source, state, explicit) {\n        this.source = source;\n        this.state = state;\n        this.explicit = explicit;\n    }\n    hasResult() { return false; }\n    update(tr, conf) {\n        let event = tr.annotation(Transaction.userEvent), value = this;\n        if (event == \"input\" || event == \"delete\")\n            value = value.handleUserEvent(tr, event, conf);\n        else if (tr.docChanged)\n            value = value.handleChange(tr);\n        else if (tr.selection && value.state != 0 /* Inactive */)\n            value = new ActiveSource(value.source, 0 /* Inactive */, false);\n        for (let effect of tr.effects) {\n            if (effect.is(startCompletionEffect))\n                value = new ActiveSource(value.source, 1 /* Pending */, effect.value);\n            else if (effect.is(closeCompletionEffect))\n                value = new ActiveSource(value.source, 0 /* Inactive */, false);\n            else if (effect.is(setActiveEffect))\n                for (let active of effect.value)\n                    if (active.source == value.source)\n                        value = active;\n        }\n        return value;\n    }\n    handleUserEvent(_tr, type, conf) {\n        return type == \"delete\" || !conf.activateOnTyping ? this : new ActiveSource(this.source, 1 /* Pending */, false);\n    }\n    handleChange(tr) {\n        return tr.changes.touchesRange(cur(tr.startState)) ? new ActiveSource(this.source, 0 /* Inactive */, false) : this;\n    }\n}\nclass ActiveResult extends ActiveSource {\n    constructor(source, explicit, result, from, to, span) {\n        super(source, 2 /* Result */, explicit);\n        this.result = result;\n        this.from = from;\n        this.to = to;\n        this.span = span;\n    }\n    hasResult() { return true; }\n    handleUserEvent(tr, type, conf) {\n        let from = tr.changes.mapPos(this.from), to = tr.changes.mapPos(this.to, 1);\n        let pos = cur(tr.state);\n        if ((this.explicit ? pos < from : pos <= from) || pos > to)\n            return new ActiveSource(this.source, type == \"input\" && conf.activateOnTyping ? 1 /* Pending */ : 0 /* Inactive */, false);\n        if (this.span && (from == to || this.span.test(tr.state.sliceDoc(from, to))))\n            return new ActiveResult(this.source, this.explicit, this.result, from, to, this.span);\n        return new ActiveSource(this.source, 1 /* Pending */, this.explicit);\n    }\n    handleChange(tr) {\n        return tr.changes.touchesRange(this.from, this.to)\n            ? new ActiveSource(this.source, 0 /* Inactive */, false)\n            : new ActiveResult(this.source, this.explicit, this.result, tr.changes.mapPos(this.from), tr.changes.mapPos(this.to, 1), this.span);\n    }\n    map(mapping) {\n        return new ActiveResult(this.source, this.explicit, this.result, mapping.mapPos(this.from), mapping.mapPos(this.to, 1), this.span);\n    }\n}\nconst startCompletionEffect = StateEffect.define();\nconst closeCompletionEffect = StateEffect.define();\nconst setActiveEffect = StateEffect.define({\n    map(sources, mapping) { return sources.map(s => s.hasResult() && !mapping.empty ? s.map(mapping) : s); }\n});\nconst setSelectedEffect = StateEffect.define();\nconst completionState = StateField.define({\n    create() { return CompletionState.start(); },\n    update(value, tr) { return value.update(tr); },\n    provide: f => [\n        showTooltip.computeN([f], state => state.field(f).tooltip),\n        EditorView.contentAttributes.from(f, state => state.attrs)\n    ]\n});\n\nconst CompletionInteractMargin = 75;\n/// Returns a command that moves the completion selection forward or\n/// backward by the given amount.\nfunction moveCompletionSelection(forward, by = \"option\") {\n    return (view) => {\n        let cState = view.state.field(completionState, false);\n        if (!cState || !cState.open || Date.now() - cState.open.timestamp < CompletionInteractMargin)\n            return false;\n        let step = 1, tooltip;\n        if (by == \"page\" && (tooltip = view.dom.querySelector(\".cm-tooltip-autocomplete\")))\n            step = Math.max(2, Math.floor(tooltip.offsetHeight / tooltip.firstChild.offsetHeight));\n        let selected = cState.open.selected + step * (forward ? 1 : -1), { length } = cState.open.options;\n        if (selected < 0)\n            selected = by == \"page\" ? 0 : length - 1;\n        else if (selected >= length)\n            selected = by == \"page\" ? length - 1 : 0;\n        view.dispatch({ effects: setSelectedEffect.of(selected) });\n        return true;\n    };\n}\n/// Accept the current completion.\nconst acceptCompletion = (view) => {\n    let cState = view.state.field(completionState, false);\n    if (!cState || !cState.open || Date.now() - cState.open.timestamp < CompletionInteractMargin)\n        return false;\n    applyCompletion(view, cState.open.options[cState.open.selected]);\n    return true;\n};\n/// Explicitly start autocompletion.\nconst startCompletion = (view) => {\n    let cState = view.state.field(completionState, false);\n    if (!cState)\n        return false;\n    view.dispatch({ effects: startCompletionEffect.of(true) });\n    return true;\n};\n/// Close the currently active completion.\nconst closeCompletion = (view) => {\n    let cState = view.state.field(completionState, false);\n    if (!cState || !cState.active.some(a => a.state != 0 /* Inactive */))\n        return false;\n    view.dispatch({ effects: closeCompletionEffect.of(null) });\n    return true;\n};\nclass RunningQuery {\n    constructor(source, context) {\n        this.source = source;\n        this.context = context;\n        this.time = Date.now();\n        this.updates = [];\n        // Note that 'undefined' means 'not done yet', whereas 'null' means\n        // 'query returned null'.\n        this.done = undefined;\n    }\n}\nconst DebounceTime = 50, MaxUpdateCount = 50, MinAbortTime = 1000;\nconst completionPlugin = ViewPlugin.fromClass(class {\n    constructor(view) {\n        this.view = view;\n        this.debounceUpdate = -1;\n        this.running = [];\n        this.debounceAccept = -1;\n        this.composing = 0 /* None */;\n        for (let active of view.state.field(completionState).active)\n            if (active.state == 1 /* Pending */)\n                this.startQuery(active);\n    }\n    update(update) {\n        let cState = update.state.field(completionState);\n        if (!update.selectionSet && !update.docChanged && update.startState.field(completionState) == cState)\n            return;\n        let doesReset = update.transactions.some(tr => {\n            let event = tr.annotation(Transaction.userEvent);\n            return (tr.selection || tr.docChanged) && event != \"input\" && event != \"delete\";\n        });\n        for (let i = 0; i < this.running.length; i++) {\n            let query = this.running[i];\n            if (doesReset ||\n                query.updates.length + update.transactions.length > MaxUpdateCount && query.time - Date.now() > MinAbortTime) {\n                for (let handler of query.context.abortListeners) {\n                    try {\n                        handler();\n                    }\n                    catch (e) {\n                        logException(this.view.state, e);\n                    }\n                }\n                query.context.abortListeners = null;\n                this.running.splice(i--, 1);\n            }\n            else {\n                query.updates.push(...update.transactions);\n            }\n        }\n        if (this.debounceUpdate > -1)\n            clearTimeout(this.debounceUpdate);\n        this.debounceUpdate = cState.active.some(a => a.state == 1 /* Pending */ && !this.running.some(q => q.source == a.source))\n            ? setTimeout(() => this.startUpdate(), DebounceTime) : -1;\n        if (this.composing != 0 /* None */)\n            for (let tr of update.transactions) {\n                if (tr.annotation(Transaction.userEvent) == \"input\")\n                    this.composing = 2 /* Changed */;\n                else if (this.composing == 2 /* Changed */ && tr.selection)\n                    this.composing = 3 /* ChangedAndMoved */;\n            }\n    }\n    startUpdate() {\n        this.debounceUpdate = -1;\n        let { state } = this.view, cState = state.field(completionState);\n        for (let active of cState.active) {\n            if (active.state == 1 /* Pending */ && !this.running.some(r => r.source == active.source))\n                this.startQuery(active);\n        }\n    }\n    startQuery(active) {\n        let { state } = this.view, pos = cur(state);\n        let context = new CompletionContext(state, pos, active.explicit);\n        let pending = new RunningQuery(active.source, context);\n        this.running.push(pending);\n        Promise.resolve(active.source(context)).then(result => {\n            if (!pending.context.aborted) {\n                pending.done = result || null;\n                this.scheduleAccept();\n            }\n        }, err => {\n            this.view.dispatch({ effects: closeCompletionEffect.of(null) });\n            logException(this.view.state, err);\n        });\n    }\n    scheduleAccept() {\n        if (this.running.every(q => q.done !== undefined))\n            this.accept();\n        else if (this.debounceAccept < 0)\n            this.debounceAccept = setTimeout(() => this.accept(), DebounceTime);\n    }\n    // For each finished query in this.running, try to create a result\n    // or, if appropriate, restart the query.\n    accept() {\n        var _a;\n        if (this.debounceAccept > -1)\n            clearTimeout(this.debounceAccept);\n        this.debounceAccept = -1;\n        let updated = [];\n        let conf = this.view.state.facet(completionConfig);\n        for (let i = 0; i < this.running.length; i++) {\n            let query = this.running[i];\n            if (query.done === undefined)\n                continue;\n            this.running.splice(i--, 1);\n            if (query.done) {\n                let active = new ActiveResult(query.source, query.context.explicit, query.done, query.done.from, (_a = query.done.to) !== null && _a !== void 0 ? _a : cur(query.updates.length ? query.updates[0].startState : this.view.state), query.done.span ? ensureAnchor(query.done.span, true) : null);\n                // Replay the transactions that happened since the start of\n                // the request and see if that preserves the result\n                for (let tr of query.updates)\n                    active = active.update(tr, conf);\n                if (active.hasResult()) {\n                    updated.push(active);\n                    continue;\n                }\n            }\n            let current = this.view.state.field(completionState).active.find(a => a.source == query.source);\n            if (current && current.state == 1 /* Pending */) {\n                if (query.done == null) {\n                    // Explicitly failed. Should clear the pending status if it\n                    // hasn't been re-set in the meantime.\n                    let active = new ActiveSource(query.source, 0 /* Inactive */, false);\n                    for (let tr of query.updates)\n                        active = active.update(tr, conf);\n                    if (active.state != 1 /* Pending */)\n                        updated.push(active);\n                }\n                else {\n                    // Cleared by subsequent transactions. Restart.\n                    this.startQuery(current);\n                }\n            }\n        }\n        if (updated.length)\n            this.view.dispatch({ effects: setActiveEffect.of(updated) });\n    }\n}, {\n    eventHandlers: {\n        compositionstart() {\n            this.composing = 1 /* Started */;\n        },\n        compositionend() {\n            if (this.composing == 3 /* ChangedAndMoved */)\n                this.view.dispatch({ effects: startCompletionEffect.of(false) });\n            this.composing = 0 /* None */;\n        }\n    }\n});\n\nclass FieldPos {\n    constructor(field, line, from, to) {\n        this.field = field;\n        this.line = line;\n        this.from = from;\n        this.to = to;\n    }\n}\nclass FieldRange {\n    constructor(field, from, to) {\n        this.field = field;\n        this.from = from;\n        this.to = to;\n    }\n    map(changes) {\n        return new FieldRange(this.field, changes.mapPos(this.from, -1), changes.mapPos(this.to, 1));\n    }\n}\nclass Snippet {\n    constructor(lines, fieldPositions) {\n        this.lines = lines;\n        this.fieldPositions = fieldPositions;\n    }\n    instantiate(state, pos) {\n        let text = [], lineStart = [pos];\n        let lineObj = state.doc.lineAt(pos), baseIndent = /^\\s*/.exec(lineObj.text)[0];\n        for (let line of this.lines) {\n            if (text.length) {\n                let indent = baseIndent, tabs = /^\\t*/.exec(line)[0].length;\n                for (let i = 0; i < tabs; i++)\n                    indent += state.facet(indentUnit);\n                lineStart.push(pos + indent.length - tabs);\n                line = indent + line.slice(tabs);\n            }\n            text.push(line);\n            pos += line.length + 1;\n        }\n        let ranges = this.fieldPositions.map(pos => new FieldRange(pos.field, lineStart[pos.line] + pos.from, lineStart[pos.line] + pos.to));\n        return { text, ranges };\n    }\n    static parse(template) {\n        let fields = [];\n        let lines = [], positions = [], m;\n        for (let line of template.split(/\\r\\n?|\\n/)) {\n            while (m = /[#$]\\{(?:(\\d+)(?::([^}]*))?|([^}]*))\\}/.exec(line)) {\n                let seq = m[1] ? +m[1] : null, name = m[2] || m[3], found = -1;\n                for (let i = 0; i < fields.length; i++) {\n                    if (name ? fields[i].name == name : seq != null && fields[i].seq == seq)\n                        found = i;\n                }\n                if (found < 0) {\n                    let i = 0;\n                    while (i < fields.length && (seq == null || (fields[i].seq != null && fields[i].seq < seq)))\n                        i++;\n                    fields.splice(i, 0, { seq, name: name || null });\n                    found = i;\n                }\n                positions.push(new FieldPos(found, lines.length, m.index, m.index + name.length));\n                line = line.slice(0, m.index) + name + line.slice(m.index + m[0].length);\n            }\n            lines.push(line);\n        }\n        return new Snippet(lines, positions);\n    }\n}\nlet fieldMarker = Decoration.widget({ widget: new class extends WidgetType {\n        toDOM() {\n            let span = document.createElement(\"span\");\n            span.className = themeClass(\"snippetFieldPosition\");\n            return span;\n        }\n        ignoreEvent() { return false; }\n    } });\nlet fieldRange = Decoration.mark({ class: themeClass(\"snippetField\") });\nclass ActiveSnippet {\n    constructor(ranges, active) {\n        this.ranges = ranges;\n        this.active = active;\n        this.deco = Decoration.set(ranges.map(r => (r.from == r.to ? fieldMarker : fieldRange).range(r.from, r.to)));\n    }\n    map(changes) {\n        return new ActiveSnippet(this.ranges.map(r => r.map(changes)), this.active);\n    }\n    selectionInsideField(sel) {\n        return sel.ranges.every(range => this.ranges.some(r => r.field == this.active && r.from <= range.from && r.to >= range.to));\n    }\n}\nconst setActive = StateEffect.define({\n    map(value, changes) { return value && value.map(changes); }\n});\nconst moveToField = StateEffect.define();\nconst snippetState = StateField.define({\n    create() { return null; },\n    update(value, tr) {\n        for (let effect of tr.effects) {\n            if (effect.is(setActive))\n                return effect.value;\n            if (effect.is(moveToField) && value)\n                return new ActiveSnippet(value.ranges, effect.value);\n        }\n        if (value && tr.docChanged)\n            value = value.map(tr.changes);\n        if (value && tr.selection && !value.selectionInsideField(tr.selection))\n            value = null;\n        return value;\n    },\n    provide: f => EditorView.decorations.from(f, val => val ? val.deco : Decoration.none)\n});\nfunction fieldSelection(ranges, field) {\n    return EditorSelection.create(ranges.filter(r => r.field == field).map(r => EditorSelection.range(r.from, r.to)));\n}\n/// Convert a snippet template to a function that can apply it.\n/// Snippets are written using syntax like this:\n///\n///     \"for (let ${index} = 0; ${index} < ${end}; ${index}++) {\\n\\t${}\\n}\"\n///\n/// Each `${}` placeholder (you may also use `#{}`) indicates a field\n/// that the user can fill in. Its name, if any, will be the default\n/// content for the field.\n///\n/// When the snippet is activated by calling the returned function,\n/// the code is inserted at the given position. Newlines in the\n/// template are indented by the indentation of the start line, plus\n/// one [indent unit](#language.indentUnit) per tab character after\n/// the newline.\n///\n/// On activation, (all instances of) the first field are selected.\n/// The user can move between fields with Tab and Shift-Tab as long as\n/// the fields are active. Moving to the last field or moving the\n/// cursor out of the current field deactivates the fields.\n///\n/// The order of fields defaults to textual order, but you can add\n/// numbers to placeholders (`${1}` or `${1:defaultText}`) to provide\n/// a custom order.\nfunction snippet(template) {\n    let snippet = Snippet.parse(template);\n    return (editor, _completion, from, to) => {\n        let { text, ranges } = snippet.instantiate(editor.state, from);\n        let spec = { changes: { from, to, insert: Text.of(text) } };\n        if (ranges.length)\n            spec.selection = fieldSelection(ranges, 0);\n        if (ranges.length > 1) {\n            spec.effects = setActive.of(new ActiveSnippet(ranges, 0));\n            if (editor.state.field(snippetState, false) === undefined)\n                spec.reconfigure = { append: [snippetState, addSnippetKeymap, baseTheme] };\n        }\n        editor.dispatch(editor.state.update(spec));\n    };\n}\nfunction moveField(dir) {\n    return ({ state, dispatch }) => {\n        let active = state.field(snippetState, false);\n        if (!active || dir < 0 && active.active == 0)\n            return false;\n        let next = active.active + dir, last = dir > 0 && !active.ranges.some(r => r.field == next + dir);\n        dispatch(state.update({\n            selection: fieldSelection(active.ranges, next),\n            effects: setActive.of(last ? null : new ActiveSnippet(active.ranges, next))\n        }));\n        return true;\n    };\n}\n/// A command that clears the active snippet, if any.\nconst clearSnippet = ({ state, dispatch }) => {\n    let active = state.field(snippetState, false);\n    if (!active)\n        return false;\n    dispatch(state.update({ effects: setActive.of(null) }));\n    return true;\n};\n/// Move to the next snippet field, if available.\nconst nextSnippetField = moveField(1);\n/// Move to the previous snippet field, if available.\nconst prevSnippetField = moveField(-1);\nconst defaultSnippetKeymap = [\n    { key: \"Tab\", run: nextSnippetField, shift: prevSnippetField },\n    { key: \"Escape\", run: clearSnippet }\n];\n/// A facet that can be used to configure the key bindings used by\n/// snippets. The default binds Tab to\n/// [`nextSnippetField`](#autocomplete.nextSnippetField), Shift-Tab to\n/// [`prevSnippetField`](#autocomplete.prevSnippetField), and Escape\n/// to [`clearSnippet`](#autocomplete.clearSnippet).\nconst snippetKeymap = Facet.define({\n    combine(maps) { return maps.length ? maps[0] : defaultSnippetKeymap; }\n});\nconst addSnippetKeymap = Prec.override(keymap.compute([snippetKeymap], state => state.facet(snippetKeymap)));\n/// Create a completion from a snippet. Returns an object with the\n/// properties from `completion`, plus an `apply` function that\n/// applies the snippet.\nfunction snippetCompletion(template, completion) {\n    return Object.assign(Object.assign({}, completion), { apply: snippet(template) });\n}\n\n/// A completion source that will scan the document for words (using a\n/// [character categorizer](#state.EditorState.charCategorizer)), and\n/// return those as completions.\nconst completeAnyWord = context => {\n    let options = [], seen = Object.create(null);\n    let cat = context.state.charCategorizer(context.pos);\n    let start = Math.max(0, context.pos - 50000 /* Range */), end = Math.min(context.state.doc.length, start + 50000 /* Range */ * 2);\n    let from = context.pos;\n    for (let cur = context.state.doc.iterRange(start, end), pos = start; !(cur.next()).done;) {\n        let { value } = cur, start = -1;\n        for (let i = 0;; i++) {\n            if (i < value.length && cat(value[i]) == CharCategory.Word) {\n                if (start < 0)\n                    start = i;\n            }\n            else if (start > -1) {\n                if (pos + start <= context.pos && pos + i >= context.pos) {\n                    from = pos + start;\n                }\n                else {\n                    let word = value.slice(start, i);\n                    if (!seen[word]) {\n                        options.push({ type: \"text\", label: word });\n                        seen[word] = true;\n                    }\n                }\n                start = -1;\n            }\n            if (i == value.length)\n                break;\n        }\n        pos += value.length;\n    }\n    return { from, options, span: /^\\w*/ };\n};\n\n/// Returns an extension that enables autocompletion.\nfunction autocompletion(config = {}) {\n    return [\n        completionState,\n        completionConfig.of(config),\n        completionPlugin,\n        completionKeymapExt,\n        baseTheme,\n        tooltips()\n    ];\n}\n/// Basic keybindings for autocompletion.\n///\n///  - Ctrl-Space (Cmd-Space on macOS): [`startCompletion`](#autocomplete.startCompletion)\n///  - Escape: [`closeCompletion`](#autocomplete.closeCompletion)\n///  - ArrowDown: [`moveCompletionSelection`](#autocomplete.moveCompletionSelection)`(true)`\n///  - ArrowUp: [`moveCompletionSelection`](#autocomplete.moveCompletionSelection)`(false)`\n///  - PageDown: [`moveCompletionSelection`](#autocomplete.moveCompletionSelection)`(true, \"page\")`\n///  - PageDown: [`moveCompletionSelection`](#autocomplete.moveCompletionSelection)`(true, \"page\")`\n///  - Enter: [`acceptCompletion`](#autocomplete.acceptCompletion)\nconst completionKeymap = [\n    { key: \"Mod-Space\", run: startCompletion },\n    { key: \"Escape\", run: closeCompletion },\n    { key: \"ArrowDown\", run: moveCompletionSelection(true) },\n    { key: \"ArrowUp\", run: moveCompletionSelection(false) },\n    { key: \"PageDown\", run: moveCompletionSelection(true, \"page\") },\n    { key: \"PageUp\", run: moveCompletionSelection(false, \"page\") },\n    { key: \"Enter\", run: acceptCompletion }\n];\nconst completionKeymapExt = Prec.override(keymap.computeN([completionConfig], state => state.facet(completionConfig).defaultKeymap ? [completionKeymap] : []));\n/// Get the current completion status. When completions are available,\n/// this will return `\"active\"`. When completions are pending (in the\n/// process of being queried), this returns `\"pending\"`. Otherwise, it\n/// returns `null`.\nfunction completionStatus(state) {\n    let cState = state.field(completionState, false);\n    return cState && cState.active.some(a => a.state == 1 /* Pending */) ? \"pending\"\n        : cState && cState.active.some(a => a.state != 0 /* Inactive */) ? \"active\" : null;\n}\n/// Returns the available completions as an array.\nfunction currentCompletions(state) {\n    var _a;\n    let open = (_a = state.field(completionState, false)) === null || _a === void 0 ? void 0 : _a.open;\n    return open ? open.options.map(o => o.completion) : [];\n}\n\nexport { CompletionContext, acceptCompletion, autocompletion, clearSnippet, closeCompletion, completeAnyWord, completeFromList, completionKeymap, completionStatus, currentCompletions, ifNotIn, moveCompletionSelection, nextSnippetField, prevSnippetField, snippet, snippetCompletion, snippetKeymap, startCompletion };\n","import { highlightSpecialChars, drawSelection, highlightActiveLine, keymap } from '@codemirror/next/view';\nexport { EditorView } from '@codemirror/next/view';\nimport { EditorState } from '@codemirror/next/state';\nexport { EditorState } from '@codemirror/next/state';\nimport { history, historyKeymap } from '@codemirror/next/history';\nimport { foldGutter, foldKeymap } from '@codemirror/next/fold';\nimport { indentOnInput } from '@codemirror/next/language';\nimport { lineNumbers } from '@codemirror/next/gutter';\nimport { defaultKeymap } from '@codemirror/next/commands';\nimport { bracketMatching } from '@codemirror/next/matchbrackets';\nimport { closeBrackets, closeBracketsKeymap } from '@codemirror/next/closebrackets';\nimport { highlightSelectionMatches, searchKeymap } from '@codemirror/next/search';\nimport { autocompletion, completionKeymap } from '@codemirror/next/autocomplete';\nimport { commentKeymap } from '@codemirror/next/comment';\nimport { rectangularSelection } from '@codemirror/next/rectangular-selection';\nimport { defaultHighlightStyle } from '@codemirror/next/highlight';\nimport { lintKeymap } from '@codemirror/next/lint';\n\n/// This is an extension value that just pulls together a whole lot of\n/// extensions that you might want in a basic editor. It is meant as a\n/// convenient helper to quickly set up CodeMirror without installing\n/// and importing a lot of packages.\n///\n/// Specifically, it includes...\n///\n///  - [the default command bindings](#commands.defaultKeymap)\n///  - [line numbers](#gutter.lineNumbers)\n///  - [special character highlighting](#view.highlightSpecialChars)\n///  - [the undo history](#history.history)\n///  - [a fold gutter](#fold.foldGutter)\n///  - [custom selection drawing](#view.drawSelection)\n///  - [multiple selections](#state.EditorState^allowMultipleSelections)\n///  - [reindentation on input](#language.indentOnInput)\n///  - [the default highlight style](#highlight.defaultHighlightStyle)\n///  - [bracket matching](#matchbrackets.bracketMatching)\n///  - [bracket closing](#closebrackets.closeBrackets)\n///  - [autocompletion](#autocomplete.autocompletion)\n///  - [rectangular selection](#rectangular-selection.rectangularSelection)\n///  - [active line highlighting](#view.highlightActiveLine)\n///  - [selection match highlighting](#search.highlightSelectionMatches)\n///  - [search](#search.searchKeymap)\n///  - [commenting](#comment.commentKeymap)\n///  - [linting](#lint.lintKeymap)\n///\n/// (You'll probably want to add some language package to your setup\n/// too.)\n///\n/// This package does not allow customization. The idea is that, once\n/// you decide you want to configure your editor more precisely, you\n/// take this package's source (which is just a bunch of imports and\n/// an array literal), copy it into your own code, and adjust it as\n/// desired.\nconst basicSetup = [\n    lineNumbers(),\n    highlightSpecialChars(),\n    history(),\n    foldGutter(),\n    drawSelection(),\n    EditorState.allowMultipleSelections.of(true),\n    indentOnInput(),\n    defaultHighlightStyle,\n    bracketMatching(),\n    closeBrackets(),\n    autocompletion(),\n    rectangularSelection(),\n    highlightActiveLine(),\n    highlightSelectionMatches(),\n    keymap.of([\n        ...closeBracketsKeymap,\n        ...defaultKeymap,\n        ...searchKeymap,\n        ...historyKeymap,\n        ...foldKeymap,\n        ...commentKeymap,\n        ...completionKeymap,\n        ...lintKeymap\n    ])\n];\n\nexport { basicSetup };\n","import { EditorView } from '@codemirror/next/view';\nimport { StateEffect, MapMode, StateField, EditorSelection, Transaction, CharCategory } from '@codemirror/next/state';\nimport { RangeValue, RangeSet } from '@codemirror/next/rangeset';\nimport { codePointSize, codePointAt, fromCodePoint } from '@codemirror/next/text';\nimport { syntaxTree } from '@codemirror/next/language';\n\nconst defaults = {\n    brackets: [\"(\", \"[\", \"{\", \"'\", '\"'],\n    before: \")]}'\\\":;>\"\n};\nconst closeBracketEffect = StateEffect.define({\n    map(value, mapping) {\n        let mapped = mapping.mapPos(value, -1, MapMode.TrackAfter);\n        return mapped == null ? undefined : mapped;\n    }\n});\nconst skipBracketEffect = StateEffect.define({\n    map(value, mapping) { return mapping.mapPos(value); }\n});\nconst closedBracket = new class extends RangeValue {\n};\nclosedBracket.startSide = 1;\nclosedBracket.endSide = -1;\nconst bracketState = StateField.define({\n    create() { return RangeSet.empty; },\n    update(value, tr) {\n        if (tr.selection) {\n            let lineStart = tr.state.doc.lineAt(tr.selection.main.head).from;\n            let prevLineStart = tr.startState.doc.lineAt(tr.startState.selection.main.head).from;\n            if (lineStart != tr.changes.mapPos(prevLineStart, -1))\n                value = RangeSet.empty;\n        }\n        value = value.map(tr.changes);\n        for (let effect of tr.effects) {\n            if (effect.is(closeBracketEffect))\n                value = value.update({ add: [closedBracket.range(effect.value, effect.value + 1)] });\n            else if (effect.is(skipBracketEffect))\n                value = value.update({ filter: from => from != effect.value });\n        }\n        return value;\n    }\n});\n/// Extension to enable bracket-closing behavior. When a closeable\n/// bracket is typed, its closing bracket is immediately inserted\n/// after the cursor. When closing a bracket directly in front of a\n/// closing bracket inserted by the extension, the cursor moves over\n/// that bracket.\nfunction closeBrackets() {\n    return [EditorView.inputHandler.of(handleInput), bracketState];\n}\nconst definedClosing = \"()[]{}<>\";\nfunction closing(ch) {\n    for (let i = 0; i < definedClosing.length; i += 2)\n        if (definedClosing.charCodeAt(i) == ch)\n            return definedClosing.charAt(i + 1);\n    return fromCodePoint(ch < 128 ? ch : ch + 1);\n}\nfunction config(state, pos) {\n    return state.languageDataAt(\"closeBrackets\", pos)[0] || defaults;\n}\nfunction handleInput(view, from, to, insert) {\n    if (view.composing)\n        return false;\n    let sel = view.state.selection.main;\n    if (insert.length > 2 || insert.length == 2 && codePointSize(codePointAt(insert, 0)) == 1 ||\n        from != sel.from || to != sel.to)\n        return false;\n    let tr = handleInsertion(view.state, insert);\n    if (!tr)\n        return false;\n    view.dispatch(tr);\n    return true;\n}\n/// Command that implements deleting a pair of matching brackets when\n/// the cursor is between them.\nconst deleteBracketPair = ({ state, dispatch }) => {\n    let conf = config(state, state.selection.main.head);\n    let tokens = conf.brackets || defaults.brackets;\n    let dont = null, changes = state.changeByRange(range => {\n        if (range.empty) {\n            let before = prevChar(state.doc, range.head);\n            for (let token of tokens) {\n                if (token == before && nextChar(state.doc, range.head) == closing(codePointAt(token, 0)))\n                    return { changes: { from: range.head - token.length, to: range.head + token.length },\n                        range: EditorSelection.cursor(range.head - token.length),\n                        annotations: Transaction.userEvent.of(\"delete\") };\n            }\n        }\n        return { range: dont = range };\n    });\n    if (!dont)\n        dispatch(state.update(changes, { scrollIntoView: true }));\n    return !dont;\n};\n/// Close-brackets related key bindings. Binds Backspace to\n/// [`deleteBracketPair`](#closebrackets.deleteBracketPair).\nconst closeBracketsKeymap = [\n    { key: \"Backspace\", run: deleteBracketPair }\n];\n/// Implements the extension's behavior on text insertion. @internal\nfunction handleInsertion(state, ch) {\n    let conf = config(state, state.selection.main.head);\n    let tokens = conf.brackets || defaults.brackets;\n    for (let tok of tokens) {\n        let closed = closing(codePointAt(tok, 0));\n        if (ch == tok)\n            return closed == tok ? handleSame(state, tok, tokens.indexOf(tok + tok + tok) > -1)\n                : handleOpen(state, tok, closed, conf.before || defaults.before);\n        if (ch == closed && closedBracketAt(state, state.selection.main.from))\n            return handleClose(state, tok, closed);\n    }\n    return null;\n}\nfunction closedBracketAt(state, pos) {\n    let found = false;\n    state.field(bracketState).between(0, state.doc.length, from => {\n        if (from == pos)\n            found = true;\n    });\n    return found;\n}\nfunction nextChar(doc, pos) {\n    let next = doc.sliceString(pos, pos + 2);\n    return next.slice(0, codePointSize(codePointAt(next, 0)));\n}\nfunction prevChar(doc, pos) {\n    let prev = doc.sliceString(pos - 2, pos);\n    return codePointSize(codePointAt(prev, 0)) == prev.length ? prev : prev.slice(1);\n}\nfunction handleOpen(state, open, close, closeBefore) {\n    let dont = null, changes = state.changeByRange(range => {\n        if (!range.empty)\n            return { changes: [{ insert: open, from: range.from }, { insert: close, from: range.to }],\n                effects: closeBracketEffect.of(range.to + open.length),\n                range: EditorSelection.range(range.anchor + open.length, range.head + open.length) };\n        let next = nextChar(state.doc, range.head);\n        if (!next || /\\s/.test(next) || closeBefore.indexOf(next) > -1)\n            return { changes: { insert: open + close, from: range.head },\n                effects: closeBracketEffect.of(range.head + open.length),\n                range: EditorSelection.cursor(range.head + open.length) };\n        return { range: dont = range };\n    });\n    return dont ? null : state.update(changes, {\n        scrollIntoView: true,\n        annotations: Transaction.userEvent.of(\"input\")\n    });\n}\nfunction handleClose(state, _open, close) {\n    let dont = null, moved = state.selection.ranges.map(range => {\n        if (range.empty && nextChar(state.doc, range.head) == close)\n            return EditorSelection.cursor(range.head + close.length);\n        return dont = range;\n    });\n    return dont ? null : state.update({\n        selection: EditorSelection.create(moved, state.selection.mainIndex),\n        scrollIntoView: true,\n        effects: state.selection.ranges.map(({ from }) => skipBracketEffect.of(from))\n    });\n}\n// Handles cases where the open and close token are the same, and\n// possibly triple quotes (as in `\"\"\"abc\"\"\"`-style quoting).\nfunction handleSame(state, token, allowTriple) {\n    let dont = null, changes = state.changeByRange(range => {\n        if (!range.empty)\n            return { changes: [{ insert: token, from: range.from }, { insert: token, from: range.to }],\n                effects: closeBracketEffect.of(range.to + token.length),\n                range: EditorSelection.range(range.anchor + token.length, range.head + token.length) };\n        let pos = range.head, next = nextChar(state.doc, pos);\n        if (next == token) {\n            if (nodeStart(state, pos)) {\n                return { changes: { insert: token + token, from: pos },\n                    effects: closeBracketEffect.of(pos + token.length),\n                    range: EditorSelection.cursor(pos + token.length) };\n            }\n            else if (closedBracketAt(state, pos)) {\n                let isTriple = allowTriple && state.sliceDoc(pos, pos + token.length * 3) == token + token + token;\n                return { range: EditorSelection.cursor(pos + token.length * (isTriple ? 3 : 1)),\n                    effects: skipBracketEffect.of(pos) };\n            }\n        }\n        else if (allowTriple && state.sliceDoc(pos - 2 * token.length, pos) == token + token &&\n            nodeStart(state, pos - 2 * token.length)) {\n            return { changes: { insert: token + token + token + token, from: pos },\n                effects: closeBracketEffect.of(pos + token.length),\n                range: EditorSelection.cursor(pos + token.length) };\n        }\n        else if (state.charCategorizer(pos)(next) != CharCategory.Word) {\n            let prev = state.sliceDoc(pos - 1, pos);\n            if (prev != token && state.charCategorizer(pos)(prev) != CharCategory.Word)\n                return { changes: { insert: token + token, from: pos },\n                    effects: closeBracketEffect.of(pos + token.length),\n                    range: EditorSelection.cursor(pos + token.length) };\n        }\n        return { range: dont = range };\n    });\n    return dont ? null : state.update(changes, {\n        scrollIntoView: true,\n        annotations: Transaction.userEvent.of(\"input\")\n    });\n}\nfunction nodeStart(state, pos) {\n    let tree = syntaxTree(state).resolve(pos + 1);\n    return tree.parent && tree.from == pos;\n}\n\nexport { closeBrackets, closeBracketsKeymap, deleteBracketPair, handleInsertion };\n","import { Transaction, EditorSelection, CharCategory } from '@codemirror/next/state';\nimport { Text, findClusterBreak, countColumn, codePointSize, codePointAt } from '@codemirror/next/text';\nimport { Direction } from '@codemirror/next/view';\nimport { matchBrackets } from '@codemirror/next/matchbrackets';\nimport { IndentContext, getIndentation, indentString, indentUnit, getIndentUnit, syntaxTree } from '@codemirror/next/language';\nimport { NodeProp } from 'lezer-tree';\n\nfunction updateSel(sel, by) {\n    return EditorSelection.create(sel.ranges.map(by), sel.mainIndex);\n}\nfunction setSel(state, selection) {\n    return state.update({ selection, scrollIntoView: true, annotations: Transaction.userEvent.of(\"keyboardselection\") });\n}\nfunction moveSel({ state, dispatch }, how) {\n    let selection = updateSel(state.selection, how);\n    if (selection.eq(state.selection))\n        return false;\n    dispatch(setSel(state, selection));\n    return true;\n}\nfunction rangeEnd(range, forward) {\n    return EditorSelection.cursor(forward ? range.to : range.from);\n}\nfunction cursorByChar(view, forward) {\n    return moveSel(view, range => range.empty ? view.moveByChar(range, forward) : rangeEnd(range, forward));\n}\n/// Move the selection one character to the left (which is backward in\n/// left-to-right text, forward in right-to-left text).\nconst cursorCharLeft = view => cursorByChar(view, view.textDirection != Direction.LTR);\n/// Move the selection one character to the right.\nconst cursorCharRight = view => cursorByChar(view, view.textDirection == Direction.LTR);\n/// Move the selection one character forward.\nconst cursorCharForward = view => cursorByChar(view, true);\n/// Move the selection one character backward.\nconst cursorCharBackward = view => cursorByChar(view, false);\nfunction cursorByGroup(view, forward) {\n    return moveSel(view, range => range.empty ? view.moveByGroup(range, forward) : rangeEnd(range, forward));\n}\n/// Move the selection across one group of word or non-word (but also\n/// non-space) characters.\nconst cursorGroupLeft = view => cursorByGroup(view, view.textDirection != Direction.LTR);\n/// Move the selection one group to the right.\nconst cursorGroupRight = view => cursorByGroup(view, view.textDirection == Direction.LTR);\n/// Move the selection one group forward.\nconst cursorGroupForward = view => cursorByGroup(view, true);\n/// Move the selection one group backward.\nconst cursorGroupBackward = view => cursorByGroup(view, false);\nfunction interestingNode(state, node, bracketProp) {\n    if (node.type.prop(bracketProp))\n        return true;\n    let len = node.to - node.from;\n    return len && (len > 2 || /[^\\s,.;:]/.test(state.sliceDoc(node.from, node.to))) || node.firstChild;\n}\nfunction moveBySyntax(state, start, forward) {\n    let pos = syntaxTree(state).resolve(start.head);\n    let bracketProp = forward ? NodeProp.closedBy : NodeProp.openedBy;\n    // Scan forward through child nodes to see if there's an interesting\n    // node ahead.\n    for (let at = start.head;;) {\n        let next = forward ? pos.childAfter(at) : pos.childBefore(at);\n        if (!next)\n            break;\n        if (interestingNode(state, next, bracketProp))\n            pos = next;\n        else\n            at = forward ? next.to : next.from;\n    }\n    let bracket = pos.type.prop(bracketProp), match, newPos;\n    if (bracket && (match = forward ? matchBrackets(state, pos.from, 1) : matchBrackets(state, pos.to, -1)) && match.matched)\n        newPos = forward ? match.other.to : match.other.from;\n    else\n        newPos = forward ? pos.to : pos.from;\n    return EditorSelection.cursor(newPos, forward ? -1 : 1);\n}\n/// Move the cursor over the next syntactic element to the left.\nconst cursorSyntaxLeft = view => moveSel(view, range => moveBySyntax(view.state, range, view.textDirection != Direction.LTR));\n/// Move the cursor over the next syntactic element to the right.\nconst cursorSyntaxRight = view => moveSel(view, range => moveBySyntax(view.state, range, view.textDirection == Direction.LTR));\nfunction cursorByLine(view, forward) {\n    return moveSel(view, range => range.empty ? view.moveVertically(range, forward) : rangeEnd(range, forward));\n}\n/// Move the selection one line up.\nconst cursorLineUp = view => cursorByLine(view, false);\n/// Move the selection one line down.\nconst cursorLineDown = view => cursorByLine(view, true);\nfunction cursorByPage(view, forward) {\n    return moveSel(view, range => range.empty ? view.moveVertically(range, forward, view.dom.clientHeight) : rangeEnd(range, forward));\n}\n/// Move the selection one page up.\nconst cursorPageUp = view => cursorByPage(view, false);\n/// Move the selection one page down.\nconst cursorPageDown = view => cursorByPage(view, true);\nfunction moveByLineBoundary(view, start, forward) {\n    let line = view.visualLineAt(start.head), moved = view.moveToLineBoundary(start, forward);\n    if (moved.head == start.head && moved.head != (forward ? line.to : line.from))\n        moved = view.moveToLineBoundary(start, forward, false);\n    if (!forward && moved.head == line.from && line.length) {\n        let space = /^\\s*/.exec(view.state.sliceDoc(line.from, Math.min(line.from + 100, line.to)))[0].length;\n        if (space && start.head != line.from + space)\n            moved = EditorSelection.cursor(line.from + space);\n    }\n    return moved;\n}\n/// Move the selection to the next line wrap point, or to the end of\n/// the line if there isn't one left on this line.\nconst cursorLineBoundaryForward = view => moveSel(view, range => moveByLineBoundary(view, range, true));\n/// Move the selection to previous line wrap point, or failing that to\n/// the start of the line. If the line is indented, and the cursor\n/// isn't already at the end of the indentation, this will move to the\n/// end of the indentation instead of the start of the line.\nconst cursorLineBoundaryBackward = view => moveSel(view, range => moveByLineBoundary(view, range, false));\n/// Move the selection to the start of the line.\nconst cursorLineStart = view => moveSel(view, range => EditorSelection.cursor(view.visualLineAt(range.head).from, 1));\n/// Move the selection to the end of the line.\nconst cursorLineEnd = view => moveSel(view, range => EditorSelection.cursor(view.visualLineAt(range.head).to, -1));\nfunction toMatchingBracket(state, dispatch, extend) {\n    let found = false, selection = updateSel(state.selection, range => {\n        let matching = matchBrackets(state, range.head, -1)\n            || matchBrackets(state, range.head, 1)\n            || (range.head > 0 && matchBrackets(state, range.head - 1, 1))\n            || (range.head < state.doc.length && matchBrackets(state, range.head + 1, -1));\n        if (!matching || !matching.other)\n            return range;\n        found = true;\n        let head = matching.start.from == range.head ? matching.other.to : matching.other.from;\n        return extend ? EditorSelection.range(range.anchor, head) : EditorSelection.cursor(head);\n    });\n    if (!found)\n        return false;\n    dispatch(setSel(state, selection));\n    return true;\n}\n/// Move the selection to the bracket matching the one it is currently\n/// on, if any.\nconst cursorMatchingBracket = ({ state, dispatch }) => toMatchingBracket(state, dispatch, false);\n/// Extend the selection to the bracket matching the one the selection\n/// head is currently on, if any.\nconst selectMatchingBracket = ({ state, dispatch }) => toMatchingBracket(state, dispatch, true);\nfunction extendSel(view, how) {\n    let selection = updateSel(view.state.selection, range => {\n        let head = how(range);\n        return EditorSelection.range(range.anchor, head.head, head.goalColumn);\n    });\n    if (selection.eq(view.state.selection))\n        return false;\n    view.dispatch(setSel(view.state, selection));\n    return true;\n}\nfunction selectByChar(view, forward) {\n    return extendSel(view, range => view.moveByChar(range, forward));\n}\n/// Move the selection head one character to the left, while leaving\n/// the anchor in place.\nconst selectCharLeft = view => selectByChar(view, view.textDirection != Direction.LTR);\n/// Move the selection head one character to the right.\nconst selectCharRight = view => selectByChar(view, view.textDirection == Direction.LTR);\n/// Move the selection head one character forward.\nconst selectCharForward = view => selectByChar(view, true);\n/// Move the selection head one character backward.\nconst selectCharBackward = view => selectByChar(view, false);\nfunction selectByGroup(view, forward) {\n    return extendSel(view, range => view.moveByGroup(range, forward));\n}\n/// Move the selection head one [group](#commands.cursorGroupLeft) to\n/// the left.\nconst selectGroupLeft = view => selectByGroup(view, view.textDirection != Direction.LTR);\n/// Move the selection head one group to the right.\nconst selectGroupRight = view => selectByGroup(view, view.textDirection == Direction.LTR);\n/// Move the selection head one group forward.\nconst selectGroupForward = view => selectByGroup(view, true);\n/// Move the selection head one group backward.\nconst selectGroupBackward = view => selectByGroup(view, false);\n/// Move the selection head over the next syntactic element to the left.\nconst selectSyntaxLeft = view => extendSel(view, range => moveBySyntax(view.state, range, view.textDirection != Direction.LTR));\n/// Move the selection head over the next syntactic element to the right.\nconst selectSyntaxRight = view => extendSel(view, range => moveBySyntax(view.state, range, view.textDirection == Direction.LTR));\nfunction selectByLine(view, forward) {\n    return extendSel(view, range => view.moveVertically(range, forward));\n}\n/// Move the selection head one line up.\nconst selectLineUp = view => selectByLine(view, false);\n/// Move the selection head one line down.\nconst selectLineDown = view => selectByLine(view, true);\nfunction selectByPage(view, forward) {\n    return extendSel(view, range => view.moveVertically(range, forward, view.dom.clientHeight));\n}\n/// Move the selection head one page up.\nconst selectPageUp = view => selectByPage(view, false);\n/// Move the selection head one page down.\nconst selectPageDown = view => selectByPage(view, true);\n/// Move the selection head to the next line boundary.\nconst selectLineBoundaryForward = view => extendSel(view, range => moveByLineBoundary(view, range, true));\n/// Move the selection head to the previous line boundary.\nconst selectLineBoundaryBackward = view => extendSel(view, range => moveByLineBoundary(view, range, false));\n/// Move the selection head to the start of the line.\nconst selectLineStart = view => extendSel(view, range => EditorSelection.cursor(view.visualLineAt(range.head).from));\n/// Move the selection head to the end of the line.\nconst selectLineEnd = view => extendSel(view, range => EditorSelection.cursor(view.visualLineAt(range.head).to));\n/// Move the selection to the start of the document.\nconst cursorDocStart = ({ state, dispatch }) => {\n    dispatch(setSel(state, { anchor: 0 }));\n    return true;\n};\n/// Move the selection to the end of the document.\nconst cursorDocEnd = ({ state, dispatch }) => {\n    dispatch(setSel(state, { anchor: state.doc.length }));\n    return true;\n};\n/// Move the selection head to the start of the document.\nconst selectDocStart = ({ state, dispatch }) => {\n    dispatch(setSel(state, { anchor: state.selection.main.anchor, head: 0 }));\n    return true;\n};\n/// Move the selection head to the end of the document.\nconst selectDocEnd = ({ state, dispatch }) => {\n    dispatch(setSel(state, { anchor: state.selection.main.anchor, head: state.doc.length }));\n    return true;\n};\n/// Select the entire document.\nconst selectAll = ({ state, dispatch }) => {\n    dispatch(state.update({ selection: { anchor: 0, head: state.doc.length }, annotations: Transaction.userEvent.of(\"keyboardselection\") }));\n    return true;\n};\n/// Expand the selection to cover entire lines.\nconst selectLine = ({ state, dispatch }) => {\n    let ranges = selectedLineBlocks(state).map(({ from, to }) => EditorSelection.range(from, Math.min(to + 1, state.doc.length)));\n    dispatch(state.update({ selection: new EditorSelection(ranges), annotations: Transaction.userEvent.of(\"keyboardselection\") }));\n    return true;\n};\n/// Select the next syntactic construct that is larger than the\n/// selection. Note that this will only work insofar as the language\n/// [provider](#language.language) you use builds up a full\n/// syntax tree.\nconst selectParentSyntax = ({ state, dispatch }) => {\n    let selection = updateSel(state.selection, range => {\n        var _a;\n        let context = syntaxTree(state).resolve(range.head, 1);\n        while (!((context.from < range.from && context.to >= range.to) ||\n            (context.to > range.to && context.from <= range.from) ||\n            !((_a = context.parent) === null || _a === void 0 ? void 0 : _a.parent)))\n            context = context.parent;\n        return EditorSelection.range(context.to, context.from);\n    });\n    dispatch(setSel(state, selection));\n    return true;\n};\n/// Simplify the current selection. When multiple ranges are selected,\n/// reduce it to its main range. Otherwise, if the selection is\n/// non-empty, convert it to a cursor selection.\nconst simplifySelection = ({ state, dispatch }) => {\n    let cur = state.selection, selection = null;\n    if (cur.ranges.length > 1)\n        selection = new EditorSelection([cur.main]);\n    else if (!cur.main.empty)\n        selection = new EditorSelection([EditorSelection.cursor(cur.main.head)]);\n    if (!selection)\n        return false;\n    dispatch(setSel(state, selection));\n    return true;\n};\nfunction deleteBy(view, by) {\n    let { state } = view, changes = state.changeByRange(range => {\n        let { from, to } = range;\n        if (from == to) {\n            let towards = by(from);\n            from = Math.min(from, towards);\n            to = Math.max(to, towards);\n        }\n        return from == to ? { range } : { changes: { from, to }, range: EditorSelection.cursor(from) };\n    });\n    if (changes.changes.empty)\n        return false;\n    view.dispatch(changes, { scrollIntoView: true, annotations: Transaction.userEvent.of(\"delete\") });\n    return true;\n}\nconst deleteByChar = (view, forward, codePoint) => deleteBy(view, pos => {\n    let { state } = view, line = state.doc.lineAt(pos), before;\n    if (!forward && pos > line.from && pos < line.from + 200 &&\n        !/[^ \\t]/.test(before = line.text.slice(0, pos - line.from))) {\n        if (before[before.length - 1] == \"\\t\")\n            return pos - 1;\n        let col = countColumn(before, 0, state.tabSize), drop = col % getIndentUnit(state) || getIndentUnit(state);\n        for (let i = 0; i < drop && before[before.length - 1 - i] == \" \"; i++)\n            pos--;\n        return pos;\n    }\n    let target;\n    if (codePoint) {\n        let next = line.text.slice(pos - line.from + (forward ? 0 : -2), pos - line.from + (forward ? 2 : 0));\n        let size = next ? codePointSize(codePointAt(next, 0)) : 1;\n        target = forward ? Math.min(state.doc.length, pos + size) : Math.max(0, pos - size);\n    }\n    else {\n        target = findClusterBreak(line.text, pos - line.from, forward) + line.from;\n    }\n    if (target == pos && line.number != (forward ? state.doc.lines : 1))\n        target += forward ? 1 : -1;\n    return target;\n});\n/// Delete the selection, or, for cursor selections, the code point\n/// before the cursor.\nconst deleteCodePointBackward = view => deleteByChar(view, false, true);\n/// Delete the selection, or, for cursor selections, the code point\n/// after the cursor.\nconst deleteCodePointForward = view => deleteByChar(view, true, true);\n/// Delete the selection, or, for cursor selections, the character\n/// before the cursor.\nconst deleteCharBackward = view => deleteByChar(view, false, false);\n/// Delete the selection or the character after the cursor.\nconst deleteCharForward = view => deleteByChar(view, true, false);\nconst deleteByGroup = (view, forward) => deleteBy(view, pos => {\n    let { state } = view, line = state.doc.lineAt(pos), categorize = state.charCategorizer(pos);\n    for (let cat = null;;) {\n        let next, nextChar;\n        if (pos == (forward ? line.to : line.from)) {\n            if (line.number == (forward ? state.doc.lines : 1))\n                break;\n            line = state.doc.line(line.number + (forward ? 1 : -1));\n            next = forward ? line.from : line.to;\n            nextChar = \"\\n\";\n        }\n        else {\n            next = findClusterBreak(line.text, pos - line.from, forward) + line.from;\n            nextChar = line.text.slice(Math.min(pos, next) - line.from, Math.max(pos, next) - line.from);\n        }\n        let nextCat = categorize(nextChar);\n        if (cat != null && nextCat != cat)\n            break;\n        if (nextCat != CharCategory.Space)\n            cat = nextCat;\n        pos = next;\n    }\n    return pos;\n});\n/// Delete the selection or backward until the end of the next\n/// [group](#view.EditorView.moveByGroup).\nconst deleteGroupBackward = view => deleteByGroup(view, false);\n/// Delete the selection or forward until the end of the next group.\nconst deleteGroupForward = view => deleteByGroup(view, true);\n/// Delete the selection, or, if it is a cursor selection, delete to\n/// the end of the line. If the cursor is directly at the end of the\n/// line, delete the line break after it.\nconst deleteToLineEnd = view => deleteBy(view, pos => {\n    let lineEnd = view.visualLineAt(pos).to;\n    if (pos < lineEnd)\n        return lineEnd;\n    return Math.max(view.state.doc.length, pos + 1);\n});\n/// Delete all whitespace directly before a line end from the\n/// document.\nconst deleteTrailingWhitespace = ({ state, dispatch }) => {\n    let changes = [];\n    for (let pos = 0, prev = \"\", iter = state.doc.iter();;) {\n        iter.next();\n        if (iter.lineBreak || iter.done) {\n            let trailing = prev.search(/\\s+$/);\n            if (trailing > -1)\n                changes.push({ from: pos - (prev.length - trailing), to: pos });\n            if (iter.done)\n                break;\n            prev = \"\";\n        }\n        else {\n            prev = iter.value;\n        }\n        pos += iter.value.length;\n    }\n    if (!changes.length)\n        return false;\n    dispatch(state.update({ changes }));\n    return true;\n};\n/// Replace each selection range with a line break, leaving the cursor\n/// on the line before the break.\nconst splitLine = ({ state, dispatch }) => {\n    let changes = state.changeByRange(range => {\n        return { changes: { from: range.from, to: range.to, insert: Text.of([\"\", \"\"]) },\n            range: EditorSelection.cursor(range.from) };\n    });\n    dispatch(state.update(changes, { scrollIntoView: true, annotations: Transaction.userEvent.of(\"input\") }));\n    return true;\n};\n/// Flip the characters before and after the cursor(s).\nconst transposeChars = ({ state, dispatch }) => {\n    let changes = state.changeByRange(range => {\n        if (!range.empty || range.from == 0 || range.from == state.doc.length)\n            return { range };\n        let pos = range.from, line = state.doc.lineAt(pos);\n        let from = pos == line.from ? pos - 1 : findClusterBreak(line.text, pos - line.from, false) + line.from;\n        let to = pos == line.to ? pos + 1 : findClusterBreak(line.text, pos - line.from, true) + line.from;\n        return { changes: { from, to, insert: state.doc.slice(pos, to).append(state.doc.slice(from, pos)) },\n            range: EditorSelection.cursor(to) };\n    });\n    if (changes.changes.empty)\n        return false;\n    dispatch(state.update(changes, { scrollIntoView: true }));\n    return true;\n};\nfunction selectedLineBlocks(state) {\n    let blocks = [], upto = -1;\n    for (let range of state.selection.ranges) {\n        let startLine = state.doc.lineAt(range.from), endLine = state.doc.lineAt(range.to);\n        if (upto == startLine.number)\n            blocks[blocks.length - 1].to = endLine.to;\n        else\n            blocks.push({ from: startLine.from, to: endLine.to });\n        upto = endLine.number;\n    }\n    return blocks;\n}\nfunction moveLine(state, dispatch, forward) {\n    let changes = [];\n    for (let block of selectedLineBlocks(state)) {\n        if (forward ? block.to == state.doc.length : block.from == 0)\n            continue;\n        let nextLine = state.doc.lineAt(forward ? block.to + 1 : block.from - 1);\n        if (forward)\n            changes.push({ from: block.to, to: nextLine.to }, { from: block.from, insert: nextLine.text + state.lineBreak });\n        else\n            changes.push({ from: nextLine.from, to: block.from }, { from: block.to, insert: state.lineBreak + nextLine.text });\n    }\n    if (!changes.length)\n        return false;\n    dispatch(state.update({ changes, scrollIntoView: true }));\n    return true;\n}\n/// Move the selected lines up one line.\nconst moveLineUp = ({ state, dispatch }) => moveLine(state, dispatch, false);\n/// Move the selected lines down one line.\nconst moveLineDown = ({ state, dispatch }) => moveLine(state, dispatch, true);\nfunction copyLine(state, dispatch, forward) {\n    let changes = [];\n    for (let block of selectedLineBlocks(state)) {\n        if (forward)\n            changes.push({ from: block.from, insert: state.doc.slice(block.from, block.to) + state.lineBreak });\n        else\n            changes.push({ from: block.to, insert: state.lineBreak + state.doc.slice(block.from, block.to) });\n    }\n    dispatch(state.update({ changes, scrollIntoView: true }));\n    return true;\n}\n/// Create a copy of the selected lines. Keep the selection in the top copy.\nconst copyLineUp = ({ state, dispatch }) => copyLine(state, dispatch, false);\n/// Create a copy of the selected lines. Keep the selection in the bottom copy.\nconst copyLineDown = ({ state, dispatch }) => copyLine(state, dispatch, true);\n/// Delete selected lines.\nconst deleteLine = view => {\n    let { state } = view, changes = state.changes(selectedLineBlocks(state).map(({ from, to }) => {\n        if (from > 0)\n            from--;\n        else if (to < state.doc.length)\n            to++;\n        return { from, to };\n    }));\n    let selection = updateSel(state.selection, range => view.moveVertically(range, true)).map(changes);\n    view.dispatch({ changes, selection, scrollIntoView: true });\n    return true;\n};\n/// Replace the selection with a newline.\nconst insertNewline = ({ state, dispatch }) => {\n    dispatch(state.update(state.replaceSelection(state.lineBreak), { scrollIntoView: true }));\n    return true;\n};\nfunction isBetweenBrackets(state, pos) {\n    if (/\\(\\)|\\[\\]|\\{\\}/.test(state.sliceDoc(pos - 1, pos + 1)))\n        return { from: pos, to: pos };\n    let context = syntaxTree(state).resolve(pos);\n    let before = context.childBefore(pos), after = context.childAfter(pos), closedBy;\n    if (before && after && before.to <= pos && after.from >= pos &&\n        (closedBy = before.type.prop(NodeProp.closedBy)) && closedBy.indexOf(after.name) > -1)\n        return { from: before.to, to: after.from };\n    return null;\n}\n/// Replace the selection with a newline and indent the newly created\n/// line(s). If the current line consists only of whitespace, this\n/// will also delete that whitespace. When the cursor is between\n/// matching brackets, an additional newline will be inserted after\n/// the cursor.\nconst insertNewlineAndIndent = ({ state, dispatch }) => {\n    let changes = state.changeByRange(({ from, to }) => {\n        let explode = from == to && isBetweenBrackets(state, from);\n        let cx = new IndentContext(state, { simulateBreak: from, simulateDoubleBreak: !!explode });\n        let indent = getIndentation(cx, from);\n        if (indent == null)\n            indent = /^\\s*/.exec(state.doc.lineAt(from).text)[0].length;\n        let line = state.doc.lineAt(from);\n        while (to < line.to && /\\s/.test(line.text.slice(to - line.from, to + 1 - line.from)))\n            to++;\n        if (explode)\n            ({ from, to } = explode);\n        else if (from > line.from && from < line.from + 100 && !/\\S/.test(line.text.slice(0, from)))\n            from = line.from;\n        let insert = [\"\", indentString(state, indent)];\n        if (explode)\n            insert.push(indentString(state, cx.lineIndent(line)));\n        return { changes: { from, to, insert: Text.of(insert) },\n            range: EditorSelection.cursor(from + 1 + insert[1].length) };\n    });\n    dispatch(state.update(changes, { scrollIntoView: true }));\n    return true;\n};\nfunction changeBySelectedLine(state, f) {\n    let atLine = -1;\n    return state.changeByRange(range => {\n        let changes = [];\n        for (let line = state.doc.lineAt(range.from);;) {\n            if (line.number > atLine) {\n                f(line, changes, range);\n                atLine = line.number;\n            }\n            if (range.to <= line.to)\n                break;\n            line = state.doc.lineAt(line.to + 1);\n        }\n        let changeSet = state.changes(changes);\n        return { changes,\n            range: EditorSelection.range(changeSet.mapPos(range.anchor, 1), changeSet.mapPos(range.head, 1)) };\n    });\n}\n/// Auto-indent the selected lines. This uses the [indentation service\n/// facet](#language.indentService) as source for auto-indent\n/// information.\nconst indentSelection = ({ state, dispatch }) => {\n    let updated = Object.create(null);\n    let context = new IndentContext(state, { overrideIndentation: start => {\n            let found = updated[start];\n            return found == null ? -1 : found;\n        } });\n    let changes = changeBySelectedLine(state, (line, changes, range) => {\n        let indent = getIndentation(context, line.from);\n        if (indent == null)\n            return;\n        let cur = /^\\s*/.exec(line.text)[0];\n        let norm = indentString(state, indent);\n        if (cur != norm || range.from < line.from + cur.length) {\n            updated[line.from] = indent;\n            changes.push({ from: line.from, to: line.from + cur.length, insert: norm });\n        }\n    });\n    if (!changes.changes.empty)\n        dispatch(state.update(changes));\n    return true;\n};\n/// Add a [unit](#language.indentUnit) of indentation to all selected\n/// lines.\nconst indentMore = ({ state, dispatch }) => {\n    dispatch(state.update(changeBySelectedLine(state, (line, changes) => {\n        changes.push({ from: line.from, insert: state.facet(indentUnit) });\n    })));\n    return true;\n};\n/// Remove a [unit](#language.indentUnit) of indentation from all\n/// selected lines.\nconst indentLess = ({ state, dispatch }) => {\n    dispatch(state.update(changeBySelectedLine(state, (line, changes) => {\n        let space = /^\\s*/.exec(line.text)[0];\n        if (!space)\n            return;\n        let col = countColumn(space, 0, state.tabSize), keep = 0;\n        let insert = indentString(state, Math.max(0, col - getIndentUnit(state)));\n        while (keep < space.length && keep < insert.length && space.charCodeAt(keep) == insert.charCodeAt(keep))\n            keep++;\n        changes.push({ from: line.from + keep, to: line.from + space.length, insert: insert.slice(keep) });\n    })));\n    return true;\n};\n/// Array of key bindings containing the Emacs-style bindings that are\n/// available on macOS by default.\n///\n///  - Ctrl-b: [`cursorCharLeft`](#commands.cursorCharLeft) ([`selectCharLeft`](#commands.selectCharLeft) with Shift)\n///  - Ctrl-f: [`cursorCharRight`](#commands.cursorCharRight) ([`selectCharRight`](#commands.selectCharRight) with Shift)\n///  - Ctrl-p: [`cursorLineUp`](#commands.cursorLineUp) ([`selectLineUp`](#commands.selectLineUp) with Shift)\n///  - Ctrl-n: [`cursorLineDown`](#commands.cursorLineDown) ([`selectLineDown`](#commands.selectLineDown) with Shift)\n///  - Ctrl-a: [`cursorLineStart`](#commands.cursorLineStart) ([`selectLineStart`](#commands.selectLineStart) with Shift)\n///  - Ctrl-e: [`cursorLineEnd`](#commands.cursorLineEnd) ([`selectLineEnd`](#commands.selectLineEnd) with Shift)\n///  - Ctrl-d: [`deleteCharForward`](#commands.deleteCharForward)\n///  - Ctrl-h: [`deleteCharBackward`](#commands.deleteCharBackward)\n///  - Ctrl-k: [`deleteToLineEnd`](#commands.deleteToLineEnd)\n///  - Alt-d: [`deleteGroupForward`](#commands.deleteGroupForward)\n///  - Ctrl-Alt-h: [`deleteGroupBackward`](#commands.deleteGroupBackward)\n///  - Ctrl-o: [`splitLine`](#commands.splitLine)\n///  - Ctrl-t: [`transposeChars`](#commands.transposeChars)\n///  - Alt-f: [`cursorGroupForward`](#commands.cursorGroupForward) ([`selectGroupForward`](#commands.selectGroupForward) with Shift)\n///  - Alt-b: [`cursorGroupBackward`](#commands.cursorGroupBackward) ([`selectGroupBackward`](#commands.selectGroupBackward) with Shift)\n///  - Alt-<: [`cursorDocStart`](#commands.cursorDocStart)\n///  - Alt->: [`cursorDocEnd`](#commands.cursorDocEnd)\n///  - Ctrl-v: [`cursorPageDown`](#commands.cursorPageDown)\n///  - Alt-v: [`cursorPageUp`](#commands.cursorPageUp)\nconst emacsStyleKeymap = [\n    { key: \"Ctrl-b\", run: cursorCharLeft, shift: selectCharLeft },\n    { key: \"Ctrl-f\", run: cursorCharRight, shift: selectCharRight },\n    { key: \"Ctrl-p\", run: cursorLineUp, shift: selectLineUp },\n    { key: \"Ctrl-n\", run: cursorLineDown, shift: selectLineDown },\n    { key: \"Ctrl-a\", run: cursorLineStart, shift: selectLineStart },\n    { key: \"Ctrl-e\", run: cursorLineEnd, shift: selectLineEnd },\n    { key: \"Ctrl-d\", run: deleteCharForward },\n    { key: \"Ctrl-h\", run: deleteCharBackward },\n    { key: \"Ctrl-k\", run: deleteToLineEnd },\n    { key: \"Alt-d\", run: deleteGroupForward },\n    { key: \"Ctrl-Alt-h\", run: deleteGroupBackward },\n    { key: \"Ctrl-o\", run: splitLine },\n    { key: \"Ctrl-t\", run: transposeChars },\n    { key: \"Alt-f\", run: cursorGroupForward, shift: selectGroupForward },\n    { key: \"Alt-b\", run: cursorGroupBackward, shift: selectGroupBackward },\n    { key: \"Alt-<\", run: cursorDocStart },\n    { key: \"Alt->\", run: cursorDocEnd },\n    { key: \"Ctrl-v\", run: cursorPageDown },\n    { key: \"Alt-v\", run: cursorPageUp },\n];\n/// An array of key bindings closely sticking to platform-standard or\n/// widely used bindings. (This includes the bindings from\n/// [`emacsStyleKeymap`](#commands.emacsStyleKeymap), with their `key`\n/// property changed to `mac`.)\n///\n///  - ArrowLeft: [`cursorCharLeft`](#commands.cursorCharLeft) ([`selectCharLeft`](#commands.selectCharLeft) with Shift)\n///  - ArrowRight: [`cursorCharRight`](#commands.cursorCharRight) ([`selectCharRight`](#commands.selectCharRight) with Shift)\n///  - Ctrl-ArrowLeft (Alt-ArrowLeft on macOS): [`cursorGroupLeft`](#commands.cursorGroupLeft) ([`selectGroupLeft`](#commands.selectGroupLeft) with Shift)\n///  - Ctrl-ArrowRight (Alt-ArrowRight on macOS): [`cursorGroupRight`](#commands.cursorGroupRight) ([`selectGroupRight`](#commands.selectGroupRight) with Shift)\n///  - Cmd-ArrowLeft (on macOS): [`cursorLineStart`](#commands.cursorLineStart) ([`selectLineStart`](#commands.selectLineStart) with Shift)\n///  - Cmd-ArrowRight (on macOS): [`cursorLineEnd`](#commands.cursorLineEnd) ([`selectLineEnd`](#commands.selectLineEnd) with Shift)\n///  - ArrowUp: [`cursorLineUp`](#commands.cursorLineUp) ([`selectLineUp`](#commands.selectLineUp) with Shift)\n///  - ArrowDown: [`cursorLineDown`](#commands.cursorLineDown) ([`selectLineDown`](#commands.selectLineDown) with Shift)\n///  - Cmd-ArrowUp (on macOS): [`cursorDocStart`](#commands.cursorDocStart) ([`selectDocStart`](#commands.selectDocStart) with Shift)\n///  - Cmd-ArrowDown (on macOS): [`cursorDocEnd`](#commands.cursorDocEnd) ([`selectDocEnd`](#commands.selectDocEnd) with Shift)\n///  - Ctrl-ArrowUp (on macOS): [`cursorPageUp`](#commands.cursorPageUp) ([`selectPageUp`](#commands.selectPageUp) with Shift)\n///  - Ctrl-ArrowDown (on macOS): [`cursorPageDown`](#commands.cursorPageDown) ([`selectPageDown`](#commands.selectPageDown) with Shift)\n///  - PageUp: [`cursorPageUp`](#commands.cursorPageUp) ([`selectPageUp`](#commands.selectPageUp) with Shift)\n///  - PageDown: [`cursorPageDown`](#commands.cursorPageDown) ([`selectPageDown`](#commands.selectPageDown) with Shift)\n///  - Home: [`cursorLineBoundaryBackward`](#commands.cursorLineBoundaryBackward) ([`selectLineBoundaryBackward`](#commands.selectLineBoundaryBackward) with Shift)\n///  - End: [`cursorLineBoundaryForward`](#commands.cursorLineBoundaryForward) ([`selectLineBoundaryForward`](#commands.selectLineBoundaryForward) with Shift)\n///  - Ctrl-Home (Cmd-Home on macOS): [`cursorDocStart`](#commands.cursorDocStart) ([`selectDocStart`](#commands.selectDocStart) with Shift)\n///  - Ctrl-End (Cmd-Home on macOS): [`cursorDocEnd`](#commands.cursorDocEnd) ([`selectDocEnd`](#commands.selectDocEnd) with Shift)\n///  - Enter: [`insertNewlineAndIndent`](#commands.insertNewlineAndIndent)\n///  - Ctrl-a (Cmd-a on macOS): [`selectAll`](#commands.selectAll)\n///  - Backspace: [`deleteCodePointBackward`](#commands.deleteCodePointBackward)\n///  - Delete: [`deleteCharForward`](#commands.deleteCharForward)\n///  - Ctrl-Backspace (Alt-Backspace on macOS): [`deleteGroupBackward`](#commands.deleteGroupBackward)\n///  - Ctrl-Delete (Alt-Delete on macOS): [`deleteGroupForward`](#commands.deleteGroupForward)\nconst standardKeymap = [\n    { key: \"ArrowLeft\", run: cursorCharLeft, shift: selectCharLeft },\n    { key: \"Mod-ArrowLeft\", mac: \"Alt-ArrowLeft\", run: cursorGroupLeft, shift: selectGroupLeft },\n    { mac: \"Cmd-ArrowLeft\", run: cursorLineStart, shift: selectLineStart },\n    { key: \"ArrowRight\", run: cursorCharRight, shift: selectCharRight },\n    { key: \"Mod-ArrowRight\", mac: \"Alt-ArrowRight\", run: cursorGroupRight, shift: selectGroupRight },\n    { mac: \"Cmd-ArrowRight\", run: cursorLineEnd, shift: selectLineEnd },\n    { key: \"ArrowUp\", run: cursorLineUp, shift: selectLineUp },\n    { mac: \"Cmd-ArrowUp\", run: cursorDocStart, shift: selectDocStart },\n    { mac: \"Ctrl-ArrowUp\", run: cursorPageUp, shift: selectPageUp },\n    { key: \"ArrowDown\", run: cursorLineDown, shift: selectLineDown },\n    { mac: \"Cmd-ArrowDown\", run: cursorDocEnd, shift: selectDocEnd },\n    { mac: \"Ctrl-ArrowDown\", run: cursorPageDown, shift: selectPageDown },\n    { key: \"PageUp\", run: cursorPageUp, shift: selectPageUp },\n    { key: \"PageDown\", run: cursorPageDown, shift: selectPageDown },\n    { key: \"Home\", run: cursorLineBoundaryBackward, shift: selectLineBoundaryBackward },\n    { key: \"Mod-Home\", run: cursorDocStart, shift: selectDocStart },\n    { key: \"End\", run: cursorLineBoundaryForward, shift: selectLineBoundaryForward },\n    { key: \"Mod-End\", run: cursorDocEnd, shift: selectDocEnd },\n    { key: \"Enter\", run: insertNewlineAndIndent },\n    { key: \"Mod-a\", run: selectAll },\n    { key: \"Backspace\", run: deleteCodePointBackward },\n    { key: \"Delete\", run: deleteCharForward },\n    { key: \"Mod-Backspace\", mac: \"Alt-Backspace\", run: deleteGroupBackward },\n    { key: \"Mod-Delete\", mac: \"Alt-Delete\", run: deleteGroupForward },\n].concat(emacsStyleKeymap.map(b => ({ mac: b.key, run: b.run, shift: b.shift })));\n/// The default keymap. Includes all bindings from\n/// [`standardKeymap`](#commands.standardKeymap) plus the following:\n///\n/// - Alt-ArrowLeft (Ctrl-ArrowLeft on macOS): [`cursorSyntaxLeft`](#commands.cursorSyntaxLeft) ([`selectSyntaxLeft`](#commands.selectSyntaxLeft) with Shift)\n/// - Alt-ArrowRight (Ctrl-ArrowRight on macOS): [`cursorSyntaxRight`](#commands.cursorSyntaxRight) ([`selectSyntaxRight`](#commands.selectSyntaxRight) with Shift)\n/// - Alt-ArrowUp: [`moveLineUp`](#commands.moveLineUp)\n/// - Alt-ArrowDown: [`moveLineDown`](#commands.moveLineDown)\n/// - Shift-Alt-ArrowUp: [`copyLineUp`](#commands.copyLineUp)\n/// - Shift-Alt-ArrowDown: [`copyLineDown`](#commands.copyLineDown)\n/// - Escape: [`simplifySelection`](#commands.simplifySelection)\n/// - Ctrl-l (Cmd-l on macOS): [`selectLine`](#commands.selectLine)\n/// - Ctrl-i (Cmd-i on macOS): [`selectParentSyntax`](#commands.selectParentSyntax)\n/// - Ctrl-[ (Cmd-[ on macOS): [`indentLess`](#commands.indentLess)\n/// - Ctrl-] (Cmd-] on macOS): [`indentMore`](#commands.indentMore)\n/// - Ctrl-Alt-\\\\ (Cmd-Alt-\\\\ on macOS): [`indentSelection`](#commands.indentSelection)\n/// - Shift-Ctrl-k (Shift-Cmd-k on macOS): [`deleteLine`](#commands.deleteLine)\n/// - Shift-Ctrl-\\\\ (Shift-Cmd-\\\\ on macOS): [`cursorMatchingBracket`](#commands.cursorMatchingBracket)\nconst defaultKeymap = [\n    { key: \"Alt-ArrowLeft\", mac: \"Ctrl-ArrowLeft\", run: cursorSyntaxLeft, shift: selectSyntaxLeft },\n    { key: \"Alt-ArrowRight\", mac: \"Ctrl-ArrowRight\", run: cursorSyntaxRight, shift: selectSyntaxRight },\n    { key: \"Alt-ArrowUp\", run: moveLineUp },\n    { key: \"Shift-Alt-ArrowUp\", run: copyLineUp },\n    { key: \"Alt-ArrowDown\", run: moveLineDown },\n    { key: \"Shift-Alt-ArrowDown\", run: copyLineDown },\n    { key: \"Escape\", run: simplifySelection },\n    { key: \"Mod-l\", run: selectLine },\n    { key: \"Mod-i\", run: selectParentSyntax },\n    { key: \"Mod-[\", run: indentLess },\n    { key: \"Mod-]\", run: indentMore },\n    { key: \"Mod-Alt-\\\\\", run: indentSelection },\n    { key: \"Shift-Mod-k\", run: deleteLine },\n    { key: \"Shift-Mod-\\\\\", run: cursorMatchingBracket }\n].concat(standardKeymap);\n\nexport { copyLineDown, copyLineUp, cursorCharBackward, cursorCharForward, cursorCharLeft, cursorCharRight, cursorDocEnd, cursorDocStart, cursorGroupBackward, cursorGroupForward, cursorGroupLeft, cursorGroupRight, cursorLineBoundaryBackward, cursorLineBoundaryForward, cursorLineDown, cursorLineEnd, cursorLineStart, cursorLineUp, cursorMatchingBracket, cursorPageDown, cursorPageUp, cursorSyntaxLeft, cursorSyntaxRight, defaultKeymap, deleteCharBackward, deleteCharForward, deleteCodePointBackward, deleteCodePointForward, deleteGroupBackward, deleteGroupForward, deleteLine, deleteToLineEnd, deleteTrailingWhitespace, emacsStyleKeymap, indentLess, indentMore, indentSelection, insertNewline, insertNewlineAndIndent, moveLineDown, moveLineUp, selectAll, selectCharBackward, selectCharForward, selectCharLeft, selectCharRight, selectDocEnd, selectDocStart, selectGroupBackward, selectGroupForward, selectGroupLeft, selectGroupRight, selectLine, selectLineBoundaryBackward, selectLineBoundaryForward, selectLineDown, selectLineEnd, selectLineStart, selectLineUp, selectMatchingBracket, selectPageDown, selectPageUp, selectParentSyntax, selectSyntaxLeft, selectSyntaxRight, simplifySelection, splitLine, standardKeymap, transposeChars };\n","import { EditorSelection } from '@codemirror/next/state';\n\n/// Comment or uncomment the current selection. Will use line comments\n/// if available, otherwise falling back to block comments.\nconst toggleComment = target => {\n    let config = getConfig(target.state);\n    return config.line ? toggleLineComment(target) : config.block ? toggleBlockComment(target) : false;\n};\nfunction command(f, option) {\n    return ({ state, dispatch }) => {\n        let tr = f(option, state.selection.ranges, state);\n        if (!tr)\n            return false;\n        dispatch(state.update(tr));\n        return true;\n    };\n}\n/// Comment or uncomment the current selection using line comments.\n/// The line comment syntax is taken from the\n/// [`commentTokens`](#comment.CommentTokens) [language\n/// data](#state.EditorState.languageDataAt).\nconst toggleLineComment = command(changeLineComment, 0 /* Toggle */);\n/// Comment the current selection using line comments.\nconst lineComment = command(changeLineComment, 1 /* Comment */);\n/// Uncomment the current selection using line comments.\nconst lineUncomment = command(changeLineComment, 2 /* Uncomment */);\n/// Comment or uncomment the current selection using block comments.\n/// The block comment syntax is taken from the\n/// [`commentTokens`](#comment.CommentTokens) [language\n/// data](#state.EditorState.languageDataAt).\nconst toggleBlockComment = command(changeBlockComment, 0 /* Toggle */);\n/// Comment the current selection using block comments.\nconst blockComment = command(changeBlockComment, 1 /* Comment */);\n/// Uncomment the current selection using block comments.\nconst blockUncomment = command(changeBlockComment, 2 /* Uncomment */);\n/// Default key bindings for this package.\n///\n///  - Ctrl-/ (Cmd-/ on macOS): [`toggleComment`](#comment.toggleComment).\n///  - Shift-Alt-a: [`toggleBlockComment`](#comment.toggleBlockComment).\nconst commentKeymap = [\n    { key: \"Mod-/\", run: toggleComment },\n    { key: \"Alt-A\", run: toggleBlockComment }\n];\nfunction getConfig(state, pos = state.selection.main.head) {\n    let data = state.languageDataAt(\"commentTokens\", pos);\n    return data.length ? data[0] : {};\n}\nconst SearchMargin = 50;\n/// Determines if the given range is block-commented in the given\n/// state.\nfunction findBlockComment(state, { open, close }, from, to) {\n    let textBefore = state.sliceDoc(from - SearchMargin, from);\n    let textAfter = state.sliceDoc(to, to + SearchMargin);\n    let spaceBefore = /\\s*$/.exec(textBefore)[0].length, spaceAfter = /^\\s*/.exec(textAfter)[0].length;\n    let beforeOff = textBefore.length - spaceBefore;\n    if (textBefore.slice(beforeOff - open.length, beforeOff) == open &&\n        textAfter.slice(spaceAfter, spaceAfter + close.length) == close) {\n        return { open: { pos: from - spaceBefore, margin: spaceBefore && 1 },\n            close: { pos: to + spaceAfter, margin: spaceAfter && 1 } };\n    }\n    let startText, endText;\n    if (to - from <= 2 * SearchMargin) {\n        startText = endText = state.sliceDoc(from, to);\n    }\n    else {\n        startText = state.sliceDoc(from, from + SearchMargin);\n        endText = state.sliceDoc(to - SearchMargin, to);\n    }\n    let startSpace = /^\\s*/.exec(startText)[0].length, endSpace = /\\s*$/.exec(endText)[0].length;\n    let endOff = endText.length - endSpace - close.length;\n    if (startText.slice(startSpace, startSpace + open.length) == open &&\n        endText.slice(endOff, endOff + close.length) == close) {\n        return { open: { pos: from + startSpace + open.length,\n                margin: /\\s/.test(startText.charAt(startSpace + open.length)) ? 1 : 0 },\n            close: { pos: to - endSpace - close.length,\n                margin: /\\s/.test(endText.charAt(endOff - 1)) ? 1 : 0 } };\n    }\n    return null;\n}\n// Performs toggle, comment and uncomment of block comments in\n// languages that support them.\nfunction changeBlockComment(option, ranges, state) {\n    let tokens = ranges.map(r => getConfig(state, r.from).block);\n    if (!tokens.every(c => c))\n        return null;\n    let comments = ranges.map((r, i) => findBlockComment(state, tokens[i], r.from, r.to));\n    if (option != 2 /* Uncomment */ && !comments.every(c => c)) {\n        let index = 0;\n        return state.changeByRange(range => {\n            let { open, close } = tokens[index++];\n            if (comments[index])\n                return { range };\n            let shift = open.length + 1;\n            return {\n                changes: [{ from: range.from, insert: open + \" \" }, { from: range.to, insert: \" \" + close }],\n                range: EditorSelection.range(range.anchor + shift, range.head + shift)\n            };\n        });\n    }\n    else if (option != 1 /* Comment */ && comments.some(c => c)) {\n        let changes = [];\n        for (let i = 0, comment; i < comments.length; i++)\n            if (comment = comments[i]) {\n                let token = tokens[i], { open, close } = comment;\n                changes.push({ from: open.pos - token.open.length, to: open.pos + open.margin }, { from: close.pos - close.margin, to: close.pos + token.close.length });\n            }\n        return { changes };\n    }\n    return null;\n}\nfunction findLineComment(token, lines) {\n    let minCol = 1e9, commented = null, skipped = [];\n    for (let i = 0; i < lines.length; i++) {\n        let line = lines[i], col = /^\\s*/.exec(line.text)[0].length;\n        let empty = skipped[line.number] = col == line.length;\n        if (col < minCol && (!empty || minCol == 1e9 && i == lines.length - 1))\n            minCol = col;\n        if (commented != false && (!empty || commented == null && i == lines.length - 1))\n            commented = line.text.slice(col, col + token.length) == token;\n    }\n    return { minCol, commented: commented, skipped };\n}\n// Performs toggle, comment and uncomment of line comments.\nfunction changeLineComment(option, ranges, state) {\n    let lines = [], tokens = [], lineRanges = [];\n    for (let { from, to } of ranges) {\n        let token = getConfig(state, from).line;\n        if (!token)\n            return null;\n        tokens.push(token);\n        let lns = getLinesInRange(state.doc, from, to);\n        lines.push(lns);\n        lineRanges.push(findLineComment(token, lns));\n    }\n    if (option != 2 /* Uncomment */ && lineRanges.some(c => !c.commented)) {\n        let changes = [];\n        for (let i = 0, lineRange; i < ranges.length; i++)\n            if (!(lineRange = lineRanges[i]).commented) {\n                for (let line of lines[i]) {\n                    if (!lineRange.skipped[line.number] || lines[i].length == 1)\n                        changes.push({ from: line.from + lineRange.minCol, insert: tokens[i] + \" \" });\n                }\n            }\n        return { changes };\n    }\n    else if (option != 1 /* Comment */ && lineRanges.some(c => c.commented)) {\n        let changes = [];\n        for (let i = 0, lineRange; i < ranges.length; i++)\n            if ((lineRange = lineRanges[i]).commented) {\n                let token = tokens[i];\n                for (let line of lines[i]) {\n                    if (lineRange.skipped[line.number] && lines[i].length > 1)\n                        continue;\n                    let pos = line.from + lineRange.minCol;\n                    let posAfter = lineRange.minCol + token.length;\n                    let marginLen = line.text.slice(posAfter, posAfter + 1) == \" \" ? 1 : 0;\n                    changes.push({ from: pos, to: pos + token.length + marginLen });\n                }\n            }\n        return { changes };\n    }\n    return null;\n}\nfunction getLinesInRange(doc, from, to) {\n    let line = doc.lineAt(from), lines = [];\n    while (line.to < to || (line.from <= to && to <= line.to)) {\n        lines.push(line);\n        if (line.number == doc.lines)\n            break;\n        line = doc.line(line.number + 1);\n    }\n    return lines;\n}\n\nexport { blockComment, blockUncomment, commentKeymap, lineComment, lineUncomment, toggleBlockComment, toggleComment, toggleLineComment };\n","import { StateEffect, StateField, Facet, combineConfig } from '@codemirror/next/state';\nimport { Decoration, EditorView, WidgetType, themeClass, ViewPlugin } from '@codemirror/next/view';\nimport { foldable } from '@codemirror/next/language';\nimport { gutter, GutterMarker } from '@codemirror/next/gutter';\nimport { RangeSet } from '@codemirror/next/rangeset';\n\nfunction mapRange(range, mapping) {\n    let from = mapping.mapPos(range.from, 1), to = mapping.mapPos(range.to, -1);\n    return from >= to ? undefined : { from, to };\n}\nconst foldEffect = StateEffect.define({ map: mapRange });\nconst unfoldEffect = StateEffect.define({ map: mapRange });\nfunction selectedLines(view) {\n    let lines = [];\n    for (let { head } of view.state.selection.ranges) {\n        if (lines.some(l => l.from <= head && l.to >= head))\n            continue;\n        lines.push(view.visualLineAt(head));\n    }\n    return lines;\n}\nconst foldState = StateField.define({\n    create() {\n        return Decoration.none;\n    },\n    update(folded, tr) {\n        folded = folded.map(tr.changes);\n        for (let e of tr.effects) {\n            if (e.is(foldEffect) && !foldExists(folded, e.value.from, e.value.to))\n                folded = folded.update({ add: [foldWidget.range(e.value.from, e.value.to)] });\n            else if (e.is(unfoldEffect)) {\n                folded = folded.update({ filter: (from, to) => e.value.from != from || e.value.to != to,\n                    filterFrom: e.value.from, filterTo: e.value.to });\n            }\n        }\n        // Clear folded ranges that cover the selection head\n        if (tr.selection) {\n            let onSelection = false, { head } = tr.selection.main;\n            folded.between(head, head, (a, b) => { if (a < head && b > head)\n                onSelection = true; });\n            if (onSelection)\n                folded = folded.update({\n                    filterFrom: head,\n                    filterTo: head,\n                    filter: (a, b) => b <= head || a >= head\n                });\n        }\n        return folded;\n    },\n    provide: f => EditorView.decorations.compute([f], s => s.field(f))\n});\nfunction foldInside(state, from, to) {\n    var _a;\n    let found = null;\n    (_a = state.field(foldState, false)) === null || _a === void 0 ? void 0 : _a.between(from, to, (from, to) => {\n        if (!found || found.from > from)\n            found = ({ from, to });\n    });\n    return found;\n}\nfunction foldExists(folded, from, to) {\n    let found = false;\n    folded.between(from, from, (a, b) => { if (a == from && b == to)\n        found = true; });\n    return found;\n}\nfunction maybeEnable(state) {\n    return state.field(foldState, false) ? undefined : { append: codeFolding() };\n}\n/// Fold the lines that are selected, if possible.\nconst foldCode = view => {\n    for (let line of selectedLines(view)) {\n        let range = foldable(view.state, line.from, line.to);\n        if (range) {\n            view.dispatch({ effects: foldEffect.of(range),\n                reconfigure: maybeEnable(view.state) });\n            return true;\n        }\n    }\n    return false;\n};\n/// Unfold folded ranges on selected lines.\nconst unfoldCode = view => {\n    if (!view.state.field(foldState, false))\n        return false;\n    let effects = [];\n    for (let line of selectedLines(view)) {\n        let folded = foldInside(view.state, line.from, line.to);\n        if (folded)\n            effects.push(unfoldEffect.of(folded));\n    }\n    if (effects.length)\n        view.dispatch({ effects });\n    return effects.length > 0;\n};\n/// Fold all top-level foldable ranges.\nconst foldAll = view => {\n    let { state } = view, effects = [];\n    for (let pos = 0; pos < state.doc.length;) {\n        let line = view.visualLineAt(pos), range = foldable(state, line.from, line.to);\n        if (range)\n            effects.push(foldEffect.of(range));\n        pos = (range ? view.visualLineAt(range.to) : line).to + 1;\n    }\n    if (effects.length)\n        view.dispatch({ effects, reconfigure: maybeEnable(view.state) });\n    return !!effects.length;\n};\n/// Unfold all folded code.\nconst unfoldAll = view => {\n    let field = view.state.field(foldState, false);\n    if (!field || !field.size)\n        return false;\n    let effects = [];\n    field.between(0, view.state.doc.length, (from, to) => { effects.push(unfoldEffect.of({ from, to })); });\n    view.dispatch({ effects });\n    return true;\n};\n/// Default fold-related key bindings.\n///\n///  - Ctrl-Shift-[ (Cmd-Alt-[ on macOS): [`foldCode`](#fold.foldCode).\n///  - Ctrl-Shift-] (Cmd-Alt-] on macOS): [`unfoldCode`](#fold.unfoldCode).\n///  - Ctrl-Alt-[: [`foldAll`](#fold.foldAll).\n///  - Ctrl-Alt-]: [`unfoldAll`](#fold.unfoldAll).\nconst foldKeymap = [\n    { key: \"Ctrl-Shift-[\", mac: \"Cmd-Alt-[\", run: foldCode },\n    { key: \"Ctrl-Shift-]\", mac: \"Cmd-Alt-]\", run: unfoldCode },\n    { key: \"Ctrl-Alt-[\", run: foldAll },\n    { key: \"Ctrl-Alt-]\", run: unfoldAll }\n];\nconst defaultConfig = {\n    placeholderDOM: null,\n    placeholderText: \"…\"\n};\nconst foldConfig = Facet.define({\n    combine(values) { return combineConfig(values, defaultConfig); }\n});\n/// Create an extension that configures code folding.\nfunction codeFolding(config) {\n    let result = [foldState, baseTheme];\n    if (config)\n        result.push(foldConfig.of(config));\n    return result;\n}\nconst foldWidget = Decoration.replace({ widget: new class extends WidgetType {\n        ignoreEvents() { return false; }\n        toDOM(view) {\n            let { state } = view, conf = state.facet(foldConfig);\n            if (conf.placeholderDOM)\n                return conf.placeholderDOM();\n            let element = document.createElement(\"span\");\n            element.textContent = conf.placeholderText;\n            element.setAttribute(\"aria-label\", state.phrase(\"folded code\"));\n            element.title = state.phrase(\"unfold\");\n            element.className = themeClass(\"foldPlaceholder\");\n            element.onclick = event => {\n                let line = view.visualLineAt(view.posAtDOM(event.target));\n                let folded = foldInside(view.state, line.from, line.to);\n                if (folded)\n                    view.dispatch({ effects: unfoldEffect.of(folded) });\n                event.preventDefault();\n            };\n            return element;\n        }\n    } });\nconst foldGutterDefaults = {\n    openText: \"⌄\",\n    closedText: \"›\"\n};\nclass FoldMarker extends GutterMarker {\n    constructor(config, open) {\n        super();\n        this.config = config;\n        this.open = open;\n    }\n    eq(other) { return this.config == other.config && this.open == other.open; }\n    toDOM(view) {\n        let span = document.createElement(\"span\");\n        span.textContent = this.open ? this.config.openText : this.config.closedText;\n        span.title = view.state.phrase(this.open ? \"Fold line\" : \"Unfold line\");\n        return span;\n    }\n}\n/// Create an extension that registers a fold gutter, which shows a\n/// fold status indicator before foldable lines (which can be clicked\n/// to fold or unfold the line).\nfunction foldGutter(config = {}) {\n    let fullConfig = Object.assign(Object.assign({}, foldGutterDefaults), config);\n    let canFold = new FoldMarker(fullConfig, true), canUnfold = new FoldMarker(fullConfig, false);\n    let markers = ViewPlugin.fromClass(class {\n        constructor(view) {\n            this.from = view.viewport.from;\n            this.markers = RangeSet.of(this.buildMarkers(view));\n        }\n        update(update) {\n            let firstChange = -1;\n            update.changes.iterChangedRanges(from => { if (firstChange < 0)\n                firstChange = from; });\n            let foldChange = update.startState.field(foldState, false) != update.state.field(foldState, false);\n            if (!foldChange && update.docChanged && update.view.viewport.from == this.from && firstChange > this.from) {\n                let start = update.view.visualLineAt(firstChange).from;\n                this.markers = this.markers.update({\n                    filter: () => false,\n                    filterFrom: start,\n                    add: this.buildMarkers(update.view, start)\n                });\n            }\n            else if (foldChange || update.docChanged || update.viewportChanged) {\n                this.from = update.view.viewport.from;\n                this.markers = RangeSet.of(this.buildMarkers(update.view));\n            }\n        }\n        buildMarkers(view, from = 0) {\n            let ranges = [];\n            view.viewportLines(line => {\n                if (line.from >= from) {\n                    let mark = foldInside(view.state, line.from, line.to) ? canUnfold\n                        : foldable(view.state, line.from, line.to) ? canFold : null;\n                    if (mark)\n                        ranges.push(mark.range(line.from));\n                }\n            });\n            return ranges;\n        }\n    });\n    return [\n        markers,\n        gutter({\n            style: \"foldGutter\",\n            markers(view) { var _a; return ((_a = view.plugin(markers)) === null || _a === void 0 ? void 0 : _a.markers) || RangeSet.empty; },\n            initialSpacer() {\n                return new FoldMarker(fullConfig, false);\n            },\n            domEventHandlers: {\n                click: (view, line) => {\n                    let folded = foldInside(view.state, line.from, line.to);\n                    if (folded) {\n                        view.dispatch({ effects: unfoldEffect.of(folded) });\n                        return true;\n                    }\n                    let range = foldable(view.state, line.from, line.to);\n                    if (range) {\n                        view.dispatch({ effects: foldEffect.of(range) });\n                        return true;\n                    }\n                    return false;\n                }\n            }\n        }),\n        codeFolding()\n    ];\n}\nconst baseTheme = EditorView.baseTheme({\n    $foldPlaceholder: {\n        backgroundColor: \"#eee\",\n        border: \"1px solid #ddd\",\n        color: \"#888\",\n        borderRadius: \".2em\",\n        margin: \"0 1px\",\n        padding: \"0 1px\",\n        cursor: \"pointer\"\n    },\n    \"$gutterElement.foldGutter\": {\n        padding: \"0 1px\",\n        cursor: \"pointer\"\n    }\n});\n\nexport { codeFolding, foldAll, foldCode, foldGutter, foldKeymap, unfoldAll, unfoldCode };\n","import { EditorView, ViewPlugin, themeClass, BlockType, PluginField, Direction } from '@codemirror/next/view';\nimport { RangeValue, Range, RangeSet } from '@codemirror/next/rangeset';\nimport { MapMode, Facet, combineConfig } from '@codemirror/next/state';\n\n/// A gutter marker represents a bit of information attached to a line\n/// in a specific gutter. Your own custom markers have to extend this\n/// class.\nclass GutterMarker extends RangeValue {\n    /// @internal\n    compare(other) {\n        return this == other || this.constructor == other.constructor && this.eq(other);\n    }\n    /// Render the DOM node for this marker, if any.\n    toDOM(_view) { return null; }\n    /// Create a range that places this marker at the given position.\n    at(pos) { return new Range(pos, pos, this); }\n}\nGutterMarker.prototype.elementClass = \"\";\nGutterMarker.prototype.mapMode = MapMode.TrackBefore;\nconst defaults = {\n    style: \"\",\n    renderEmptyElements: false,\n    elementStyle: \"\",\n    markers: () => RangeSet.empty,\n    lineMarker: () => null,\n    initialSpacer: null,\n    updateSpacer: null,\n    domEventHandlers: {}\n};\nconst activeGutters = Facet.define();\n/// Define an editor gutter. The order in which the gutters appear is\n/// determined by their extension priority.\nfunction gutter(config) {\n    return [gutters(), activeGutters.of(Object.assign(Object.assign({}, defaults), config))];\n}\nconst baseTheme = EditorView.baseTheme({\n    $gutters: {\n        display: \"flex\",\n        height: \"100%\",\n        boxSizing: \"border-box\",\n        left: 0\n    },\n    \"$$light $gutters\": {\n        backgroundColor: \"#f5f5f5\",\n        color: \"#999\",\n        borderRight: \"1px solid #ddd\"\n    },\n    \"$$dark $gutters\": {\n        backgroundColor: \"#333338\",\n        color: \"#ccc\"\n    },\n    $gutter: {\n        display: \"flex !important\",\n        flexDirection: \"column\",\n        flexShrink: 0,\n        boxSizing: \"border-box\",\n        height: \"100%\",\n        overflow: \"hidden\"\n    },\n    $gutterElement: {\n        boxSizing: \"border-box\"\n    },\n    \"$gutterElement.lineNumber\": {\n        padding: \"0 3px 0 5px\",\n        minWidth: \"20px\",\n        textAlign: \"right\",\n        whiteSpace: \"nowrap\"\n    }\n});\nconst unfixGutters = Facet.define({\n    combine: values => values.some(x => x)\n});\n/// The gutter-drawing plugin is automatically enabled when you add a\n/// gutter, but you can use this function to explicitly configure it.\n///\n/// Unless `fixed` is explicitly set to `false`, the gutters are\n/// fixed, meaning they don't scroll along with the content\n/// horizontally (except on Internet Explorer, which doesn't support\n/// CSS [`position:\n/// sticky`](https://developer.mozilla.org/en-US/docs/Web/CSS/position#sticky)).\nfunction gutters(config) {\n    let result = [\n        gutterView,\n        baseTheme\n    ];\n    if (config && config.fixed === false)\n        result.push(unfixGutters.of(true));\n    return result;\n}\nconst gutterView = ViewPlugin.fromClass(class {\n    constructor(view) {\n        this.view = view;\n        this.dom = document.createElement(\"div\");\n        this.dom.className = themeClass(\"gutters\");\n        this.dom.setAttribute(\"aria-hidden\", \"true\");\n        this.gutters = view.state.facet(activeGutters).map(conf => new SingleGutterView(view, conf));\n        for (let gutter of this.gutters)\n            this.dom.appendChild(gutter.dom);\n        this.fixed = !view.state.facet(unfixGutters);\n        if (this.fixed) {\n            // FIXME IE11 fallback, which doesn't support position: sticky,\n            // by using position: relative + event handlers that realign the\n            // gutter (or just force fixed=false on IE11?)\n            this.dom.style.position = \"sticky\";\n        }\n        view.scrollDOM.insertBefore(this.dom, view.contentDOM);\n    }\n    update(update) {\n        if (!this.updateGutters(update))\n            return;\n        let contexts = this.gutters.map(gutter => new UpdateContext(gutter, this.view.viewport));\n        this.view.viewportLines(line => {\n            let text;\n            if (Array.isArray(line.type)) {\n                for (let b of line.type)\n                    if (b.type == BlockType.Text) {\n                        text = b;\n                        break;\n                    }\n            }\n            else {\n                text = line.type == BlockType.Text ? line : undefined;\n            }\n            if (!text)\n                return;\n            for (let cx of contexts)\n                cx.line(this.view, text);\n        }, 0);\n        for (let cx of contexts)\n            cx.finish();\n        this.dom.style.minHeight = this.view.contentHeight + \"px\";\n        if (update.state.facet(unfixGutters) != !this.fixed) {\n            this.fixed = !this.fixed;\n            this.dom.style.position = this.fixed ? \"sticky\" : \"\";\n        }\n    }\n    updateGutters(update) {\n        let prev = update.startState.facet(activeGutters), cur = update.state.facet(activeGutters);\n        let change = update.docChanged || update.heightChanged || update.viewportChanged;\n        if (prev == cur) {\n            for (let gutter of this.gutters)\n                if (gutter.update(update))\n                    change = true;\n        }\n        else {\n            change = true;\n            let gutters = [];\n            for (let conf of cur) {\n                let known = prev.indexOf(conf);\n                if (known < 0) {\n                    gutters.push(new SingleGutterView(this.view, conf));\n                }\n                else {\n                    this.gutters[known].update(update);\n                    gutters.push(this.gutters[known]);\n                }\n            }\n            for (let g of this.gutters)\n                g.dom.remove();\n            for (let g of gutters)\n                this.dom.appendChild(g.dom);\n            this.gutters = gutters;\n        }\n        return change;\n    }\n    destroy() {\n        this.dom.remove();\n    }\n}, {\n    provide: PluginField.scrollMargins.from(value => {\n        if (value.gutters.length == 0 || !value.fixed)\n            return null;\n        return value.view.textDirection == Direction.LTR ? { left: value.dom.offsetWidth } : { right: value.dom.offsetWidth };\n    })\n});\nfunction asArray(val) { return (Array.isArray(val) ? val : [val]); }\nclass UpdateContext {\n    constructor(gutter, viewport) {\n        this.gutter = gutter;\n        this.localMarkers = [];\n        this.i = 0;\n        this.height = 0;\n        this.cursor = RangeSet.iter(gutter.markers, viewport.from);\n    }\n    line(view, line) {\n        if (this.localMarkers.length)\n            this.localMarkers = [];\n        while (this.cursor.value && this.cursor.from <= line.from) {\n            if (this.cursor.from == line.from)\n                this.localMarkers.push(this.cursor.value);\n            this.cursor.next();\n        }\n        let forLine = this.gutter.config.lineMarker(view, line, this.localMarkers);\n        if (forLine)\n            this.localMarkers.unshift(forLine);\n        let gutter = this.gutter;\n        if (this.localMarkers.length == 0 && !gutter.config.renderEmptyElements)\n            return;\n        let above = line.top - this.height;\n        if (this.i == gutter.elements.length) {\n            let newElt = new GutterElement(view, line.height, above, this.localMarkers, gutter.elementClass);\n            gutter.elements.push(newElt);\n            gutter.dom.appendChild(newElt.dom);\n        }\n        else {\n            let markers = this.localMarkers, elt = gutter.elements[this.i];\n            if (sameMarkers(markers, elt.markers)) {\n                markers = elt.markers;\n                this.localMarkers.length = 0;\n            }\n            elt.update(view, line.height, above, markers, gutter.elementClass);\n        }\n        this.height = line.bottom;\n        this.i++;\n    }\n    finish() {\n        let gutter = this.gutter;\n        while (gutter.elements.length > this.i)\n            gutter.dom.removeChild(gutter.elements.pop().dom);\n    }\n}\nclass SingleGutterView {\n    constructor(view, config) {\n        this.view = view;\n        this.config = config;\n        this.elements = [];\n        this.spacer = null;\n        this.dom = document.createElement(\"div\");\n        this.dom.className = themeClass(\"gutter\" + (this.config.style ? \".\" + this.config.style : \"\"));\n        this.elementClass = themeClass(\"gutterElement\" + (this.config.style ? \".\" + this.config.style : \"\"));\n        for (let prop in config.domEventHandlers) {\n            this.dom.addEventListener(prop, (event) => {\n                let line = view.visualLineAtHeight(event.clientY, view.contentDOM.getBoundingClientRect().top);\n                if (config.domEventHandlers[prop](view, line, event))\n                    event.preventDefault();\n            });\n        }\n        this.markers = asArray(config.markers(view));\n        if (config.initialSpacer) {\n            this.spacer = new GutterElement(view, 0, 0, [config.initialSpacer(view)], this.elementClass);\n            this.dom.appendChild(this.spacer.dom);\n            this.spacer.dom.style.cssText += \"visibility: hidden; pointer-events: none\";\n        }\n    }\n    update(update) {\n        let prevMarkers = this.markers;\n        this.markers = asArray(this.config.markers(update.view));\n        if (this.spacer && this.config.updateSpacer) {\n            let updated = this.config.updateSpacer(this.spacer.markers[0], update);\n            if (updated != this.spacer.markers[0])\n                this.spacer.update(update.view, 0, 0, [updated], this.elementClass);\n        }\n        return this.markers != prevMarkers;\n    }\n}\nclass GutterElement {\n    constructor(view, height, above, markers, eltClass) {\n        this.height = -1;\n        this.above = 0;\n        this.dom = document.createElement(\"div\");\n        this.update(view, height, above, markers, eltClass);\n    }\n    update(view, height, above, markers, cssClass) {\n        if (this.height != height)\n            this.dom.style.height = (this.height = height) + \"px\";\n        if (this.above != above)\n            this.dom.style.marginTop = (this.above = above) ? above + \"px\" : \"\";\n        if (this.markers != markers) {\n            this.markers = markers;\n            for (let ch; ch = this.dom.lastChild;)\n                ch.remove();\n            let cls = cssClass;\n            for (let m of markers) {\n                let dom = m.toDOM(view);\n                if (dom)\n                    this.dom.appendChild(dom);\n                let c = m.elementClass;\n                if (c)\n                    cls += \" \" + c;\n            }\n            this.dom.className = cls;\n        }\n    }\n}\nfunction sameMarkers(a, b) {\n    if (a.length != b.length)\n        return false;\n    for (let i = 0; i < a.length; i++)\n        if (!a[i].compare(b[i]))\n            return false;\n    return true;\n}\n/// Facet used to provide markers to the line number gutter.\nconst lineNumberMarkers = Facet.define();\nconst lineNumberConfig = Facet.define({\n    combine(values) {\n        return combineConfig(values, { formatNumber: String, domEventHandlers: {} }, {\n            domEventHandlers(a, b) {\n                let result = Object.assign({}, a);\n                for (let event in b) {\n                    let exists = result[event], add = b[event];\n                    result[event] = exists ? (view, line, event) => exists(view, line, event) || add(view, line, event) : add;\n                }\n                return result;\n            }\n        });\n    }\n});\nclass NumberMarker extends GutterMarker {\n    constructor(number) {\n        super();\n        this.number = number;\n    }\n    eq(other) { return this.number == other.number; }\n    toDOM(view) {\n        let config = view.state.facet(lineNumberConfig);\n        return document.createTextNode(config.formatNumber(this.number));\n    }\n}\nconst lineNumberGutter = gutter({\n    style: \"lineNumber\",\n    markers(view) { return view.state.facet(lineNumberMarkers); },\n    lineMarker(view, line, others) {\n        if (others.length)\n            return null;\n        return new NumberMarker(view.state.doc.lineAt(line.from).number);\n    },\n    initialSpacer(view) {\n        return new NumberMarker(maxLineNumber(view.state.doc.lines));\n    },\n    updateSpacer(spacer, update) {\n        let max = maxLineNumber(update.view.state.doc.lines);\n        return max == spacer.number ? spacer : new NumberMarker(max);\n    }\n});\n/// Create a line number gutter extension.\nfunction lineNumbers(config = {}) {\n    return [\n        lineNumberConfig.of(config),\n        lineNumberGutter\n    ];\n}\nfunction maxLineNumber(lines) {\n    let last = 9;\n    while (last < lines)\n        last = last * 10 + 9;\n    return last;\n}\n\nexport { GutterMarker, gutter, gutters, lineNumberMarkers, lineNumbers };\n","import { NodeProp } from 'lezer-tree';\nimport { StyleModule } from 'style-mod';\nimport { EditorView, ViewPlugin, Decoration } from '@codemirror/next/view';\nimport { Facet, Prec } from '@codemirror/next/state';\nimport { syntaxTree } from '@codemirror/next/language';\nimport { RangeSetBuilder } from '@codemirror/next/rangeset';\n\nlet nextTagID = 0;\n/// Highlighting tags are markers that denote a highlighting category.\n/// They are [associated](#highlight.styleTags) with parts of a syntax\n/// tree by a language mode, and then mapped to an actual CSS style by\n/// a [highlight style](#highlight.HighlightStyle).\n///\n/// Because syntax tree node types and highlight styles have to be\n/// able to talk the same language, CodeMirror uses a mostly _closed_\n/// [vocabulary](#highlight.tags) of syntax tags (as opposed to\n/// traditional open string-based systems, which make it hard for\n/// highlighting themes to cover all the tokens produced by the\n/// various languages).\n///\n/// It _is_ possible to [define](#highlight.Tag^define) your own\n/// highlighting tags for system-internal use (where you control both\n/// the language package and the highlighter), but such tags will not\n/// be picked up by regular highlighters (though you can derive them\n/// from standard tags to allow highlighters to fall back to those).\nclass Tag {\n    /// @internal\n    constructor(\n    /// The set of tags that match this tag, starting with this one\n    /// itself, sorted in order of decreasing specificity. @internal\n    set, \n    /// The base unmodified tag that this one is based on, if it's\n    /// modified @internal\n    base, \n    /// The modifiers applied to this.base @internal\n    modified) {\n        this.set = set;\n        this.base = base;\n        this.modified = modified;\n        /// @internal\n        this.id = nextTagID++;\n    }\n    /// Define a new tag. If `parent` is given, the tag is treated as a\n    /// sub-tag of that parent, and [highlight\n    /// styles](#highlight.HighlightStyle) that don't mention this tag\n    /// will try to fall back to the parent tag (or grandparent tag,\n    /// etc).\n    static define(parent) {\n        if (parent === null || parent === void 0 ? void 0 : parent.base)\n            throw new Error(\"Can not derive from a modified tag\");\n        let tag = new Tag([], null, []);\n        tag.set.push(tag);\n        if (parent)\n            for (let t of parent.set)\n                tag.set.push(t);\n        return tag;\n    }\n    /// Define a tag _modifier_, which is a function that, given a tag,\n    /// will return a tag that is a subtag of the original. Applying the\n    /// same modifier to a twice tag will return the same value (`m1(t1)\n    /// == m1(t1)`) and applying multiple modifiers will, regardless or\n    /// order, produce the same tag (`m1(m2(t1)) == m2(m1(t1))`).\n    ///\n    /// When multiple modifiers are applied to a given base tag, each\n    /// smaller set of modifiers is registered as a parent, so that for\n    /// example `m1(m2(m3(t1)))` is a subtype of `m1(m2(t1))`,\n    /// `m1(m3(t1)`, and so on.\n    static defineModifier() {\n        let mod = new Modifier;\n        return (tag) => {\n            if (tag.modified.indexOf(mod) > -1)\n                return tag;\n            return Modifier.get(tag.base || tag, tag.modified.concat(mod).sort((a, b) => a.id - b.id));\n        };\n    }\n}\nlet nextModifierID = 0;\nclass Modifier {\n    constructor() {\n        this.instances = [];\n        this.id = nextModifierID++;\n    }\n    static get(base, mods) {\n        if (!mods.length)\n            return base;\n        let exists = mods[0].instances.find(t => t.base == base && sameArray(mods, t.modified));\n        if (exists)\n            return exists;\n        let set = [], tag = new Tag(set, base, mods);\n        for (let m of mods)\n            m.instances.push(tag);\n        let configs = permute(mods);\n        for (let parent of base.set)\n            for (let config of configs)\n                set.push(Modifier.get(parent, config));\n        return tag;\n    }\n}\nfunction sameArray(a, b) {\n    return a.length == b.length && a.every((x, i) => x == b[i]);\n}\nfunction permute(array) {\n    let result = [array];\n    for (let i = 0; i < array.length; i++) {\n        for (let a of permute(array.slice(0, i).concat(array.slice(i + 1))))\n            result.push(a);\n    }\n    return result;\n}\n/// This function is used to add a set of tags to a language syntax\n/// via\n/// [`Parser.configure`](https://lezer.codemirror.net/docs/ref#lezer.Parser.configure).\n///\n/// The argument object maps node selectors to [highlighting\n/// tags](#highlight.Tag) or arrays of tags.\n///\n/// Node selectors may hold one or more (space-separated) node paths.\n/// Such a path can be a [node\n/// name](https://lezer.codemirror.net/docs/ref#tree.NodeType.name),\n/// or multiple node names (or `*` wildcards) separated by slash\n/// characters, as in `\"Block/Declaration/VariableName\"`. Such a path\n/// matches the final node but only if its direct parent nodes are the\n/// other nodes mentioned. A `*` in such a path matches any parent,\n/// but only a single level—wildcards that match multiple parents\n/// aren't supported, both for efficiency reasons and because Lezer\n/// trees make it rather hard to reason about what they would match.)\n///\n/// A path can be ended with `/...` to indicate that the tag assigned\n/// to the node should also apply to all child nodes, even if they\n/// match their own style (by default, only the innermost style is\n/// used).\n///\n/// When a path ends in `!`, as in `Attribute!`, no further matching\n/// happens for the node's child nodes, and the entire node gets the\n/// given style.\n///\n/// In this notation, node names that contain `/`, `!`, `*`, or `...`\n/// must be quoted as JSON strings.\n///\n/// For example:\n///\n/// ```javascript\n/// parser.withProps(\n///   styleTags({\n///     // Style Number and BigNumber nodes\n///     \"Number BigNumber\": tags.number,\n///     // Style Escape nodes whose parent is String\n///     \"String/Escape\": tags.escape,\n///     // Style anything inside Attributes nodes\n///     \"Attributes!\": tags.meta,\n///     // Add a style to all content inside Italic nodes\n///     \"Italic/...\": tags.emphasis,\n///     // Style InvalidString nodes as both `string` and `invalid`\n///     \"InvalidString\": [tags.string, tags.invalid],\n///     // Style the node named \"/\" as punctuation\n///     '\"/\"': tags.punctuation\n///   })\n/// )\n/// ```\nfunction styleTags(spec) {\n    let byName = Object.create(null);\n    for (let prop in spec) {\n        let tags = spec[prop];\n        if (!Array.isArray(tags))\n            tags = [tags];\n        for (let part of prop.split(\" \"))\n            if (part) {\n                let pieces = [], mode = 2 /* Normal */, rest = part;\n                for (let pos = 0;;) {\n                    if (rest == \"...\" && pos > 0 && pos + 3 == part.length) {\n                        mode = 1 /* Inherit */;\n                        break;\n                    }\n                    let m = /^\"(?:[^\"\\\\]|\\\\.)*?\"|[^\\/!]+/.exec(rest);\n                    if (!m)\n                        throw new RangeError(\"Invalid path: \" + part);\n                    pieces.push(m[0] == \"*\" ? null : m[0][0] == '\"' ? JSON.parse(m[0]) : m[0]);\n                    pos += m[0].length;\n                    if (pos == part.length)\n                        break;\n                    let next = part[pos++];\n                    if (pos == part.length && next == \"!\") {\n                        mode = 0 /* Opaque */;\n                        break;\n                    }\n                    if (next != \"/\")\n                        throw new RangeError(\"Invalid path: \" + part);\n                    rest = part.slice(pos);\n                }\n                let last = pieces.length - 1, inner = pieces[last];\n                if (!inner)\n                    throw new RangeError(\"Invalid path: \" + part);\n                let rule = new Rule(tags, mode, last > 0 ? pieces.slice(0, last) : null);\n                byName[inner] = rule.sort(byName[inner]);\n            }\n    }\n    return ruleNodeProp.add(byName);\n}\nconst ruleNodeProp = new NodeProp();\nconst highlightStyleProp = Facet.define({\n    combine(stylings) { return stylings.length ? stylings[0] : null; }\n});\nclass Rule {\n    constructor(tags, mode, context, next) {\n        this.tags = tags;\n        this.mode = mode;\n        this.context = context;\n        this.next = next;\n    }\n    sort(other) {\n        if (!other || other.depth < this.depth) {\n            this.next = other;\n            return this;\n        }\n        other.next = this.sort(other.next);\n        return other;\n    }\n    get depth() { return this.context ? this.context.length : 0; }\n}\nclass HighlightStyle {\n    constructor(spec) {\n        this.map = Object.create(null);\n        let modSpec = Object.create(null);\n        for (let style of spec) {\n            let cls = StyleModule.newName();\n            modSpec[\".\" + cls] = Object.assign({}, style, { tag: null });\n            let tags = style.tag;\n            if (!Array.isArray(tags))\n                tags = [tags];\n            for (let tag of tags)\n                this.map[tag.id] = cls;\n        }\n        this.module = new StyleModule(modSpec);\n        this.match = this.match.bind(this);\n        this.extension = [\n            treeHighlighter,\n            highlightStyleProp.of(this),\n            EditorView.styleModule.of(this.module)\n        ];\n    }\n    /// Returns the CSS class associated with the given tag, if any.\n    match(tag) {\n        for (let t of tag.set) {\n            let match = this.map[t.id];\n            if (match) {\n                if (t != tag)\n                    this.map[tag.id] = match;\n                return match;\n            }\n        }\n        return this.map[tag.id] = null;\n    }\n    /// Create a highlighter style that associates the given styles to\n    /// the given tags. The spec must be objects that hold a style tag\n    /// or array of tags in their `tag` property, and\n    /// [`style-mod`](https://github.com/marijnh/style-mod#documentation)-style\n    /// CSS properties in further properties (which define the styling\n    /// for those tags).\n    ///\n    /// The CSS rules created for a highlighter will be emitted in the\n    /// order of the spec's properties. That means that for elements that\n    /// have multiple tags associated with them, styles defined further\n    /// down in the list will have a higher CSS precedence than styles\n    /// defined earlier.\n    static define(...specs) {\n        return new HighlightStyle(specs);\n    }\n}\n/// Given a string of code and a language, parse the code in that\n/// language and run the tree highlighter over the resulting syntax\n/// tree. For each differently-styled range, call `emit` with the\n/// extend of the range and the CSS classes (as a space-separated\n/// string) that apply to it. `emit` will be called with an empty\n/// string for unstyled ranges.\nfunction highlightTree(tree, \n/// Get the CSS classes used to style a given [tag](#highlight.Tag),\n/// or `null` if it isn't styled.\ngetStyle, \n/// Assign styling to a region of the text. Will only be in order of\n/// position for any ranges where more than zero classes apply.\n/// `classes` is a space separated string of CSS classes.\nputStyle) {\n    highlightTreeRange(tree, 0, tree.length, getStyle, putStyle);\n}\n// This extension installs a highlighter that highlights based on the\n// syntax tree and highlight style.\nconst treeHighlighter = Prec.fallback(ViewPlugin.define(view => new TreeHighlighter(view), {\n    decorations: v => v.decorations\n}));\nclass TreeHighlighter {\n    constructor(view) {\n        this.markCache = Object.create(null);\n        this.tree = syntaxTree(view.state);\n        this.decorations = this.buildDeco(view);\n    }\n    update(update) {\n        let tree = syntaxTree(update.state);\n        if (tree.length < update.view.viewport.to) {\n            this.decorations = this.decorations.map(update.changes);\n        }\n        else if (tree != this.tree || update.viewportChanged) {\n            this.tree = tree;\n            this.decorations = this.buildDeco(update.view);\n        }\n    }\n    buildDeco(view) {\n        const style = view.state.facet(highlightStyleProp);\n        if (!style || !this.tree.length)\n            return Decoration.none;\n        let builder = new RangeSetBuilder();\n        for (let { from, to } of view.visibleRanges) {\n            highlightTreeRange(this.tree, from, to, style.match, (from, to, style) => {\n                builder.add(from, to, this.markCache[style] || (this.markCache[style] = Decoration.mark({ class: style })));\n            });\n        }\n        return builder.finish();\n    }\n}\n// Reused stacks for highlightTreeRange\nconst nodeStack = [\"\"], classStack = [\"\"], inheritStack = [\"\"];\nfunction highlightTreeRange(tree, from, to, style, span) {\n    let spanStart = from, spanClass = \"\", depth = 0;\n    tree.iterate({\n        from, to,\n        enter: (type, start) => {\n            depth++;\n            let inheritedClass = inheritStack[depth - 1];\n            let cls = inheritedClass;\n            let rule = type.prop(ruleNodeProp), opaque = false;\n            while (rule) {\n                if (!rule.context || matchContext(rule.context, nodeStack, depth)) {\n                    for (let tag of rule.tags) {\n                        let st = style(tag);\n                        if (st) {\n                            if (cls)\n                                cls += \" \";\n                            cls += st;\n                            if (rule.mode == 1 /* Inherit */)\n                                inheritedClass = cls;\n                            else if (rule.mode == 0 /* Opaque */)\n                                opaque = true;\n                        }\n                    }\n                    break;\n                }\n                rule = rule.next;\n            }\n            if (cls != spanClass) {\n                if (start > spanStart && spanClass)\n                    span(spanStart, start, spanClass);\n                spanStart = start;\n                spanClass = cls;\n            }\n            if (opaque) {\n                depth--;\n                return false;\n            }\n            classStack[depth] = cls;\n            inheritStack[depth] = inheritedClass;\n            nodeStack[depth] = type.name;\n            return undefined;\n        },\n        leave: (_t, _s, end) => {\n            depth--;\n            let backTo = classStack[depth];\n            if (backTo != spanClass) {\n                let pos = Math.min(to, end);\n                if (pos > spanStart && spanClass)\n                    span(spanStart, pos, spanClass);\n                spanStart = pos;\n                spanClass = backTo;\n            }\n        }\n    });\n}\nfunction matchContext(context, stack, depth) {\n    if (context.length > depth - 1)\n        return false;\n    for (let d = depth - 1, i = context.length - 1; i >= 0; i--, d--) {\n        let check = context[i];\n        if (check && check != stack[d])\n            return false;\n    }\n    return true;\n}\nconst t = Tag.define;\nconst comment = t(), name = t(), literal = t(), string = t(literal), number = t(literal), content = t(), heading = t(content), keyword = t(), operator = t(), punctuation = t(), bracket = t(punctuation), meta = t();\n/// The default set of highlighting [tags](#highlight.Tag^define) used\n/// by regular language packages and themes.\n///\n/// This collection is heavily biased towards programming languages,\n/// and necessarily incomplete. A full ontology of syntactic\n/// constructs would fill a stack of books, and be impractical to\n/// write themes for. So try to make do with this set. If all else\n/// fails, [open an\n/// issue](https://github.com/codemirror/codemirror.next) to propose a\n/// new tag, or [define](#highlight.Tag^define) a local custom tag for\n/// your use case.\n///\n/// Note that it is not obligatory to always attach the most specific\n/// tag possible to an element—if your grammar can't easily\n/// distinguish a certain type of element (such as a local variable),\n/// it is okay to style it as its more general variant (a variable).\n/// \n/// For tags that extend some parent tag, the documentation links to\n/// the parent.\nconst tags = {\n    /// A comment.\n    comment,\n    /// A line [comment](#highlight.tags.comment).\n    lineComment: t(comment),\n    /// A block [comment](#highlight.tags.comment).\n    blockComment: t(comment),\n    /// A documentation [comment](#highlight.tags.comment).\n    docComment: t(comment),\n    /// Any kind of identifier.\n    name,\n    /// The [name](#highlight.tags.name) of a variable.\n    variableName: t(name),\n    /// A type or tag [name](#highlight.tags.name).\n    typeName: t(name),\n    /// A property, field, or attribute [name](#highlight.tags.name).\n    propertyName: t(name),\n    /// The [name](#highlight.tags.name) of a class.\n    className: t(name),\n    /// A label [name](#highlight.tags.name).\n    labelName: t(name),\n    /// A namespace [name](#highlight.tags.name).\n    namespace: t(name),\n    /// The [name](#highlight.tags.name) of a macro.\n    macroName: t(name),\n    /// A literal value.\n    literal,\n    /// A string [literal](#highlight.tags.literal).\n    string,\n    /// A documentation [string](#highlight.tags.string).\n    docString: t(string),\n    /// A character literal (subtag of [string](#highlight.tags.string)).\n    character: t(string),\n    /// A number [literal](#highlight.tags.literal).\n    number,\n    /// An integer [number](#highlight.tags.number) literal.\n    integer: t(number),\n    /// A floating-point [number](#highlight.tags.number) literal.\n    float: t(number),\n    /// A boolean [literal](#highlight.tags.literal).\n    bool: t(literal),\n    /// Regular expression [literal](#highlight.tags.literal).\n    regexp: t(literal),\n    /// An escape [literal](#highlight.tags.literal), for example a\n    /// backslash escape in a string.\n    escape: t(literal),\n    /// A color [literal](#highlight.tags.literal).\n    color: t(literal),\n    /// A URL [literal](#highlight.tags.literal).\n    url: t(literal),\n    /// A language keyword.\n    keyword,\n    /// The [keyword](#highlight.tags.keyword) for the self or this\n    /// object.\n    self: t(keyword),\n    /// The [keyword](#highlight.tags.keyword) for null.\n    null: t(keyword),\n    /// A [keyword](#highlight.tags.keyword) denoting some atomic value.\n    atom: t(keyword),\n    /// A [keyword](#highlight.tags.keyword) that represents a unit.\n    unit: t(keyword),\n    /// A modifier [keyword](#highlight.tags.keyword).\n    modifier: t(keyword),\n    /// A [keyword](#highlight.tags.keyword) that acts as an operator.\n    operatorKeyword: t(keyword),\n    /// A control-flow related [keyword](#highlight.tags.keyword).\n    controlKeyword: t(keyword),\n    /// A [keyword](#highlight.tags.keyword) that defines something.\n    definitionKeyword: t(keyword),\n    /// An operator.\n    operator,\n    /// An [operator](#highlight.tags.operator) that defines something.\n    derefOperator: t(operator),\n    /// Arithmetic-related [operator](#highlight.tags.operator).\n    arithmeticOperator: t(operator),\n    /// Logical [operator](#highlight.tags.operator).\n    logicOperator: t(operator),\n    /// Bit [operator](#highlight.tags.operator).\n    bitwiseOperator: t(operator),\n    /// Comparison [operator](#highlight.tags.operator).\n    compareOperator: t(operator),\n    /// [Operator](#highlight.tags.operator) that updates its operand.\n    updateOperator: t(operator),\n    /// [Operator](#highlight.tags.operator) that defines something.\n    definitionOperator: t(operator),\n    /// Type-related [operator](#highlight.tags.operator).\n    typeOperator: t(operator),\n    /// Control-flow [operator](#highlight.tags.operator).\n    controlOperator: t(operator),\n    /// Program or markup punctuation.\n    punctuation,\n    /// [Punctuation](#highlight.tags.punctuation) that separates\n    /// things.\n    separator: t(punctuation),\n    /// Bracket-style [punctuation](#highlight.tags.punctuation).\n    bracket,\n    /// Angle [brackets](#highlight.tags.bracket) (usually `<` and `>`\n    /// tokens).\n    angleBracket: t(bracket),\n    /// Square [brackets](#highlight.tags.bracket) (usually `[` and `]`\n    /// tokens).\n    squareBracket: t(bracket),\n    /// Parentheses (usually `(` and `)` tokens). Subtag of\n    /// [bracket](#highlight.tags.bracket).\n    paren: t(bracket),\n    /// Braces (usually `{` and `}` tokens). Subtag of\n    /// [bracket](#highlight.tags.bracket).\n    brace: t(bracket),\n    /// Content, for example plain text in XML or markup documents.\n    content,\n    /// [Content](#highlight.tags.content) that represents a heading.\n    heading,\n    /// A level 1 [heading](#highlight.tags.heading).\n    heading1: t(heading),\n    /// A level 2 [heading](#highlight.tags.heading).\n    heading2: t(heading),\n    /// A level 3 [heading](#highlight.tags.heading).\n    heading3: t(heading),\n    /// A level 4 [heading](#highlight.tags.heading).\n    heading4: t(heading),\n    /// A level 5 [heading](#highlight.tags.heading).\n    heading5: t(heading),\n    /// A level 6 [heading](#highlight.tags.heading).\n    heading6: t(heading),\n    /// A prose separator (such as a horizontal rule).\n    contentSeparator: t(content),\n    /// [Content](#highlight.tags.content) that represents a list.\n    list: t(content),\n    /// [Content](#highlight.tags.content) that represents a quote.\n    quote: t(content),\n    /// [Content](#highlight.tags.content) that is emphasized.\n    emphasis: t(content),\n    /// [Content](#highlight.tags.content) that is styled strong.\n    strong: t(content),\n    /// [Content](#highlight.tags.content) that is part of a link.\n    link: t(content),\n    /// [Content](#highlight.tags.content) that is styled as code or\n    /// monospace.\n    monospace: t(content),\n    /// Inserted text in a change-tracking format.\n    inserted: t(),\n    /// Deleted text.\n    deleted: t(),\n    /// Changed text.\n    changed: t(),\n    /// An invalid or unsyntactic element.\n    invalid: t(),\n    /// Metadata or meta-instruction.\n    meta,\n    /// [Metadata](#highlight.tags.meta) that applies to the entire\n    /// document.\n    documentMeta: t(meta),\n    /// [Metadata](#highlight.tags.meta) that annotates or adds\n    /// attributes to a given syntactic element.\n    annotation: t(meta),\n    /// Processing instruction or preprocessor directive. Subtag of\n    /// [meta](#highlight.tags.meta).\n    processingInstruction: t(meta),\n    /// [Modifier](#highlight.Tag^defineModifier) that indicates that a\n    /// given element is being defined. Expected to be used with the\n    /// various [name](#highlight.tags.name) tags.\n    definition: Tag.defineModifier(),\n    /// [Modifier](#highlight.Tag^defineModifier) that indicates that\n    /// something is constant. Mostly expected to be used with\n    /// [variable names](#highlight.tags.variableName).\n    constant: Tag.defineModifier(),\n    /// [Modifier](#highlight.Tag^defineModifier) used to indicate that\n    /// a [variable](#highlight.tags.variableName) or [property\n    /// name](#highlight.tags.propertyName) is being called or defined\n    /// as a function.\n    function: Tag.defineModifier(),\n    /// [Modifier](#highlight.Tag^defineModifier) that can be applied to\n    /// [names](#highlight.tags.name) to indicate that they belong to\n    /// the language's standard environment.\n    standard: Tag.defineModifier(),\n    /// [Modifier](#highlight.Tag^defineModifier) that indicates a given\n    /// [names](#highlight.tags.name) is local to some scope.\n    local: Tag.defineModifier(),\n    /// A generic variant [modifier](#highlight.Tag^defineModifier) that\n    /// can be used to tag language-specific alternative variants of\n    /// some common tag. It is recommended for themes to define special\n    /// forms of at least the [string](#highlight.tags.string) and\n    /// [variable name](#highlight.tags.variableName) tags, since those\n    /// come up a lot.\n    special: Tag.defineModifier()\n};\n/// A default highlight style (works well with light themes).\nconst defaultHighlightStyle = HighlightStyle.define({ tag: tags.link,\n    textDecoration: \"underline\" }, { tag: tags.heading,\n    textDecoration: \"underline\",\n    fontWeight: \"bold\" }, { tag: tags.emphasis,\n    fontStyle: \"italic\" }, { tag: tags.strong,\n    fontWeight: \"bold\" }, { tag: tags.keyword,\n    color: \"#708\" }, { tag: [tags.atom, tags.bool, tags.url, tags.contentSeparator, tags.labelName],\n    color: \"#219\" }, { tag: [tags.literal, tags.inserted],\n    color: \"#164\" }, { tag: [tags.string, tags.deleted],\n    color: \"#a11\" }, { tag: [tags.regexp, tags.escape, tags.special(tags.string)],\n    color: \"#e40\" }, { tag: tags.definition(tags.variableName),\n    color: \"#00f\" }, { tag: tags.local(tags.variableName),\n    color: \"#30a\" }, { tag: [tags.typeName, tags.namespace],\n    color: \"#085\" }, { tag: tags.className,\n    color: \"#167\" }, { tag: [tags.special(tags.variableName), tags.macroName, tags.local(tags.variableName)],\n    color: \"#256\" }, { tag: tags.definition(tags.propertyName),\n    color: \"#00c\" }, { tag: tags.comment,\n    color: \"#940\" }, { tag: tags.meta,\n    color: \"#7a757a\" }, { tag: tags.invalid,\n    color: \"#f00\" });\n\nexport { HighlightStyle, Tag, defaultHighlightStyle, highlightTree, styleTags, tags };\n","import { Annotation, Facet, combineConfig, StateField, Transaction, StateEffect } from '@codemirror/next/state';\nimport { EditorView } from '@codemirror/next/view';\n\nconst fromHistory = Annotation.define();\n/// Transaction annotation that will prevent that transaction from\n/// being combined with other transactions in the undo history. Given\n/// `\"before\"`, it'll prevent merging with previous transactions. With\n/// `\"after\"`, subsequent transactions won't be combined with this\n/// one. With `\"full\"`, the transaction is isolated on both sides.\nconst isolateHistory = Annotation.define();\n/// This facet provides a way to register functions that, given a\n/// transaction, provide a set of effects that the history should\n/// store when inverting the transaction. This can be used to\n/// integrate some kinds of effects in the history, so that they can\n/// be undone (and redone again).\nconst invertedEffects = Facet.define();\nconst historyConfig = Facet.define({\n    combine(configs) {\n        return combineConfig(configs, {\n            minDepth: 100,\n            newGroupDelay: 500\n        }, { minDepth: Math.max, newGroupDelay: Math.min });\n    }\n});\nconst historyField = StateField.define({\n    create() {\n        return HistoryState.empty;\n    },\n    update(state, tr) {\n        let config = tr.state.facet(historyConfig);\n        let fromHist = tr.annotation(fromHistory);\n        if (fromHist) {\n            let item = HistEvent.fromTransaction(tr), from = fromHist.side;\n            let other = from == 0 /* Done */ ? state.undone : state.done;\n            if (item)\n                other = updateBranch(other, other.length, config.minDepth, item);\n            else\n                other = addSelection(other, tr.startState.selection);\n            return new HistoryState(from == 0 /* Done */ ? fromHist.rest : other, from == 0 /* Done */ ? other : fromHist.rest);\n        }\n        let isolate = tr.annotation(isolateHistory);\n        if (isolate == \"full\" || isolate == \"before\")\n            state = state.isolate();\n        if (tr.annotation(Transaction.addToHistory) === false)\n            return tr.changes.length ? state.addMapping(tr.changes.desc) : state;\n        let event = HistEvent.fromTransaction(tr);\n        let time = tr.annotation(Transaction.time), userEvent = tr.annotation(Transaction.userEvent);\n        if (event)\n            state = state.addChanges(event, time, userEvent, config.newGroupDelay, config.minDepth);\n        else if (tr.selection)\n            state = state.addSelection(tr.startState.selection, time, userEvent, config.newGroupDelay);\n        if (isolate == \"full\" || isolate == \"after\")\n            state = state.isolate();\n        return state;\n    }\n});\n/// Create a history extension with the given configuration.\nfunction history(config = {}) {\n    return [\n        historyField,\n        historyConfig.of(config),\n        EditorView.domEventHandlers({\n            beforeinput(e, view) {\n                if (e.inputType == \"historyUndo\")\n                    return undo(view);\n                if (e.inputType == \"historyRedo\")\n                    return redo(view);\n                return false;\n            }\n        })\n    ];\n}\nfunction cmd(side, selection) {\n    return function ({ state, dispatch }) {\n        let historyState = state.field(historyField, false);\n        if (!historyState)\n            return false;\n        let tr = historyState.pop(side, state, selection);\n        if (!tr)\n            return false;\n        dispatch(tr);\n        return true;\n    };\n}\n/// Undo a single group of history events. Returns false if no group\n/// was available.\nconst undo = cmd(0 /* Done */, false);\n/// Redo a group of history events. Returns false if no group was\n/// available.\nconst redo = cmd(1 /* Undone */, false);\n/// Undo a selection change.\nconst undoSelection = cmd(0 /* Done */, true);\n/// Redo a selection change.\nconst redoSelection = cmd(1 /* Undone */, true);\nfunction depth(side) {\n    return function (state) {\n        let histState = state.field(historyField, false);\n        if (!histState)\n            return 0;\n        let branch = side == 0 /* Done */ ? histState.done : histState.undone;\n        return branch.length - (branch.length && !branch[0].changes ? 1 : 0);\n    };\n}\n/// The amount of undoable change events available in a given state.\nconst undoDepth = depth(0 /* Done */);\n/// The amount of redoable change events available in a given state.\nconst redoDepth = depth(1 /* Undone */);\n// History events store groups of changes or effects that need to be\n// undone/redone together.\nclass HistEvent {\n    constructor(\n    // The changes in this event. Normal events hold at least one\n    // change or effect. But it may be necessary to store selection\n    // events before the first change, in which case a special type of\n    // instance is created which doesn't hold any changes, with\n    // changes == startSelection == undefined\n    changes, \n    // The effects associated with this event\n    effects, mapped, \n    // The selection before this event\n    startSelection, \n    // Stores selection changes after this event, to be used for\n    // selection undo/redo.\n    selectionsAfter) {\n        this.changes = changes;\n        this.effects = effects;\n        this.mapped = mapped;\n        this.startSelection = startSelection;\n        this.selectionsAfter = selectionsAfter;\n    }\n    setSelAfter(after) {\n        return new HistEvent(this.changes, this.effects, this.mapped, this.startSelection, after);\n    }\n    // This does not check `addToHistory` and such, it assumes the\n    // transaction needs to be converted to an item. Returns null when\n    // there are no changes or effects in the transaction.\n    static fromTransaction(tr) {\n        let effects = none;\n        for (let invert of tr.startState.facet(invertedEffects)) {\n            let result = invert(tr);\n            if (result.length)\n                effects = effects.concat(result);\n        }\n        if (!effects.length && tr.changes.empty)\n            return null;\n        return new HistEvent(tr.changes.invert(tr.startState.doc), effects, undefined, tr.startState.selection, none);\n    }\n    static selection(selections) {\n        return new HistEvent(undefined, none, undefined, undefined, selections);\n    }\n}\nfunction updateBranch(branch, to, maxLen, newEvent) {\n    let start = to + 1 > maxLen + 20 ? to - maxLen - 1 : 0;\n    let newBranch = branch.slice(start, to);\n    newBranch.push(newEvent);\n    return newBranch;\n}\nfunction isAdjacent(a, b) {\n    let ranges = [], isAdjacent = false;\n    a.iterChangedRanges((f, t) => ranges.push(f, t));\n    b.iterChangedRanges((_f, _t, f, t) => {\n        for (let i = 0; i < ranges.length;) {\n            let from = ranges[i++], to = ranges[i++];\n            if (t >= from && f <= to)\n                isAdjacent = true;\n        }\n    });\n    return isAdjacent;\n}\nfunction eqSelectionShape(a, b) {\n    return a.ranges.length == b.ranges.length &&\n        a.ranges.filter((r, i) => r.empty != b.ranges[i].empty).length === 0;\n}\nfunction conc(a, b) {\n    return !a.length ? b : !b.length ? a : a.concat(b);\n}\nconst none = [];\nconst MaxSelectionsPerEvent = 200;\nfunction addSelection(branch, selection) {\n    if (!branch.length) {\n        return [HistEvent.selection([selection])];\n    }\n    else {\n        let lastEvent = branch[branch.length - 1];\n        let sels = lastEvent.selectionsAfter.slice(Math.max(0, lastEvent.selectionsAfter.length - MaxSelectionsPerEvent));\n        if (sels.length && sels[sels.length - 1].eq(selection))\n            return branch;\n        sels.push(selection);\n        return updateBranch(branch, branch.length - 1, 1e9, lastEvent.setSelAfter(sels));\n    }\n}\n// Assumes the top item has one or more selectionAfter values\nfunction popSelection(branch) {\n    let last = branch[branch.length - 1];\n    let newBranch = branch.slice();\n    newBranch[branch.length - 1] = last.setSelAfter(last.selectionsAfter.slice(0, last.selectionsAfter.length - 1));\n    return newBranch;\n}\n// Add a mapping to the top event in the given branch. If this maps\n// away all the changes and effects in that item, drop it and\n// propagate the mapping to the next item.\nfunction addMappingToBranch(branch, mapping) {\n    if (!branch.length)\n        return branch;\n    let length = branch.length, selections = none;\n    while (length) {\n        let event = mapEvent(branch[length - 1], mapping, selections);\n        if (event.changes && !event.changes.empty || event.effects.length) { // Event survived mapping\n            let result = branch.slice(0, length);\n            result[length - 1] = event;\n            return result;\n        }\n        else { // Drop this event, since there's no changes or effects left\n            mapping = event.mapped;\n            length--;\n            selections = event.selectionsAfter;\n        }\n    }\n    return selections.length ? [HistEvent.selection(selections)] : none;\n}\nfunction mapEvent(event, mapping, extraSelections) {\n    let selections = conc(event.selectionsAfter.length ? event.selectionsAfter.map(s => s.map(mapping)) : none, extraSelections);\n    // Change-less events don't store mappings (they are always the last event in a branch)\n    if (!event.changes)\n        return HistEvent.selection(selections);\n    let mappedChanges = event.changes.map(mapping), before = mapping.mapDesc(event.changes, true);\n    let fullMapping = event.mapped ? event.mapped.composeDesc(before) : before;\n    return new HistEvent(mappedChanges, StateEffect.mapEffects(event.effects, mapping), fullMapping, event.startSelection.map(before), selections);\n}\nclass HistoryState {\n    constructor(done, undone, prevTime = 0, prevUserEvent = undefined) {\n        this.done = done;\n        this.undone = undone;\n        this.prevTime = prevTime;\n        this.prevUserEvent = prevUserEvent;\n    }\n    isolate() {\n        return this.prevTime ? new HistoryState(this.done, this.undone) : this;\n    }\n    addChanges(event, time, userEvent, newGroupDelay, maxLen) {\n        let done = this.done, lastEvent = done[done.length - 1];\n        if (lastEvent && lastEvent.changes &&\n            time - this.prevTime < newGroupDelay &&\n            !lastEvent.selectionsAfter.length &&\n            lastEvent.changes.length && event.changes &&\n            isAdjacent(lastEvent.changes, event.changes)) {\n            done = updateBranch(done, done.length - 1, maxLen, new HistEvent(event.changes.compose(lastEvent.changes), conc(event.effects, lastEvent.effects), lastEvent.mapped, lastEvent.startSelection, none));\n        }\n        else {\n            done = updateBranch(done, done.length, maxLen, event);\n        }\n        return new HistoryState(done, none, time, userEvent);\n    }\n    addSelection(selection, time, userEvent, newGroupDelay) {\n        let last = this.done.length ? this.done[this.done.length - 1].selectionsAfter : none;\n        if (last.length > 0 &&\n            time - this.prevTime < newGroupDelay &&\n            userEvent == \"keyboardselection\" && this.prevUserEvent == userEvent &&\n            eqSelectionShape(last[last.length - 1], selection))\n            return this;\n        return new HistoryState(addSelection(this.done, selection), this.undone, time, userEvent);\n    }\n    addMapping(mapping) {\n        return new HistoryState(addMappingToBranch(this.done, mapping), addMappingToBranch(this.undone, mapping), this.prevTime, this.prevUserEvent);\n    }\n    pop(side, state, selection) {\n        let branch = side == 0 /* Done */ ? this.done : this.undone;\n        if (branch.length == 0)\n            return null;\n        let event = branch[branch.length - 1];\n        if (selection && event.selectionsAfter.length) {\n            return state.update({\n                selection: event.selectionsAfter[event.selectionsAfter.length - 1],\n                annotations: fromHistory.of({ side, rest: popSelection(branch) })\n            });\n        }\n        else if (!event.changes) {\n            return null;\n        }\n        else {\n            let rest = branch.length == 1 ? none : branch.slice(0, branch.length - 1);\n            if (event.mapped)\n                rest = addMappingToBranch(rest, event.mapped);\n            return state.update({\n                changes: event.changes,\n                selection: event.startSelection,\n                effects: event.effects,\n                annotations: fromHistory.of({ side, rest }),\n                filter: false\n            });\n        }\n    }\n}\nHistoryState.empty = new HistoryState(none, none);\n/// Default key bindings for the undo history.\n///\n/// - Mod-z: [`undo`](#history.undo).\n/// - Mod-y (Mod-Shift-z on macOS): [`redo`](#history.redo).\n/// - Mod-u: [`undoSelection`](#history.undoSelection).\n/// - Alt-u (Mod-Shift-u on macOS): [`redoSelection`](#history.redoSelection).\nconst historyKeymap = [\n    { key: \"Mod-z\", run: undo, preventDefault: true },\n    { key: \"Mod-y\", mac: \"Mod-Shift-z\", run: redo, preventDefault: true },\n    { key: \"Mod-u\", run: undoSelection, preventDefault: true },\n    { key: \"Alt-u\", mac: \"Mod-Shift-u\", run: redoSelection, preventDefault: true }\n];\n\nexport { history, historyKeymap, invertedEffects, isolateHistory, redo, redoDepth, redoSelection, undo, undoDepth, undoSelection };\n","import { NodeProp, Tree, TreeFragment, NodeType } from 'lezer-tree';\nimport { Text, countColumn } from '@codemirror/next/text';\nimport { Facet, EditorState, StateField, StateEffect, Transaction } from '@codemirror/next/state';\nimport { ViewPlugin } from '@codemirror/next/view';\n\n/// Node prop stored in a grammar's top syntax node to provide the\n/// facet that stores language data for that language.\nconst languageDataProp = new NodeProp();\n/// Helper function to define a facet (to be added to the top syntax\n/// node(s) for a language via\n/// [`languageDataProp`](#language.languageDataProp)), that will be\n/// used to associate language data with the language. You\n/// probably only need this when subclassing\n/// [`Language`](#language.Language).\nfunction defineLanguageFacet(baseData) {\n    return Facet.define({\n        combine: baseData ? values => values.concat(baseData) : undefined\n    });\n}\n/// A language object manages parsing and per-language\n/// [metadata](#state.EditorState.languageDataAt). Parse data is\n/// managed as a [Lezer](https://lezer.codemirror.net) tree. You'll\n/// want to subclass this class for custom parsers, or use the\n/// [`LezerLanguage`](#language.LezerLanguage) or\n/// [`StreamLanguage`](#stream-parser.StreamLanguage) abstractions for\n/// [Lezer](https://lezer.codemirror.net/) or stream parsers.\nclass Language {\n    /// Construct a language object. You usually don't need to invoke\n    /// this directly. But when you do, make sure you use\n    /// [`defineLanguageFacet`](#language.defineLanguageFacet) to create\n    /// the first argument.\n    constructor(\n    /// The [language data](#state.EditorState.languageDataAt) data\n    /// facet used for this language.\n    data, parser, extraExtensions = []) {\n        this.data = data;\n        // Kludge to define EditorState.tree as a debugging helper,\n        // without the EditorState package actually knowing about\n        // languages and lezer trees.\n        if (!EditorState.prototype.hasOwnProperty(\"tree\"))\n            Object.defineProperty(EditorState.prototype, \"tree\", { get() { return syntaxTree(this); } });\n        this.parser = parser;\n        this.extension = [\n            language.of(this),\n            EditorState.languageData.of((state, pos) => state.facet(languageDataFacetAt(state, pos)))\n        ].concat(extraExtensions);\n    }\n    /// Query whether this language is active at the given position.\n    isActiveAt(state, pos) {\n        return languageDataFacetAt(state, pos) == this.data;\n    }\n    /// Find the document regions that were parsed using this language.\n    /// The returned regions will _include_ any nested languages rooted\n    /// in this language, when those exist.\n    findRegions(state) {\n        let lang = state.facet(language);\n        if ((lang === null || lang === void 0 ? void 0 : lang.data) == this.data)\n            return [{ from: 0, to: state.doc.length }];\n        if (!lang || !lang.allowsNesting)\n            return [];\n        let result = [];\n        syntaxTree(state).iterate({\n            enter: (type, from, to) => {\n                if (type.isTop && type.prop(languageDataProp) == this.data) {\n                    result.push({ from, to });\n                    return false;\n                }\n                return undefined;\n            }\n        });\n        return result;\n    }\n    /// Indicates whether this language allows nested languages. The\n    /// default implementation returns true.\n    get allowsNesting() { return true; }\n    /// Use this language to parse the given string into a tree.\n    parseString(code) {\n        let doc = Text.of(code.split(\"\\n\"));\n        let parse = this.parser.startParse(new DocInput(doc), 0, new EditorParseContext(this.parser, EditorState.create({ doc }), [], Tree.empty, { from: 0, to: code.length }, []));\n        let tree;\n        while (!(tree = parse.advance())) { }\n        return tree;\n    }\n}\n/// @internal\nLanguage.state = StateField.define({\n    create(state) {\n        let parseState = new EditorParseContext(state.facet(language).parser, state, [], Tree.empty, { from: 0, to: state.doc.length }, []);\n        if (!parseState.work(25 /* Apply */))\n            parseState.takeTree();\n        return new LanguageState(parseState);\n    },\n    update(value, tr) {\n        for (let e of tr.effects)\n            if (e.is(Language.setState))\n                return e.value;\n        return value.apply(tr);\n    }\n});\n/// @internal\nLanguage.setState = StateEffect.define();\nfunction languageDataFacetAt(state, pos) {\n    let topLang = state.facet(language);\n    if (!topLang)\n        return null;\n    if (!topLang.allowsNesting)\n        return topLang.data;\n    let tree = syntaxTree(state);\n    let target = tree.resolve(pos, -1);\n    while (target) {\n        let facet = target.type.prop(languageDataProp);\n        if (facet)\n            return facet;\n        target = target.parent;\n    }\n    return topLang.data;\n}\n/// A subclass of [`Language`](#language.Language) for use with\n/// [Lezer](https://lezer.codemirror.net/docs/ref#lezer.Parser)\n/// parsers.\nclass LezerLanguage extends Language {\n    constructor(data, parser) {\n        super(data, parser);\n        this.parser = parser;\n    }\n    /// Define a language from a parser.\n    static define(spec) {\n        let data = defineLanguageFacet(spec.languageData);\n        return new LezerLanguage(data, spec.parser.configure({\n            props: [languageDataProp.add(type => type.isTop ? data : undefined)]\n        }));\n    }\n    /// Create a new instance of this language with a reconfigured\n    /// version of its parser.\n    configure(options) {\n        return new LezerLanguage(this.data, this.parser.configure(options));\n    }\n    get allowsNesting() { return this.parser.hasNested; }\n}\n/// Get the syntax tree for a state, which is the current (possibly\n/// incomplete) parse tree of active [language](#language.Language),\n/// or the empty tree if there is no language available.\nfunction syntaxTree(state) {\n    let field = state.field(Language.state, false);\n    return field ? field.tree : Tree.empty;\n}\n/// Try to get a parse tree that spans at least up to `upto`. The\n/// method will do at most `timeout` milliseconds of work to parse\n/// up to that point if the tree isn't already available.\nfunction ensureSyntaxTree(state, upto, timeout = 50) {\n    var _a;\n    let parse = (_a = state.field(Language.state, false)) === null || _a === void 0 ? void 0 : _a.context;\n    return !parse ? null : parse.tree.length >= upto || parse.work(timeout, upto) ? parse.tree : null;\n}\n// Lezer-style Input object for a Text document.\nclass DocInput {\n    constructor(doc, length = doc.length) {\n        this.doc = doc;\n        this.length = length;\n        this.cursorPos = 0;\n        this.string = \"\";\n        this.prevString = \"\";\n        this.cursor = doc.iter();\n    }\n    syncTo(pos) {\n        if (pos < this.cursorPos) { // Reset the cursor if we have to go back\n            this.cursor = this.doc.iter();\n            this.cursorPos = 0;\n        }\n        this.prevString = pos == this.cursorPos ? this.string : \"\";\n        this.string = this.cursor.next(pos - this.cursorPos).value;\n        this.cursorPos = pos + this.string.length;\n        return this.cursorPos - this.string.length;\n    }\n    get(pos) {\n        if (pos >= this.length)\n            return -1;\n        let stringStart = this.cursorPos - this.string.length;\n        if (pos < stringStart || pos >= this.cursorPos) {\n            if (pos < stringStart && pos >= stringStart - this.prevString.length)\n                return this.prevString.charCodeAt(pos - (stringStart - this.prevString.length));\n            stringStart = this.syncTo(pos);\n        }\n        return this.string.charCodeAt(pos - stringStart);\n    }\n    lineAfter(pos) {\n        if (pos >= this.length || pos < 0)\n            return \"\";\n        let stringStart = this.cursorPos - this.string.length;\n        if (pos < stringStart || pos >= this.cursorPos)\n            stringStart = this.syncTo(pos);\n        return this.cursor.lineBreak ? \"\" : this.string.slice(pos - stringStart);\n    }\n    read(from, to) {\n        let stringStart = this.cursorPos - this.string.length;\n        if (from < stringStart || to >= this.cursorPos)\n            return this.doc.sliceString(from, to);\n        else\n            return this.string.slice(from - stringStart, to - stringStart);\n    }\n    clip(at) {\n        return new DocInput(this.doc, at);\n    }\n}\n/// A parse context provided to parsers working on the editor content.\nclass EditorParseContext {\n    /// @internal\n    constructor(parser, \n    /// The current editor state.\n    state, \n    /// Tree fragments that can be reused by incremental re-parses.\n    fragments = [], \n    /// @internal\n    tree, \n    /// The current editor viewport (or some overapproximation\n    /// thereof). Intended to be used for opportunistically avoiding\n    /// work (in which case\n    /// [`skipUntilInView`](#language.EditorParseContext.skipUntilInView)\n    /// should be called to make sure the parser is restarted when the\n    /// skipped region becomes visible).\n    viewport, \n    /// @internal\n    skipped) {\n        this.parser = parser;\n        this.state = state;\n        this.fragments = fragments;\n        this.tree = tree;\n        this.viewport = viewport;\n        this.skipped = skipped;\n        this.parse = null;\n        /// @internal\n        this.tempSkipped = [];\n    }\n    /// @internal\n    work(time, upto) {\n        if (this.tree != Tree.empty && (upto == null ? this.tree.length == this.state.doc.length : this.tree.length >= upto))\n            return true;\n        if (!this.parse)\n            this.parse = this.parser.startParse(new DocInput(this.state.doc), 0, this);\n        let endTime = Date.now() + time;\n        for (;;) {\n            let done = this.parse.advance();\n            if (done) {\n                this.fragments = this.withoutTempSkipped(TreeFragment.addTree(done));\n                this.parse = null;\n                this.tree = done;\n                return true;\n            }\n            else if (upto != null && this.parse.pos >= upto) {\n                this.takeTree();\n                return true;\n            }\n            if (Date.now() > endTime)\n                return false;\n        }\n    }\n    /// @internal\n    takeTree() {\n        if (this.parse && this.parse.pos > this.tree.length) {\n            this.tree = this.parse.forceFinish();\n            this.fragments = this.withoutTempSkipped(TreeFragment.addTree(this.tree, this.fragments, true));\n        }\n    }\n    withoutTempSkipped(fragments) {\n        for (let r; r = this.tempSkipped.pop();)\n            fragments = cutFragments(fragments, r.from, r.to);\n        return fragments;\n    }\n    /// @internal\n    changes(changes, newState) {\n        let { fragments, tree, viewport, skipped } = this;\n        this.takeTree();\n        if (!changes.empty) {\n            let ranges = [];\n            changes.iterChangedRanges((fromA, toA, fromB, toB) => ranges.push({ fromA, toA, fromB, toB }));\n            fragments = TreeFragment.applyChanges(fragments, ranges);\n            tree = Tree.empty;\n            viewport = { from: changes.mapPos(viewport.from, -1), to: changes.mapPos(viewport.to, 1) };\n            if (this.skipped.length) {\n                skipped = [];\n                for (let r of this.skipped) {\n                    let from = changes.mapPos(r.from, 1), to = changes.mapPos(r.to, -1);\n                    if (from < to)\n                        skipped.push({ from, to });\n                }\n            }\n        }\n        return new EditorParseContext(this.parser, newState, fragments, tree, viewport, skipped);\n    }\n    /// @internal\n    updateViewport(viewport) {\n        this.viewport = viewport;\n        let startLen = this.skipped.length;\n        for (let i = 0; i < this.skipped.length; i++) {\n            let { from, to } = this.skipped[i];\n            if (from < viewport.to && to > viewport.from) {\n                this.fragments = cutFragments(this.fragments, from, to);\n                this.skipped.splice(i--, 1);\n            }\n        }\n        return this.skipped.length < startLen;\n    }\n    /// @internal\n    reset() {\n        if (this.parse) {\n            this.takeTree();\n            this.parse = null;\n        }\n    }\n    /// Notify the parse scheduler that the given region was skipped\n    /// because it wasn't in view, and the parse should be restarted\n    /// when it comes into view.\n    skipUntilInView(from, to) {\n        this.skipped.push({ from, to });\n    }\n}\n/// A parser intended to be used as placeholder when asynchronously\n/// loading a nested parser. It'll skip its input and mark it as\n/// not-really-parsed, so that the next update will parse it again.\nEditorParseContext.skippingParser = {\n    startParse(input, startPos, context) {\n        return {\n            pos: startPos,\n            advance() {\n                context.tempSkipped.push({ from: startPos, to: input.length });\n                this.pos = input.length;\n                return new Tree(NodeType.none, [], [], input.length - startPos);\n            },\n            forceFinish() { return this.advance(); }\n        };\n    }\n};\nfunction cutFragments(fragments, from, to) {\n    return TreeFragment.applyChanges(fragments, [{ fromA: from, toA: to, fromB: from, toB: to }]);\n}\nclass LanguageState {\n    constructor(\n    // A mutable parse state that is used to preserve work done during\n    // the lifetime of a state when moving to the next state.\n    context) {\n        this.context = context;\n        this.tree = context.tree;\n    }\n    apply(tr) {\n        if (!tr.docChanged)\n            return this;\n        let newCx = this.context.changes(tr.changes, tr.state);\n        // If the previous parse wasn't done, go forward only up to its\n        // end position or the end of the viewport, to avoid slowing down\n        // state updates with parse work beyond the viewport.\n        let upto = this.context.tree.length == tr.startState.doc.length ? undefined\n            : Math.max(tr.changes.mapPos(this.context.tree.length), newCx.viewport.to);\n        if (!newCx.work(25 /* Apply */, upto))\n            newCx.takeTree();\n        return new LanguageState(newCx);\n    }\n}\nlet requestIdle = typeof window != \"undefined\" && window.requestIdleCallback ||\n    ((callback, { timeout }) => setTimeout(callback, timeout));\nlet cancelIdle = typeof window != \"undefined\" && window.cancelIdleCallback || clearTimeout;\nconst parseWorker = ViewPlugin.fromClass(class ParseWorker {\n    constructor(view) {\n        this.view = view;\n        this.working = -1;\n        // End of the current time chunk\n        this.chunkEnd = -1;\n        // Milliseconds of budget left for this chunk\n        this.chunkBudget = -1;\n        this.work = this.work.bind(this);\n        this.scheduleWork();\n    }\n    update(update) {\n        if (update.docChanged) {\n            if (this.view.hasFocus)\n                this.chunkBudget += 50 /* ChangeBonus */;\n            this.scheduleWork();\n        }\n        let cx = this.view.state.field(Language.state).context;\n        if (update.viewportChanged && cx.updateViewport(update.view.viewport)) {\n            cx.reset();\n            this.scheduleWork();\n        }\n    }\n    scheduleWork() {\n        if (this.working > -1)\n            return;\n        let { state } = this.view, field = state.field(Language.state);\n        if (field.tree.length >= state.doc.length)\n            return;\n        this.working = requestIdle(this.work, { timeout: 500 /* Pause */ });\n    }\n    work(deadline) {\n        this.working = -1;\n        let now = Date.now();\n        if (this.chunkEnd < now && this.view.hasFocus) { // Start a new chunk\n            this.chunkEnd = now + 30000 /* ChunkTime */;\n            this.chunkBudget = 3000 /* ChunkBudget */;\n        }\n        if (this.chunkBudget <= 0)\n            return; // No more budget\n        let { state } = this.view, field = state.field(Language.state);\n        if (field.tree.length >= state.doc.length)\n            return;\n        let time = Math.min(this.chunkBudget, deadline ? Math.max(25 /* MinSlice */, deadline.timeRemaining()) : 100 /* Slice */);\n        field.context.work(time);\n        this.chunkBudget -= Date.now() - now;\n        if (field.context.tree.length >= state.doc.length) {\n            this.view.dispatch({ effects: Language.setState.of(new LanguageState(field.context)) });\n        }\n        else {\n            this.scheduleWork();\n        }\n    }\n    destroy() {\n        if (this.working >= 0)\n            cancelIdle(this.working);\n    }\n}, {\n    eventHandlers: { focus() { this.scheduleWork(); } }\n});\n/// The facet used to associate a language with an editor state.\nconst language = Facet.define({\n    combine(languages) { return languages.length ? languages[0] : null; },\n    enables: [Language.state, parseWorker]\n});\n/// This class bundles a [language object](#language.Language) with an\n/// optional set of supporting extensions. Language packages are\n/// encouraged to export a function that optionally takes a\n/// configuration object and returns a `LanguageSupport` instance, as\n/// the main way for client code to use the package.\nclass LanguageSupport {\n    /// Create a support object.\n    constructor(\n    /// The language object.\n    language, \n    /// An optional set of supporting extensions. When nesting a\n    /// language in another language, the outer language is encouraged\n    /// to include the supporting extensions for its inner languages\n    /// in its own set of support extensions.\n    support = []) {\n        this.language = language;\n        this.support = support;\n        this.extension = [language, support];\n    }\n}\n/// Language descriptions are used to store metadata about languages\n/// and to dynamically load them. Their main role is finding the\n/// appropriate language for a filename or dynamically loading nested\n/// parsers.\nclass LanguageDescription {\n    constructor(\n    /// The name of this language.\n    name, \n    /// Alternative names for the mode (lowercased, includes `this.name`).\n    alias, \n    /// File extensions associated with this language.\n    extensions, \n    /// Optional filename pattern that should be associated with this\n    /// language.\n    filename, loadFunc) {\n        this.name = name;\n        this.alias = alias;\n        this.extensions = extensions;\n        this.filename = filename;\n        this.loadFunc = loadFunc;\n        /// If the language has been loaded, this will hold its value.\n        this.support = undefined;\n        this.loading = null;\n    }\n    /// Start loading the the language. Will return a promise that\n    /// resolves to a [`LanguageSupport`](#language.LanguageSupport)\n    /// object when the language successfully loads.\n    load() {\n        return this.loading || (this.loading = this.loadFunc().then(support => this.support = support, err => { this.loading = null; throw err; }));\n    }\n    /// Create a language description.\n    static of(spec) {\n        return new LanguageDescription(spec.name, (spec.alias || []).concat(spec.name).map(s => s.toLowerCase()), spec.extensions || [], spec.filename, spec.load);\n    }\n    /// Look for a language in the given array of descriptions that\n    /// matches the filename. Will first match\n    /// [`filename`](#language.LanguageDescription.filename) patterns,\n    /// and then [extensions](#language.LanguageDescription.extensions),\n    /// and return the first language that matches.\n    static matchFilename(descs, filename) {\n        for (let d of descs)\n            if (d.filename && d.filename.test(filename))\n                return d;\n        let ext = /\\.([^.]+)$/.exec(filename);\n        if (ext)\n            for (let d of descs)\n                if (d.extensions.indexOf(ext[1]) > -1)\n                    return d;\n        return null;\n    }\n    /// Look for a language whose name or alias matches the the given\n    /// name (case-insensitively). If `fuzzy` is true, and no direct\n    /// matchs is found, this'll also search for a language whose name\n    /// or alias occurs in the string (for names shorter than three\n    /// characters, only when surrounded by non-word characters).\n    static matchLanguageName(descs, name, fuzzy = true) {\n        name = name.toLowerCase();\n        for (let d of descs)\n            if (d.alias.some(a => a == name))\n                return d;\n        if (fuzzy)\n            for (let d of descs)\n                for (let a of d.alias) {\n                    let found = name.indexOf(a);\n                    if (found > -1 && (a.length > 2 || !/\\w/.test(name[found - 1]) && !/\\w/.test(name[found + a.length])))\n                        return d;\n                }\n        return null;\n    }\n}\n\n/// Facet that defines a way to provide a function that computes the\n/// appropriate indentation depth at the start of a given line, or\n/// `null` to indicate no appropriate indentation could be determined.\nconst indentService = Facet.define();\n/// Facet for overriding the unit by which indentation happens.\n/// Should be a string consisting either entirely of spaces or\n/// entirely of tabs. When not set, this defaults to 2 spaces.\nconst indentUnit = Facet.define({\n    combine: values => {\n        if (!values.length)\n            return \"  \";\n        if (!/^(?: +|\\t+)$/.test(values[0]))\n            throw new Error(\"Invalid indent unit: \" + JSON.stringify(values[0]));\n        return values[0];\n    }\n});\n/// Return the _column width_ of an indent unit in the state.\n/// Determined by the [`indentUnit`](#language.indentUnit)\n/// facet, and [`tabSize`](#state.EditorState^tabSize) when that\n/// contains tabs.\nfunction getIndentUnit(state) {\n    let unit = state.facet(indentUnit);\n    return unit.charCodeAt(0) == 9 ? state.tabSize * unit.length : unit.length;\n}\n/// Create an indentation string that covers columns 0 to `cols`.\n/// Will use tabs for as much of the columns as possible when the\n/// [`indentUnit`](#language.indentUnit) facet contains\n/// tabs.\nfunction indentString(state, cols) {\n    let result = \"\", ts = state.tabSize;\n    if (state.facet(indentUnit).charCodeAt(0) == 9)\n        while (cols >= ts) {\n            result += \"\\t\";\n            cols -= ts;\n        }\n    for (let i = 0; i < cols; i++)\n        result += \" \";\n    return result;\n}\n/// Get the indentation at the given position. Will first consult any\n/// [indent services](#language.indentService) that are registered,\n/// and if none of those return an indentation, this will check the\n/// syntax tree for the [indent node prop](#language.indentNodeProp)\n/// and use that if found. Returns a number when an indentation could\n/// be determined, and null otherwise.\nfunction getIndentation(context, pos) {\n    if (context instanceof EditorState)\n        context = new IndentContext(context);\n    for (let service of context.state.facet(indentService)) {\n        let result = service(context, pos);\n        if (result != null)\n            return result;\n    }\n    let tree = syntaxTree(context.state);\n    return tree ? syntaxIndentation(context, tree, pos) : null;\n}\n/// Indentation contexts are used when calling [indentation\n/// services](#language.indentService). They provide helper utilities\n/// useful in indentation logic, and can selectively override the\n/// indentation reported for some lines.\nclass IndentContext {\n    /// Create an indent context.\n    constructor(\n    /// The editor state.\n    state, \n    /// @internal\n    options = {}) {\n        this.state = state;\n        this.options = options;\n        this.unit = getIndentUnit(state);\n    }\n    /// Get the text directly after `pos`, either the entire line\n    /// or the next 100 characters, whichever is shorter.\n    textAfterPos(pos) {\n        var _a, _b;\n        let sim = (_a = this.options) === null || _a === void 0 ? void 0 : _a.simulateBreak;\n        if (pos == sim && ((_b = this.options) === null || _b === void 0 ? void 0 : _b.simulateDoubleBreak))\n            return \"\";\n        return this.state.sliceDoc(pos, Math.min(pos + 100, sim != null && sim > pos ? sim : 1e9, this.state.doc.lineAt(pos).to));\n    }\n    /// Find the column for the given position.\n    column(pos) {\n        var _a;\n        let line = this.state.doc.lineAt(pos), text = line.text.slice(0, pos - line.from);\n        let result = this.countColumn(text, pos - line.from);\n        let override = ((_a = this.options) === null || _a === void 0 ? void 0 : _a.overrideIndentation) ? this.options.overrideIndentation(line.from) : -1;\n        if (override > -1)\n            result += override - this.countColumn(text, text.search(/\\S/));\n        return result;\n    }\n    /// find the column position (taking tabs into account) of the given\n    /// position in the given string.\n    countColumn(line, pos) {\n        return countColumn(pos < 0 ? line : line.slice(0, pos), 0, this.state.tabSize);\n    }\n    /// Find the indentation column of the given document line.\n    lineIndent(line) {\n        var _a;\n        let override = (_a = this.options) === null || _a === void 0 ? void 0 : _a.overrideIndentation;\n        if (override) {\n            let overriden = override(line.from);\n            if (overriden > -1)\n                return overriden;\n        }\n        return this.countColumn(line.text, line.text.search(/\\S/));\n    }\n}\n/// A syntax tree node prop used to associate indentation strategies\n/// with node types. Such a strategy is a function from an indentation\n/// context to a column number or null, where null indicates that no\n/// definitive indentation can be determined.\nconst indentNodeProp = new NodeProp();\n// Compute the indentation for a given position from the syntax tree.\nfunction syntaxIndentation(cx, ast, pos) {\n    let tree = ast.resolve(pos);\n    // Enter previous nodes that end in empty error terms, which means\n    // they were broken off by error recovery, so that indentation\n    // works even if the constructs haven't been finished.\n    for (let scan = tree, scanPos = pos;;) {\n        let last = scan.childBefore(scanPos);\n        if (!last)\n            break;\n        if (last.type.isError && last.from == last.to) {\n            tree = scan;\n            scanPos = last.from;\n        }\n        else {\n            scan = last;\n            scanPos = scan.to + 1;\n        }\n    }\n    for (; tree; tree = tree.parent) {\n        let strategy = indentStrategy(tree);\n        if (strategy)\n            return strategy(new TreeIndentContext(cx, pos, tree));\n    }\n    return null;\n}\nfunction ignoreClosed(cx) {\n    var _a, _b;\n    return cx.pos == ((_a = cx.options) === null || _a === void 0 ? void 0 : _a.simulateBreak) && ((_b = cx.options) === null || _b === void 0 ? void 0 : _b.simulateDoubleBreak);\n}\nfunction indentStrategy(tree) {\n    let strategy = tree.type.prop(indentNodeProp);\n    if (strategy)\n        return strategy;\n    let first = tree.firstChild, close;\n    if (first && (close = first.type.prop(NodeProp.closedBy))) {\n        let last = tree.lastChild, closed = last && close.indexOf(last.name) > -1;\n        return cx => delimitedStrategy(cx, true, 1, undefined, closed && !ignoreClosed(cx) ? last.from : undefined);\n    }\n    return tree.parent == null ? topIndent : null;\n}\nfunction topIndent() { return 0; }\n/// Objects of this type provide context information and helper\n/// methods to indentation functions.\nclass TreeIndentContext extends IndentContext {\n    /// @internal\n    constructor(base, \n    /// The position at which indentation is being computed.\n    pos, \n    /// The syntax tree node to which the indentation strategy\n    /// applies.\n    node) {\n        super(base.state, base.options);\n        this.pos = pos;\n        this.node = node;\n    }\n    /// Get the text directly after `this.pos`, either the entire line\n    /// or the next 100 characters, whichever is shorter.\n    get textAfter() {\n        return this.textAfterPos(this.pos);\n    }\n    /// Get the indentation at the reference line for `this.node`, which\n    /// is the line on which it starts, unless there is a node that is\n    /// _not_ a parent of this node covering the start of that line. If\n    /// so, the line at the start of that node is tried, again skipping\n    /// on if it is covered by another such node.\n    get baseIndent() {\n        let line = this.state.doc.lineAt(this.node.from);\n        // Skip line starts that are covered by a sibling (or cousin, etc)\n        for (;;) {\n            let atBreak = this.node.resolve(line.from);\n            while (atBreak.parent && atBreak.parent.from == atBreak.from)\n                atBreak = atBreak.parent;\n            if (isParent(atBreak, this.node))\n                break;\n            line = this.state.doc.lineAt(atBreak.from);\n        }\n        return this.lineIndent(line);\n    }\n}\nfunction isParent(parent, of) {\n    for (let cur = of; cur; cur = cur.parent)\n        if (parent == cur)\n            return true;\n    return false;\n}\n// Check whether a delimited node is aligned (meaning there are\n// non-skipped nodes on the same line as the opening delimiter). And\n// if so, return the opening token.\nfunction bracketedAligned(context) {\n    var _a;\n    let tree = context.node;\n    let openToken = tree.childAfter(tree.from), last = tree.lastChild;\n    if (!openToken)\n        return null;\n    let sim = (_a = context.options) === null || _a === void 0 ? void 0 : _a.simulateBreak;\n    let openLine = context.state.doc.lineAt(openToken.from);\n    let lineEnd = sim == null || sim <= openLine.from ? openLine.to : Math.min(openLine.to, sim);\n    for (let pos = openToken.to;;) {\n        let next = tree.childAfter(pos);\n        if (!next || next == last)\n            return null;\n        if (!next.type.isSkipped)\n            return next.from < lineEnd ? openToken : null;\n        pos = next.to;\n    }\n}\n/// An indentation strategy for delimited (usually bracketed) nodes.\n/// Will, by default, indent one unit more than the parent's base\n/// indent unless the line starts with a closing token. When `align`\n/// is true and there are non-skipped nodes on the node's opening\n/// line, the content of the node will be aligned with the end of the\n/// opening node, like this:\n///\n///     foo(bar,\n///         baz)\nfunction delimitedIndent({ closing, align = true, units = 1 }) {\n    return (context) => delimitedStrategy(context, align, units, closing);\n}\nfunction delimitedStrategy(context, align, units, closing, closedAt) {\n    let after = context.textAfter, space = after.match(/^\\s*/)[0].length;\n    let closed = closing && after.slice(space, space + closing.length) == closing || closedAt == context.pos + space;\n    let aligned = align ? bracketedAligned(context) : null;\n    if (aligned)\n        return closed ? context.column(aligned.from) : context.column(aligned.to);\n    return context.baseIndent + (closed ? 0 : context.unit * units);\n}\n/// An indentation strategy that aligns a node's content to its base\n/// indentation.\nconst flatIndent = (context) => context.baseIndent;\n/// Creates an indentation strategy that, by default, indents\n/// continued lines one unit more than the node's base indentation.\n/// You can provide `except` to prevent indentation of lines that\n/// match a pattern (for example `/^else\\b/` in `if`/`else`\n/// constructs), and you can change the amount of units used with the\n/// `units` option.\nfunction continuedIndent({ except, units = 1 } = {}) {\n    return (context) => {\n        let matchExcept = except && except.test(context.textAfter);\n        return context.baseIndent + (matchExcept ? 0 : units * context.unit);\n    };\n}\nconst DontIndentBeyond = 200;\n/// Enables reindentation on input. When a language defines an\n/// `indentOnInput` field in its [language\n/// data](#state.EditorState.languageDataAt), which must hold a regular\n/// expression, the line at the cursor will be reindented whenever new\n/// text is typed and the input from the start of the line up to the\n/// cursor matches that regexp.\n///\n/// To avoid unneccesary reindents, it is recommended to start the\n/// regexp with `^` (usually followed by `\\s*`), and end it with `$`.\n/// For example, `/^\\s*\\}$/` will reindent when a closing brace is\n/// added at the start of a line.\nfunction indentOnInput() {\n    return EditorState.transactionFilter.of(tr => {\n        if (!tr.docChanged || tr.annotation(Transaction.userEvent) != \"input\")\n            return tr;\n        let rules = tr.startState.languageDataAt(\"indentOnInput\", tr.startState.selection.main.head);\n        if (!rules.length)\n            return tr;\n        let doc = tr.newDoc, { head } = tr.newSelection.main, line = doc.lineAt(head);\n        if (head > line.from + DontIndentBeyond)\n            return tr;\n        let lineStart = doc.sliceString(line.from, head);\n        if (!rules.some(r => r.test(lineStart)))\n            return tr;\n        let { state } = tr, last = -1, changes = [];\n        for (let { head } of state.selection.ranges) {\n            let line = state.doc.lineAt(head);\n            if (line.from == last)\n                continue;\n            last = line.from;\n            let indent = getIndentation(state, line.from);\n            if (indent == null)\n                continue;\n            let cur = /^\\s*/.exec(line.text)[0];\n            let norm = indentString(state, indent);\n            if (cur != norm)\n                changes.push({ from: line.from, to: line.from + cur.length, insert: norm });\n        }\n        return changes.length ? [tr, { changes }] : tr;\n    });\n}\n\n/// A facet that registers a code folding service. When called with\n/// the extent of a line, such a function should return a foldable\n/// range that starts on that line (but continues beyond it), if one\n/// can be found.\nconst foldService = Facet.define();\n/// This node prop is used to associate folding information with\n/// syntax node types. Given a syntax node, it should check whether\n/// that tree is foldable and return the range that can be collapsed\n/// when it is.\nconst foldNodeProp = new NodeProp();\nfunction syntaxFolding(state, start, end) {\n    let tree = syntaxTree(state);\n    if (tree.length == 0)\n        return null;\n    let inner = tree.resolve(end);\n    let found = null;\n    for (let cur = inner; cur; cur = cur.parent) {\n        if (cur.to <= end || cur.from > end)\n            continue;\n        if (found && cur.from < start)\n            break;\n        let prop = cur.type.prop(foldNodeProp);\n        if (prop) {\n            let value = prop(cur, state);\n            if (value && value.from <= end && value.from >= start && value.to > end)\n                found = value;\n        }\n    }\n    return found;\n}\n/// Check whether the given line is foldable. First asks any fold\n/// services registered through\n/// [`foldService`](#language.foldService), and if none of them return\n/// a result, tries to query the [fold node\n/// prop](#language.foldNodeProp) of syntax nodes that cover the end\n/// of the line.\nfunction foldable(state, lineStart, lineEnd) {\n    for (let service of state.facet(foldService)) {\n        let result = service(state, lineStart, lineEnd);\n        if (result)\n            return result;\n    }\n    return syntaxFolding(state, lineStart, lineEnd);\n}\n\nexport { EditorParseContext, IndentContext, Language, LanguageDescription, LanguageSupport, LezerLanguage, TreeIndentContext, continuedIndent, defineLanguageFacet, delimitedIndent, ensureSyntaxTree, flatIndent, foldNodeProp, foldService, foldable, getIndentUnit, getIndentation, indentNodeProp, indentOnInput, indentService, indentString, indentUnit, language, languageDataProp, syntaxTree };\n","import { EditorView, Decoration, themeClass, ViewPlugin, logException, WidgetType } from '@codemirror/next/view';\nimport { StateEffect, StateField } from '@codemirror/next/state';\nimport { hoverTooltip } from '@codemirror/next/tooltip';\nimport { panels, showPanel, getPanel } from '@codemirror/next/panel';\nimport elt from 'crelt';\n\nclass SelectedDiagnostic {\n    constructor(from, to, diagnostic) {\n        this.from = from;\n        this.to = to;\n        this.diagnostic = diagnostic;\n    }\n}\nclass LintState {\n    constructor(diagnostics, panel, selected) {\n        this.diagnostics = diagnostics;\n        this.panel = panel;\n        this.selected = selected;\n    }\n}\nfunction findDiagnostic(diagnostics, diagnostic = null, after = 0) {\n    let found = null;\n    diagnostics.between(after, diagnostics.length, (from, to, { spec }) => {\n        if (diagnostic && spec.diagnostic != diagnostic)\n            return;\n        found = new SelectedDiagnostic(from, to, spec.diagnostic);\n        return false;\n    });\n    return found;\n}\nfunction maybeEnableLint(state) {\n    return state.field(lintState, false) ? undefined : { append: [\n            lintState,\n            EditorView.decorations.compute([lintState], state => {\n                let { selected, panel } = state.field(lintState);\n                return !selected || !panel || selected.from == selected.to ? Decoration.none : Decoration.set([\n                    activeMark.range(selected.from, selected.to)\n                ]);\n            }),\n            panels(),\n            hoverTooltip(lintTooltip),\n            baseTheme\n        ] };\n}\n/// State effect that is used to update the current set of\n/// diagnostics.\nfunction setDiagnostics(state, diagnostics) {\n    return {\n        effects: setDiagnosticsEffect.of(diagnostics),\n        reconfigure: maybeEnableLint(state)\n    };\n}\nconst setDiagnosticsEffect = StateEffect.define();\nconst togglePanel = StateEffect.define();\nconst movePanelSelection = StateEffect.define();\nconst lintState = StateField.define({\n    create() {\n        return new LintState(Decoration.none, null, null);\n    },\n    update(value, tr) {\n        if (tr.docChanged) {\n            let mapped = value.diagnostics.map(tr.changes), selected = null;\n            if (value.selected) {\n                let selPos = tr.changes.mapPos(value.selected.from, 1);\n                selected = findDiagnostic(mapped, value.selected.diagnostic, selPos) || findDiagnostic(mapped, null, selPos);\n            }\n            value = new LintState(mapped, value.panel, selected);\n        }\n        for (let effect of tr.effects) {\n            if (effect.is(setDiagnosticsEffect)) {\n                let ranges = Decoration.set(effect.value.map((d) => {\n                    return d.from < d.to\n                        ? Decoration.mark({\n                            attributes: { class: themeClass(\"lintRange.\" + d.severity) },\n                            diagnostic: d\n                        }).range(d.from, d.to)\n                        : Decoration.widget({\n                            widget: new DiagnosticWidget(d),\n                            diagnostic: d\n                        }).range(d.from);\n                }));\n                value = new LintState(ranges, value.panel, findDiagnostic(ranges));\n            }\n            else if (effect.is(togglePanel)) {\n                value = new LintState(value.diagnostics, effect.value ? LintPanel.open : null, value.selected);\n            }\n            else if (effect.is(movePanelSelection)) {\n                value = new LintState(value.diagnostics, value.panel, effect.value);\n            }\n        }\n        return value;\n    },\n    provide: f => [showPanel.computeN([f], s => { let { panel } = s.field(f); return panel ? [panel] : []; }),\n        EditorView.decorations.from(f, s => s.diagnostics)]\n});\nconst activeMark = Decoration.mark({ class: themeClass(\"lintRange.active\") });\nfunction lintTooltip(view, pos, side) {\n    let { diagnostics } = view.state.field(lintState);\n    let found = [], stackStart = 2e8, stackEnd = 0;\n    diagnostics.between(pos - (side < 0 ? 1 : 0), pos + (side > 0 ? 1 : 0), (from, to, { spec }) => {\n        if (pos >= from && pos <= to &&\n            (from == to || ((pos > from || side > 0) && (pos < to || side < 0)))) {\n            found.push(spec.diagnostic);\n            stackStart = Math.min(from, stackStart);\n            stackEnd = Math.max(to, stackEnd);\n        }\n    });\n    if (!found.length)\n        return null;\n    return {\n        pos: stackStart,\n        end: stackEnd,\n        above: view.state.doc.lineAt(stackStart).to < stackEnd,\n        style: \"lint\",\n        create() {\n            return { dom: elt(\"ul\", found.map(d => renderDiagnostic(view, d, false))) };\n        }\n    };\n}\n/// Command to open and focus the lint panel.\nconst openLintPanel = (view) => {\n    let field = view.state.field(lintState, false);\n    if (!field || !field.panel)\n        view.dispatch({ effects: togglePanel.of(true),\n            reconfigure: maybeEnableLint(view.state) });\n    let panel = getPanel(view, LintPanel.open);\n    if (panel)\n        panel.dom.querySelector(\".cm-panel-lint ul\").focus();\n    return true;\n};\n/// Command to close the lint panel, when open.\nconst closeLintPanel = (view) => {\n    let field = view.state.field(lintState, false);\n    if (!field || !field.panel)\n        return false;\n    view.dispatch({ effects: togglePanel.of(false) });\n    return true;\n};\n/// Move the selection to the next diagnostic.\nconst nextDiagnostic = (view) => {\n    let field = view.state.field(lintState, false);\n    if (!field)\n        return false;\n    let sel = view.state.selection.main, next = field.diagnostics.iter(sel.to + 1);\n    if (!next.value) {\n        next = field.diagnostics.iter(0);\n        if (!next.value || next.from == sel.from && next.to == sel.to)\n            return false;\n    }\n    view.dispatch({ selection: { anchor: next.from, head: next.to }, scrollIntoView: true });\n    return true;\n};\n/// A set of default key bindings for the lint functionality.\n///\n/// - Ctrl-Shift-m (Cmd-Shift-m on macOS): [`openLintPanel`](#lint.openLintPanel)\n/// - F8: [`nextDiagnostic`](#lint.nextDiagnostic)\nconst lintKeymap = [\n    { key: \"Mod-Shift-m\", run: openLintPanel },\n    { key: \"F8\", run: nextDiagnostic }\n];\nconst LintDelay = 500;\n/// Given a diagnostic source, this function returns an extension that\n/// enables linting with that source. It will be called whenever the\n/// editor is idle (after its content changed).\nfunction linter(source) {\n    return ViewPlugin.fromClass(class {\n        constructor(view) {\n            this.view = view;\n            this.lintTime = Date.now() + LintDelay;\n            this.set = true;\n            this.run = this.run.bind(this);\n            setTimeout(this.run, LintDelay);\n        }\n        run() {\n            let now = Date.now();\n            if (now < this.lintTime - 10) {\n                setTimeout(this.run, this.lintTime - now);\n            }\n            else {\n                this.set = false;\n                let { state } = this.view;\n                Promise.resolve(source(this.view)).then(annotations => {\n                    var _a, _b;\n                    if (this.view.state.doc == state.doc &&\n                        (annotations.length || ((_b = (_a = this.view.state.field(lintState, false)) === null || _a === void 0 ? void 0 : _a.diagnostics) === null || _b === void 0 ? void 0 : _b.size)))\n                        this.view.dispatch(setDiagnostics(this.view.state, annotations));\n                }, error => { logException(this.view.state, error); });\n            }\n        }\n        update(update) {\n            if (update.docChanged) {\n                this.lintTime = Date.now() + LintDelay;\n                if (!this.set) {\n                    this.set = true;\n                    setTimeout(this.run, LintDelay);\n                }\n            }\n        }\n    });\n}\nfunction assignKeys(actions) {\n    let assigned = [];\n    if (actions)\n        actions: for (let { name } of actions) {\n            for (let i = 0; i < name.length; i++) {\n                let ch = name[i];\n                if (/[a-zA-Z]/.test(ch) && !assigned.some(c => c.toLowerCase() == ch.toLowerCase())) {\n                    assigned.push(ch);\n                    continue actions;\n                }\n            }\n            assigned.push(\"\");\n        }\n    return assigned;\n}\nfunction renderDiagnostic(view, diagnostic, inPanel) {\n    var _a;\n    let keys = inPanel ? assignKeys(diagnostic.actions) : [];\n    return elt(\"li\", { class: themeClass(\"diagnostic.\" + diagnostic.severity) }, elt(\"span\", { class: themeClass(\"diagnosticText\") }, diagnostic.message), (_a = diagnostic.actions) === null || _a === void 0 ? void 0 : _a.map((action, i) => {\n        let click = (e) => {\n            e.preventDefault();\n            let found = findDiagnostic(view.state.field(lintState).diagnostics, diagnostic);\n            if (found)\n                action.apply(view, found.from, found.to);\n        };\n        let { name } = action, keyIndex = keys[i] ? name.indexOf(keys[i]) : -1;\n        let nameElt = keyIndex < 0 ? name : [name.slice(0, keyIndex),\n            elt(\"u\", name.slice(keyIndex, keyIndex + 1)),\n            name.slice(keyIndex + 1)];\n        return elt(\"button\", {\n            class: themeClass(\"diagnosticAction\"),\n            onclick: click,\n            onmousedown: click\n        }, nameElt);\n    }), diagnostic.source && elt(\"div\", { class: themeClass(\"diagnosticSource\") }, diagnostic.source));\n}\nclass DiagnosticWidget extends WidgetType {\n    constructor(diagnostic) {\n        super();\n        this.diagnostic = diagnostic;\n    }\n    eq(other) { return other.diagnostic == this.diagnostic; }\n    toDOM() {\n        return elt(\"span\", { class: themeClass(\"lintPoint.\" + this.diagnostic.severity) });\n    }\n}\nclass PanelItem {\n    constructor(view, diagnostic) {\n        this.diagnostic = diagnostic;\n        this.id = \"item_\" + Math.floor(Math.random() * 0xffffffff).toString(16);\n        this.dom = renderDiagnostic(view, diagnostic, true);\n        this.dom.setAttribute(\"role\", \"option\");\n    }\n}\nclass LintPanel {\n    constructor(view) {\n        this.view = view;\n        this.items = [];\n        let onkeydown = (event) => {\n            if (event.keyCode == 27) { // Escape\n                closeLintPanel(this.view);\n                this.view.focus();\n            }\n            else if (event.keyCode == 38 || event.keyCode == 33) { // ArrowUp, PageUp\n                this.moveSelection((this.selectedIndex - 1 + this.items.length) % this.items.length);\n            }\n            else if (event.keyCode == 40 || event.keyCode == 34) { // ArrowDown, PageDown\n                this.moveSelection((this.selectedIndex + 1) % this.items.length);\n            }\n            else if (event.keyCode == 36) { // Home\n                this.moveSelection(0);\n            }\n            else if (event.keyCode == 35) { // End\n                this.moveSelection(this.items.length - 1);\n            }\n            else if (event.keyCode == 13) { // Enter\n                this.view.focus();\n            }\n            else if (event.keyCode >= 65 && event.keyCode <= 90 && this.items.length) { // A-Z\n                let { diagnostic } = this.items[this.selectedIndex], keys = assignKeys(diagnostic.actions);\n                for (let i = 0; i < keys.length; i++)\n                    if (keys[i].toUpperCase().charCodeAt(0) == event.keyCode) {\n                        let found = findDiagnostic(this.view.state.field(lintState).diagnostics, diagnostic);\n                        if (found)\n                            diagnostic.actions[i].apply(view, found.from, found.to);\n                    }\n            }\n            else {\n                return;\n            }\n            event.preventDefault();\n        };\n        let onclick = (event) => {\n            for (let i = 0; i < this.items.length; i++) {\n                if (this.items[i].dom.contains(event.target))\n                    this.moveSelection(i);\n            }\n        };\n        this.list = elt(\"ul\", {\n            tabIndex: 0,\n            role: \"listbox\",\n            \"aria-label\": this.view.state.phrase(\"Diagnostics\"),\n            onkeydown,\n            onclick\n        });\n        this.dom = elt(\"div\", this.list, elt(\"button\", {\n            name: \"close\",\n            \"aria-label\": this.view.state.phrase(\"close\"),\n            onclick: () => closeLintPanel(this.view)\n        }, \"×\"));\n        this.update();\n    }\n    get selectedIndex() {\n        let selected = this.view.state.field(lintState).selected;\n        if (!selected)\n            return -1;\n        for (let i = 0; i < this.items.length; i++)\n            if (this.items[i].diagnostic == selected.diagnostic)\n                return i;\n        return -1;\n    }\n    update() {\n        let { diagnostics, selected } = this.view.state.field(lintState);\n        let i = 0, needsSync = false, newSelectedItem = null;\n        diagnostics.between(0, this.view.state.doc.length, (_start, _end, { spec }) => {\n            let found = -1, item;\n            for (let j = i; j < this.items.length; j++)\n                if (this.items[j].diagnostic == spec.diagnostic) {\n                    found = j;\n                    break;\n                }\n            if (found < 0) {\n                item = new PanelItem(this.view, spec.diagnostic);\n                this.items.splice(i, 0, item);\n                needsSync = true;\n            }\n            else {\n                item = this.items[found];\n                if (found > i) {\n                    this.items.splice(i, found - i);\n                    needsSync = true;\n                }\n            }\n            if (selected && item.diagnostic == selected.diagnostic) {\n                if (!item.dom.hasAttribute(\"aria-selected\")) {\n                    item.dom.setAttribute(\"aria-selected\", \"true\");\n                    newSelectedItem = item;\n                }\n            }\n            else if (item.dom.hasAttribute(\"aria-selected\")) {\n                item.dom.removeAttribute(\"aria-selected\");\n            }\n            i++;\n        });\n        while (i < this.items.length && !(this.items.length == 1 && this.items[0].diagnostic.from < 0)) {\n            needsSync = true;\n            this.items.pop();\n        }\n        if (this.items.length == 0) {\n            this.items.push(new PanelItem(this.view, {\n                from: -1, to: -1,\n                severity: \"info\",\n                message: this.view.state.phrase(\"No diagnostics\")\n            }));\n            needsSync = true;\n        }\n        if (newSelectedItem) {\n            this.list.setAttribute(\"aria-activedescendant\", newSelectedItem.id);\n            this.view.requestMeasure({\n                key: this,\n                read: () => ({ sel: newSelectedItem.dom.getBoundingClientRect(), panel: this.list.getBoundingClientRect() }),\n                write: ({ sel, panel }) => {\n                    if (sel.top < panel.top)\n                        this.list.scrollTop -= panel.top - sel.top;\n                    else if (sel.bottom > panel.bottom)\n                        this.list.scrollTop += sel.bottom - panel.bottom;\n                }\n            });\n        }\n        else if (!this.items.length) {\n            this.list.removeAttribute(\"aria-activedescendant\");\n        }\n        if (needsSync)\n            this.sync();\n    }\n    sync() {\n        let domPos = this.list.firstChild;\n        function rm() {\n            let prev = domPos;\n            domPos = prev.nextSibling;\n            prev.remove();\n        }\n        for (let item of this.items) {\n            if (item.dom.parentNode == this.list) {\n                while (domPos != item.dom)\n                    rm();\n                domPos = item.dom.nextSibling;\n            }\n            else {\n                this.list.insertBefore(item.dom, domPos);\n            }\n        }\n        while (domPos)\n            rm();\n        if (!this.list.firstChild)\n            this.list.appendChild(renderDiagnostic(this.view, {\n                severity: \"info\",\n                message: this.view.state.phrase(\"No diagnostics\")\n            }, true));\n    }\n    moveSelection(selectedIndex) {\n        if (this.items.length == 0)\n            return;\n        let field = this.view.state.field(lintState);\n        let selection = findDiagnostic(field.diagnostics, this.items[selectedIndex].diagnostic);\n        if (!selection)\n            return;\n        this.view.dispatch({\n            selection: { anchor: selection.from, head: selection.to },\n            scrollIntoView: true,\n            effects: movePanelSelection.of(selection)\n        });\n    }\n    get style() { return \"lint\"; }\n    static open(view) { return new LintPanel(view); }\n}\nfunction underline(color) {\n    if (typeof btoa != \"function\")\n        return \"none\";\n    let svg = `<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"6\" height=\"3\">\n    <path d=\"m0 3 l2 -2 l1 0 l2 2 l1 0\" stroke=\"${color}\" fill=\"none\" stroke-width=\".7\"/>\n  </svg>`;\n    return `url('data:image/svg+xml;base64,${btoa(svg)}')`;\n}\nconst baseTheme = EditorView.baseTheme({\n    $diagnostic: {\n        padding: \"3px 6px 3px 8px\",\n        marginLeft: \"-1px\",\n        display: \"block\"\n    },\n    \"$diagnostic.error\": { borderLeft: \"5px solid #d11\" },\n    \"$diagnostic.warning\": { borderLeft: \"5px solid orange\" },\n    \"$diagnostic.info\": { borderLeft: \"5px solid #999\" },\n    $diagnosticAction: {\n        font: \"inherit\",\n        border: \"none\",\n        padding: \"2px 4px\",\n        backgroundColor: \"#444\",\n        color: \"white\",\n        borderRadius: \"3px\",\n        marginLeft: \"8px\"\n    },\n    $diagnosticSource: {\n        fontSize: \"70%\",\n        opacity: .7\n    },\n    $lintRange: {\n        backgroundPosition: \"left bottom\",\n        backgroundRepeat: \"repeat-x\"\n    },\n    \"$lintRange.error\": { backgroundImage: underline(\"#d11\") },\n    \"$lintRange.warning\": { backgroundImage: underline(\"orange\") },\n    \"$lintRange.info\": { backgroundImage: underline(\"#999\") },\n    \"$lintRange.active\": { backgroundColor: \"#ffdd9980\" },\n    $lintPoint: {\n        position: \"relative\",\n        \"&:after\": {\n            content: '\"\"',\n            position: \"absolute\",\n            bottom: 0,\n            left: \"-2px\",\n            borderLeft: \"3px solid transparent\",\n            borderRight: \"3px solid transparent\",\n            borderBottom: \"4px solid #d11\"\n        }\n    },\n    \"$lintPoint.warning\": {\n        \"&:after\": { borderBottomColor: \"orange\" }\n    },\n    \"$lintPoint.info\": {\n        \"&:after\": { borderBottomColor: \"#999\" }\n    },\n    \"$panel.lint\": {\n        position: \"relative\",\n        \"& ul\": {\n            maxHeight: \"100px\",\n            overflowY: \"auto\",\n            \"& [aria-selected]\": {\n                backgroundColor: \"#ddd\",\n                \"& u\": { textDecoration: \"underline\" }\n            },\n            \"&:focus [aria-selected]\": {\n                background_fallback: \"#bdf\",\n                backgroundColor: \"Highlight\",\n                color_fallback: \"white\",\n                color: \"HighlightText\"\n            },\n            \"& u\": { textDecoration: \"none\" },\n            padding: 0,\n            margin: 0\n        },\n        \"& [name=close]\": {\n            position: \"absolute\",\n            top: \"0\",\n            right: \"2px\",\n            background: \"inherit\",\n            border: \"none\",\n            font: \"inherit\",\n            padding: 0,\n            margin: 0\n        }\n    },\n    \"$tooltip.lint\": {\n        padding: 0,\n        margin: 0\n    }\n});\n\nexport { closeLintPanel, lintKeymap, linter, nextDiagnostic, openLintPanel, setDiagnostics };\n","import { Facet, combineConfig, StateField } from '@codemirror/next/state';\nimport { syntaxTree } from '@codemirror/next/language';\nimport { EditorView, Decoration, themeClass } from '@codemirror/next/view';\nimport { NodeProp } from 'lezer-tree';\n\nconst baseTheme = EditorView.baseTheme({\n    $matchingBracket: { color: \"#0b0\" },\n    $nonmatchingBracket: { color: \"#a22\" }\n});\nconst DefaultScanDist = 10000, DefaultBrackets = \"()[]{}\";\nconst bracketMatchingConfig = Facet.define({\n    combine(configs) {\n        return combineConfig(configs, {\n            afterCursor: true,\n            brackets: DefaultBrackets,\n            maxScanDistance: DefaultScanDist\n        });\n    }\n});\nconst matchingMark = Decoration.mark({ class: themeClass(\"matchingBracket\") }), nonmatchingMark = Decoration.mark({ class: themeClass(\"nonmatchingBracket\") });\nconst bracketMatchingState = StateField.define({\n    create() { return Decoration.none; },\n    update(deco, tr) {\n        if (!tr.docChanged && !tr.selection)\n            return deco;\n        let decorations = [];\n        let config = tr.state.facet(bracketMatchingConfig);\n        for (let range of tr.state.selection.ranges) {\n            if (!range.empty)\n                continue;\n            let match = matchBrackets(tr.state, range.head, -1, config)\n                || (range.head > 0 && matchBrackets(tr.state, range.head - 1, 1, config))\n                || (config.afterCursor &&\n                    (matchBrackets(tr.state, range.head, 1, config) ||\n                        (range.head < tr.state.doc.length && matchBrackets(tr.state, range.head + 1, -1, config))));\n            if (!match)\n                continue;\n            let mark = match.matched ? matchingMark : nonmatchingMark;\n            decorations.push(mark.range(match.start.from, match.start.to));\n            if (match.other)\n                decorations.push(mark.range(match.other.from, match.other.to));\n        }\n        return Decoration.set(decorations, true);\n    },\n    provide: f => EditorView.decorations.from(f)\n});\nconst bracketMatchingUnique = [\n    bracketMatchingState,\n    baseTheme\n];\n/// Create an extension that enables bracket matching. Whenever the\n/// cursor is next to a bracket, that bracket and the one it matches\n/// are highlighted. Or, when no matching bracket is found, another\n/// highlighting style is used to indicate this.\nfunction bracketMatching(config = {}) {\n    return [bracketMatchingConfig.of(config), bracketMatchingUnique];\n}\nfunction matchingNodes(node, dir, brackets) {\n    let byProp = node.prop(dir < 0 ? NodeProp.openedBy : NodeProp.closedBy);\n    if (byProp)\n        return byProp;\n    if (node.name.length == 1) {\n        let index = brackets.indexOf(node.name);\n        if (index > -1 && index % 2 == (dir < 0 ? 1 : 0))\n            return [brackets[index + dir]];\n    }\n    return null;\n}\n/// Find the matching bracket for the token at `pos`, scanning\n/// direction `dir`. Only the `brackets` and `maxScanDistance`\n/// properties are used from `config`, if given. Returns null if no\n/// bracket was found at `pos`, or a match result otherwise.\nfunction matchBrackets(state, pos, dir, config = {}) {\n    let maxScanDistance = config.maxScanDistance || DefaultScanDist, brackets = config.brackets || DefaultBrackets;\n    let tree = syntaxTree(state), sub = tree.resolve(pos, dir), matches;\n    if (matches = matchingNodes(sub.type, dir, brackets))\n        return matchMarkedBrackets(state, pos, dir, sub, matches, brackets);\n    else\n        return matchPlainBrackets(state, pos, dir, tree, sub.type, maxScanDistance, brackets);\n}\nfunction matchMarkedBrackets(_state, _pos, dir, token, matching, brackets) {\n    let parent = token.parent, firstToken = { from: token.from, to: token.to };\n    let depth = 0, cursor = parent === null || parent === void 0 ? void 0 : parent.cursor;\n    if (cursor && (dir < 0 ? cursor.childBefore(token.from) : cursor.childAfter(token.to)))\n        do {\n            if (dir < 0 ? cursor.to <= token.from : cursor.from >= token.to) {\n                if (depth == 0 && matching.indexOf(cursor.type.name) > -1) {\n                    return { start: firstToken, end: { from: cursor.from, to: cursor.to }, matched: true };\n                }\n                else if (matchingNodes(cursor.type, dir, brackets)) {\n                    depth++;\n                }\n                else if (matchingNodes(cursor.type, -dir, brackets)) {\n                    depth--;\n                    if (depth == 0)\n                        return { start: firstToken, end: { from: cursor.from, to: cursor.to }, matched: false };\n                }\n            }\n        } while (dir < 0 ? cursor.prevSibling() : cursor.nextSibling());\n    return { start: firstToken, matched: false };\n}\nfunction matchPlainBrackets(state, pos, dir, tree, tokenType, maxScanDistance, brackets) {\n    let startCh = dir < 0 ? state.sliceDoc(pos - 1, pos) : state.sliceDoc(pos, pos + 1);\n    let bracket = brackets.indexOf(startCh);\n    if (bracket < 0 || (bracket % 2 == 0) != (dir > 0))\n        return null;\n    let startToken = { from: dir < 0 ? pos - 1 : pos, to: dir > 0 ? pos + 1 : pos };\n    let iter = state.doc.iterRange(pos, dir > 0 ? state.doc.length : 0), depth = 0;\n    for (let distance = 0; !(iter.next()).done && distance <= maxScanDistance;) {\n        let text = iter.value;\n        if (dir < 0)\n            distance += text.length;\n        let basePos = pos + distance * dir;\n        for (let pos = dir > 0 ? 0 : text.length - 1, end = dir > 0 ? text.length : -1; pos != end; pos += dir) {\n            let found = brackets.indexOf(text[pos]);\n            if (found < 0 || tree.resolve(basePos + pos, 1).type != tokenType)\n                continue;\n            if ((found % 2 == 0) == (dir > 0)) {\n                depth++;\n            }\n            else if (depth == 1) { // Closing\n                return { start: startToken, end: { from: basePos + pos, to: basePos + pos + 1 }, matched: (found >> 1) == (bracket >> 1) };\n            }\n            else {\n                depth--;\n            }\n        }\n        if (dir > 0)\n            distance += text.length;\n    }\n    return iter.done ? { start: startToken, matched: false } : null;\n}\n\nexport { bracketMatching, matchBrackets };\n","import { ViewPlugin, themeClass, PluginField, EditorView } from '@codemirror/next/view';\nimport { Facet } from '@codemirror/next/state';\n\nconst panelConfig = Facet.define({\n    combine(configs) {\n        let topContainer, bottomContainer;\n        for (let c of configs) {\n            topContainer = topContainer || c.topContainer;\n            bottomContainer = bottomContainer || c.bottomContainer;\n        }\n        return { topContainer, bottomContainer };\n    }\n});\n/// Enables the panel-managing extension.\nfunction panels(config) {\n    let ext = [panelPlugin, baseTheme];\n    if (config)\n        ext.push(panelConfig.of(config));\n    return ext;\n}\n/// Opening a panel is done by providing a constructor function for\n/// the panel through this facet. (The panel is closed again when its\n/// constructor is no longer provided.)\nconst showPanel = Facet.define();\n/// Get the active panel created by the given constructor, if any.\n/// This can be useful when you need access to your panels' DOM\n/// structure.\nfunction getPanel(view, panel) {\n    let plugin = view.plugin(panelPlugin);\n    let index = view.state.facet(showPanel).indexOf(panel);\n    return plugin && index > -1 ? plugin.panels[index] : null;\n}\nconst panelPlugin = ViewPlugin.fromClass(class {\n    constructor(view) {\n        this.specs = view.state.facet(showPanel);\n        this.panels = this.specs.map(spec => spec(view));\n        let conf = view.state.facet(panelConfig);\n        this.top = new PanelGroup(view, true, conf.topContainer);\n        this.bottom = new PanelGroup(view, false, conf.bottomContainer);\n        this.top.sync(this.panels.filter(p => p.top));\n        this.bottom.sync(this.panels.filter(p => !p.top));\n        for (let p of this.panels) {\n            p.dom.className += \" \" + panelClass(p);\n            if (p.mount)\n                p.mount();\n        }\n    }\n    update(update) {\n        let conf = update.state.facet(panelConfig);\n        if (this.top.container != conf.topContainer) {\n            this.top.sync([]);\n            this.top = new PanelGroup(update.view, true, conf.topContainer);\n        }\n        if (this.bottom.container != conf.bottomContainer) {\n            this.bottom.sync([]);\n            this.bottom = new PanelGroup(update.view, false, conf.bottomContainer);\n        }\n        this.top.syncClasses();\n        this.bottom.syncClasses();\n        let specs = update.state.facet(showPanel);\n        if (specs != this.specs) {\n            let panels = [], top = [], bottom = [], mount = [];\n            for (let spec of specs) {\n                let known = this.specs.indexOf(spec), panel;\n                if (known < 0) {\n                    panel = spec(update.view);\n                    mount.push(panel);\n                }\n                else {\n                    panel = this.panels[known];\n                    if (panel.update)\n                        panel.update(update);\n                }\n                panels.push(panel);\n                (panel.top ? top : bottom).push(panel);\n            }\n            this.specs = specs;\n            this.panels = panels;\n            this.top.sync(top);\n            this.bottom.sync(bottom);\n            for (let p of mount) {\n                p.dom.className += \" \" + panelClass(p);\n                if (p.mount)\n                    p.mount();\n            }\n        }\n        else {\n            for (let p of this.panels)\n                if (p.update)\n                    p.update(update);\n        }\n    }\n    destroy() {\n        this.top.sync([]);\n        this.bottom.sync([]);\n    }\n}, {\n    provide: PluginField.scrollMargins.from(value => ({ top: value.top.scrollMargin(), bottom: value.bottom.scrollMargin() }))\n});\nfunction panelClass(panel) {\n    return themeClass(panel.style ? `panel.${panel.style}` : \"panel\");\n}\nclass PanelGroup {\n    constructor(view, top, container) {\n        this.view = view;\n        this.top = top;\n        this.container = container;\n        this.dom = undefined;\n        this.classes = \"\";\n        this.panels = [];\n        this.syncClasses();\n    }\n    sync(panels) {\n        this.panels = panels;\n        this.syncDOM();\n    }\n    syncDOM() {\n        if (this.panels.length == 0) {\n            if (this.dom) {\n                this.dom.remove();\n                this.dom = undefined;\n            }\n            return;\n        }\n        if (!this.dom) {\n            this.dom = document.createElement(\"div\");\n            this.dom.className = themeClass(this.top ? \"panels.top\" : \"panels.bottom\");\n            this.dom.style[this.top ? \"top\" : \"bottom\"] = \"0\";\n            let parent = this.container || this.view.dom;\n            parent.insertBefore(this.dom, this.top ? parent.firstChild : null);\n        }\n        let curDOM = this.dom.firstChild;\n        for (let panel of this.panels) {\n            if (panel.dom.parentNode == this.dom) {\n                while (curDOM != panel.dom)\n                    curDOM = rm(curDOM);\n                curDOM = curDOM.nextSibling;\n            }\n            else {\n                this.dom.insertBefore(panel.dom, curDOM);\n            }\n        }\n        while (curDOM)\n            curDOM = rm(curDOM);\n    }\n    scrollMargin() {\n        return !this.dom || this.container ? 0\n            : Math.max(0, this.top ? this.dom.getBoundingClientRect().bottom - this.view.scrollDOM.getBoundingClientRect().top\n                : this.view.scrollDOM.getBoundingClientRect().bottom - this.dom.getBoundingClientRect().top);\n    }\n    syncClasses() {\n        if (!this.container || this.classes == this.view.themeClasses)\n            return;\n        for (let cls of this.classes.split(\" \"))\n            if (cls)\n                this.container.classList.remove(cls);\n        for (let cls of (this.classes = this.view.themeClasses).split(\" \"))\n            if (cls)\n                this.container.classList.add(cls);\n    }\n}\nfunction rm(node) {\n    let next = node.nextSibling;\n    node.remove();\n    return next;\n}\nconst baseTheme = EditorView.baseTheme({\n    $panels: {\n        boxSizing: \"border-box\",\n        position: \"sticky\",\n        left: 0,\n        right: 0\n    },\n    \"$$light $panels\": {\n        backgroundColor: \"#f5f5f5\",\n        color: \"black\"\n    },\n    \"$$light $panels.top\": {\n        borderBottom: \"1px solid #ddd\"\n    },\n    \"$$light $panels.bottom\": {\n        borderTop: \"1px solid #ddd\"\n    },\n    \"$$dark $panels\": {\n        backgroundColor: \"#333338\",\n        color: \"white\"\n    }\n});\n\nexport { getPanel, panels, showPanel };\n","import { MapMode } from '@codemirror/next/state';\n\n/// Each range is associated with a value, which must inherit from\n/// this class.\nclass RangeValue {\n    /// Compare this value with another value. The default\n    /// implementation compares by identity.\n    eq(other) { return this == other; }\n    /// Create a [range](#rangeset.Range) with this value.\n    range(from, to = from) { return new Range(from, to, this); }\n}\nRangeValue.prototype.startSide = RangeValue.prototype.endSide = 0;\nRangeValue.prototype.point = false;\nRangeValue.prototype.mapMode = MapMode.TrackDel;\n/// A range associates a value with a range of positions.\nclass Range {\n    /// @internal\n    constructor(\n    /// The range's start position.\n    from, \n    /// Its end position.\n    to, \n    /// The value associated with this range.\n    value) {\n        this.from = from;\n        this.to = to;\n        this.value = value;\n    }\n}\nfunction cmpRange(a, b) {\n    return a.from - b.from || a.value.startSide - b.value.startSide;\n}\nclass Chunk {\n    constructor(from, to, value, \n    // Chunks are marked with the largest point that occurs\n    // in them (or -1 for no points), so that scans that are\n    // only interested in points (such as the\n    // heightmap-related logic) can skip range-only chunks.\n    maxPoint) {\n        this.from = from;\n        this.to = to;\n        this.value = value;\n        this.maxPoint = maxPoint;\n    }\n    get length() { return this.to[this.to.length - 1]; }\n    // With side == -1, return the first index where to >= pos. When\n    // side == 1, the first index where from > pos.\n    findIndex(pos, end, side = end * 1000000000 /* Far */, startAt = 0) {\n        if (pos <= 0)\n            return startAt;\n        let arr = end < 0 ? this.to : this.from;\n        for (let lo = startAt, hi = arr.length;;) {\n            if (lo == hi)\n                return lo;\n            let mid = (lo + hi) >> 1;\n            let diff = arr[mid] - pos || (end < 0 ? this.value[mid].startSide : this.value[mid].endSide) - side;\n            if (mid == lo)\n                return diff >= 0 ? lo : hi;\n            if (diff >= 0)\n                hi = mid;\n            else\n                lo = mid + 1;\n        }\n    }\n    between(offset, from, to, f) {\n        for (let i = this.findIndex(from, -1), e = this.findIndex(to, 1, undefined, i); i < e; i++)\n            if (f(this.from[i] + offset, this.to[i] + offset, this.value[i]) === false)\n                return false;\n    }\n    map(offset, changes) {\n        let value = [], from = [], to = [], newPos = -1, maxPoint = -1;\n        for (let i = 0; i < this.value.length; i++) {\n            let val = this.value[i], curFrom = this.from[i] + offset, curTo = this.to[i] + offset, newFrom, newTo;\n            if (curFrom == curTo) {\n                let mapped = changes.mapPos(curFrom, val.startSide, val.mapMode);\n                if (mapped == null)\n                    continue;\n                newFrom = newTo = mapped;\n            }\n            else {\n                newFrom = changes.mapPos(curFrom, val.startSide);\n                newTo = changes.mapPos(curTo, val.endSide);\n                if (newFrom > newTo || newFrom == newTo && val.startSide > 0 && val.endSide <= 0)\n                    continue;\n            }\n            if ((newTo - newFrom || val.endSide - val.startSide) < 0)\n                continue;\n            if (newPos < 0)\n                newPos = newFrom;\n            if (val.point)\n                maxPoint = Math.max(maxPoint, newTo - newFrom);\n            value.push(val);\n            from.push(newFrom - newPos);\n            to.push(newTo - newPos);\n        }\n        return { mapped: value.length ? new Chunk(from, to, value, maxPoint) : null, pos: newPos };\n    }\n}\n/// A range set stores a collection of [ranges](#rangeset.Range) in a\n/// way that makes them efficient to [map](#rangeset.RangeSet.map) and\n/// [update](#rangeset.RangeSet.update). This is an immutable data\n/// structure.\nclass RangeSet {\n    /// @internal\n    constructor(\n    /// @internal\n    chunkPos, \n    /// @internal\n    chunk, \n    /// @internal\n    nextLayer = RangeSet.empty, \n    /// @internal\n    maxPoint) {\n        this.chunkPos = chunkPos;\n        this.chunk = chunk;\n        this.nextLayer = nextLayer;\n        this.maxPoint = maxPoint;\n    }\n    /// @internal\n    get length() {\n        let last = this.chunk.length - 1;\n        return last < 0 ? 0 : Math.max(this.chunkEnd(last), this.nextLayer.length);\n    }\n    /// @internal\n    get size() {\n        if (this == RangeSet.empty)\n            return 0;\n        let size = this.nextLayer.size;\n        for (let chunk of this.chunk)\n            size += chunk.value.length;\n        return size;\n    }\n    /// @internal\n    chunkEnd(index) {\n        return this.chunkPos[index] + this.chunk[index].length;\n    }\n    /// Update the range set, optionally adding new ranges or filtering\n    /// out existing ones.\n    ///\n    /// (The extra type parameter is just there as a kludge to work\n    /// around TypeScript variance issues that prevented `RangeSet<X>`\n    /// from being a subtype of `RangeSet<Y>` when `X` is a subtype of\n    /// `Y`.)\n    update(updateSpec) {\n        let { add = [], sort = false, filterFrom = 0, filterTo = this.length } = updateSpec;\n        let filter = updateSpec.filter;\n        if (add.length == 0 && !filter)\n            return this;\n        if (sort)\n            add.slice().sort(cmpRange);\n        if (this == RangeSet.empty)\n            return add.length ? RangeSet.of(add) : this;\n        let cur = new LayerCursor(this, null, -1).goto(0), i = 0, spill = [];\n        let builder = new RangeSetBuilder();\n        while (cur.value || i < add.length) {\n            if (i < add.length && (cur.from - add[i].from || cur.startSide - add[i].value.startSide) >= 0) {\n                let range = add[i++];\n                if (!builder.addInner(range.from, range.to, range.value))\n                    spill.push(range);\n            }\n            else if (cur.rangeIndex == 1 && cur.chunkIndex < this.chunk.length &&\n                (i == add.length || this.chunkEnd(cur.chunkIndex) < add[i].from) &&\n                (!filter || filterFrom > this.chunkEnd(cur.chunkIndex) || filterTo < this.chunkPos[cur.chunkIndex]) &&\n                builder.addChunk(this.chunkPos[cur.chunkIndex], this.chunk[cur.chunkIndex])) {\n                cur.nextChunk();\n            }\n            else {\n                if (!filter || filterFrom > cur.to || filterTo < cur.from || filter(cur.from, cur.to, cur.value)) {\n                    if (!builder.addInner(cur.from, cur.to, cur.value))\n                        spill.push(new Range(cur.from, cur.to, cur.value));\n                }\n                cur.next();\n            }\n        }\n        return builder.finishInner(this.nextLayer == RangeSet.empty && !spill.length ? RangeSet.empty\n            : this.nextLayer.update({ add: spill, filter, filterFrom, filterTo }));\n    }\n    /// Map this range set through a set of changes, return the new set.\n    map(changes) {\n        if (changes.length == 0 || this == RangeSet.empty)\n            return this;\n        let chunks = [], chunkPos = [], maxPoint = -1;\n        for (let i = 0; i < this.chunk.length; i++) {\n            let start = this.chunkPos[i], chunk = this.chunk[i];\n            let touch = changes.touchesRange(start, start + chunk.length);\n            if (touch === false) {\n                maxPoint = Math.max(maxPoint, chunk.maxPoint);\n                chunks.push(chunk);\n                chunkPos.push(changes.mapPos(start));\n            }\n            else if (touch === true) {\n                let { mapped, pos } = chunk.map(start, changes);\n                if (mapped) {\n                    maxPoint = Math.max(maxPoint, mapped.maxPoint);\n                    chunks.push(mapped);\n                    chunkPos.push(pos);\n                }\n            }\n        }\n        let next = this.nextLayer.map(changes);\n        return chunks.length == 0 ? next : new RangeSet(chunkPos, chunks, next, maxPoint);\n    }\n    /// Iterate over the ranges that touch the region `from` to `to`,\n    /// calling `f` for each. There is no guarantee that the ranges will\n    /// be reported in any specific order. When the callback returns\n    /// `false`, iteration stops.\n    between(from, to, f) {\n        if (this == RangeSet.empty)\n            return;\n        for (let i = 0; i < this.chunk.length; i++) {\n            let start = this.chunkPos[i], chunk = this.chunk[i];\n            if (to >= start && from <= start + chunk.length &&\n                chunk.between(start, from - start, to - start, f) === false)\n                return;\n        }\n        this.nextLayer.between(from, to, f);\n    }\n    /// Iterate over the ranges in this set, in order, including all\n    /// ranges that end at or after `from`.\n    iter(from = 0) {\n        return HeapCursor.from([this]).goto(from);\n    }\n    /// Iterate over the ranges in a collection of sets, in order,\n    /// starting from `from`.\n    static iter(sets, from = 0) {\n        return HeapCursor.from(sets).goto(from);\n    }\n    /// Iterate over two groups of sets, calling methods on `comparator`\n    /// to notify it of possible differences.\n    static compare(oldSets, newSets, \n    /// This indicates how the underlying data changed between these\n    /// ranges, and is needed to synchronize the iteration. `from` and\n    /// `to` are coordinates in the _new_ space, after these changes.\n    textDiff, comparator, \n    /// Can be used to ignore all non-point ranges, and points below\n    /// the given size. When -1, all ranges are compared.\n    minPointSize = -1) {\n        let a = oldSets.filter(set => set.maxPoint >= 500 /* BigPointSize */ ||\n            set != RangeSet.empty && newSets.indexOf(set) < 0 && set.maxPoint >= minPointSize);\n        let b = newSets.filter(set => set.maxPoint >= 500 /* BigPointSize */ ||\n            set != RangeSet.empty && oldSets.indexOf(set) < 0 && set.maxPoint >= minPointSize);\n        let sharedChunks = findSharedChunks(a, b);\n        let sideA = new SpanCursor(a, sharedChunks, minPointSize);\n        let sideB = new SpanCursor(b, sharedChunks, minPointSize);\n        textDiff.iterGaps((fromA, fromB, length) => compare(sideA, fromA, sideB, fromB, length, comparator));\n        if (textDiff.empty && textDiff.length == 0)\n            compare(sideA, 0, sideB, 0, 0, comparator);\n    }\n    /// Iterate over a group of range sets at the same time, notifying\n    /// the iterator about the ranges covering every given piece of\n    /// content. Returns the open count (see\n    /// [`SpanIterator.span`](#rangeset.SpanIterator.span)) at the end\n    /// of the iteration.\n    static spans(sets, from, to, iterator, \n    /// When given and greater than -1, only points of at least this\n    /// size are taken into account.\n    minPointSize = -1) {\n        let cursor = new SpanCursor(sets, null, minPointSize).goto(from), pos = from;\n        let open = cursor.openStart;\n        for (;;) {\n            let curTo = Math.min(cursor.to, to);\n            if (cursor.point) {\n                iterator.point(pos, curTo, cursor.point, cursor.activeForPoint(cursor.to), open);\n                open = cursor.openEnd(curTo) + (cursor.to > curTo ? 1 : 0);\n            }\n            else if (curTo > pos) {\n                iterator.span(pos, curTo, cursor.active, open);\n                open = cursor.openEnd(curTo);\n            }\n            if (cursor.to > to)\n                break;\n            pos = cursor.to;\n            cursor.next();\n        }\n        return open;\n    }\n    /// Create a range set for the given range or array of ranges. By\n    /// default, this expects the ranges to be _sorted_ (by start\n    /// position and, if two start at the same position,\n    /// `value.startSide`). You can pass `true` as second argument to\n    /// cause the method to sort them.\n    static of(ranges, sort = false) {\n        let build = new RangeSetBuilder();\n        for (let range of ranges instanceof Range ? [ranges] : sort ? ranges.slice().sort(cmpRange) : ranges)\n            build.add(range.from, range.to, range.value);\n        return build.finish();\n    }\n}\n/// The empty set of ranges.\nRangeSet.empty = new RangeSet([], [], null, -1);\nRangeSet.empty.nextLayer = RangeSet.empty;\n/// A range set builder is a data structure that helps build up a\n/// [range set](#rangeset.RangeSet) directly, without first allocating\n/// an array of [`Range`](#rangeset.Range) objects.\nclass RangeSetBuilder {\n    /// Create an empty builder.\n    constructor() {\n        this.chunks = [];\n        this.chunkPos = [];\n        this.chunkStart = -1;\n        this.last = null;\n        this.lastFrom = -1000000000 /* Far */;\n        this.lastTo = -1000000000 /* Far */;\n        this.from = [];\n        this.to = [];\n        this.value = [];\n        this.maxPoint = -1;\n        this.setMaxPoint = -1;\n        this.nextLayer = null;\n    }\n    finishChunk(newArrays) {\n        this.chunks.push(new Chunk(this.from, this.to, this.value, this.maxPoint));\n        this.chunkPos.push(this.chunkStart);\n        this.chunkStart = -1;\n        this.setMaxPoint = Math.max(this.setMaxPoint, this.maxPoint);\n        this.maxPoint = -1;\n        if (newArrays) {\n            this.from = [];\n            this.to = [];\n            this.value = [];\n        }\n    }\n    /// Add a range. Ranges should be added in sorted (by `from` and\n    /// `value.startSide`) order.\n    add(from, to, value) {\n        if (!this.addInner(from, to, value))\n            (this.nextLayer || (this.nextLayer = new RangeSetBuilder)).add(from, to, value);\n    }\n    /// @internal\n    addInner(from, to, value) {\n        let diff = from - this.lastTo || value.startSide - this.last.endSide;\n        if (diff <= 0 && (from - this.lastFrom || value.startSide - this.last.startSide) < 0)\n            throw new Error(\"Ranges must be added sorted by `from` position and `startSide`\");\n        if (diff < 0)\n            return false;\n        if (this.from.length == 250 /* ChunkSize */)\n            this.finishChunk(true);\n        if (this.chunkStart < 0)\n            this.chunkStart = from;\n        this.from.push(from - this.chunkStart);\n        this.to.push(to - this.chunkStart);\n        this.last = value;\n        this.lastFrom = from;\n        this.lastTo = to;\n        this.value.push(value);\n        if (value.point)\n            this.maxPoint = Math.max(this.maxPoint, to - from);\n        return true;\n    }\n    /// @internal\n    addChunk(from, chunk) {\n        if ((from - this.lastTo || chunk.value[0].startSide - this.last.endSide) < 0)\n            return false;\n        if (this.from.length)\n            this.finishChunk(true);\n        this.setMaxPoint = Math.max(this.setMaxPoint, chunk.maxPoint);\n        this.chunks.push(chunk);\n        this.chunkPos.push(from);\n        let last = chunk.value.length - 1;\n        this.last = chunk.value[last];\n        this.lastFrom = chunk.from[last] + from;\n        this.lastTo = chunk.to[last] + from;\n        return true;\n    }\n    /// Finish the range set. Returns the new set. The builder can't be\n    /// used anymore after this has been called.\n    finish() { return this.finishInner(RangeSet.empty); }\n    /// @internal\n    finishInner(next) {\n        if (this.from.length)\n            this.finishChunk(false);\n        if (this.chunks.length == 0)\n            return next;\n        let result = new RangeSet(this.chunkPos, this.chunks, this.nextLayer ? this.nextLayer.finishInner(next) : next, this.setMaxPoint);\n        this.from = null; // Make sure further `add` calls produce errors\n        return result;\n    }\n}\nfunction findSharedChunks(a, b) {\n    let inA = new Map();\n    for (let set of a)\n        for (let i = 0; i < set.chunk.length; i++)\n            if (set.chunk[i].maxPoint < 500 /* BigPointSize */)\n                inA.set(set.chunk[i], set.chunkPos[i]);\n    let shared = new Set();\n    for (let set of b)\n        for (let i = 0; i < set.chunk.length; i++)\n            if (inA.get(set.chunk[i]) == set.chunkPos[i])\n                shared.add(set.chunk[i]);\n    return shared;\n}\nclass LayerCursor {\n    constructor(layer, skip, minPoint, rank = 0) {\n        this.layer = layer;\n        this.skip = skip;\n        this.minPoint = minPoint;\n        this.rank = rank;\n    }\n    get startSide() { return this.value ? this.value.startSide : 0; }\n    get endSide() { return this.value ? this.value.endSide : 0; }\n    goto(pos, side = -1000000000 /* Far */) {\n        this.chunkIndex = this.rangeIndex = 0;\n        this.gotoInner(pos, side, false);\n        return this;\n    }\n    gotoInner(pos, side, forward) {\n        while (this.chunkIndex < this.layer.chunk.length) {\n            let next = this.layer.chunk[this.chunkIndex];\n            if (!(this.skip && this.skip.has(next) ||\n                this.layer.chunkEnd(this.chunkIndex) < pos ||\n                next.maxPoint < this.minPoint))\n                break;\n            this.chunkIndex++;\n            forward = false;\n        }\n        let rangeIndex = this.chunkIndex == this.layer.chunk.length ? 0\n            : this.layer.chunk[this.chunkIndex].findIndex(pos - this.layer.chunkPos[this.chunkIndex], -1, side);\n        if (!forward || this.rangeIndex < rangeIndex)\n            this.rangeIndex = rangeIndex;\n        this.next();\n    }\n    forward(pos, side) {\n        if ((this.to - pos || this.endSide - side) < 0)\n            this.gotoInner(pos, side, true);\n    }\n    next() {\n        for (;;) {\n            if (this.chunkIndex == this.layer.chunk.length) {\n                this.from = this.to = 1000000000 /* Far */;\n                this.value = null;\n                break;\n            }\n            else {\n                let chunkPos = this.layer.chunkPos[this.chunkIndex], chunk = this.layer.chunk[this.chunkIndex];\n                let from = chunkPos + chunk.from[this.rangeIndex];\n                this.from = from;\n                this.to = chunkPos + chunk.to[this.rangeIndex];\n                this.value = chunk.value[this.rangeIndex];\n                if (++this.rangeIndex == chunk.value.length) {\n                    this.chunkIndex++;\n                    if (this.skip) {\n                        while (this.chunkIndex < this.layer.chunk.length && this.skip.has(this.layer.chunk[this.chunkIndex]))\n                            this.chunkIndex++;\n                    }\n                    this.rangeIndex = 0;\n                }\n                if (this.minPoint < 0 || this.value.point && this.to - this.from >= this.minPoint)\n                    break;\n            }\n        }\n    }\n    nextChunk() {\n        this.chunkIndex++;\n        this.rangeIndex = 0;\n        this.next();\n    }\n    compare(other) {\n        return this.from - other.from || this.startSide - other.startSide || this.to - other.to || this.endSide - other.endSide;\n    }\n}\nclass HeapCursor {\n    constructor(heap) {\n        this.heap = heap;\n    }\n    static from(sets, skip = null, minPoint = -1) {\n        let heap = [];\n        for (let i = 0; i < sets.length; i++) {\n            for (let cur = sets[i]; cur != RangeSet.empty; cur = cur.nextLayer) {\n                if (cur.maxPoint >= minPoint)\n                    heap.push(new LayerCursor(cur, skip, minPoint, i));\n            }\n        }\n        return heap.length == 1 ? heap[0] : new HeapCursor(heap);\n    }\n    get startSide() { return this.value ? this.value.startSide : 0; }\n    goto(pos, side = -1000000000 /* Far */) {\n        for (let cur of this.heap)\n            cur.goto(pos, side);\n        for (let i = this.heap.length >> 1; i >= 0; i--)\n            heapBubble(this.heap, i);\n        this.next();\n        return this;\n    }\n    forward(pos, side) {\n        for (let cur of this.heap)\n            cur.forward(pos, side);\n        for (let i = this.heap.length >> 1; i >= 0; i--)\n            heapBubble(this.heap, i);\n        if ((this.to - pos || this.value.endSide - side) < 0)\n            this.next();\n    }\n    next() {\n        if (this.heap.length == 0) {\n            this.from = this.to = 1000000000 /* Far */;\n            this.value = null;\n            this.rank = -1;\n        }\n        else {\n            let top = this.heap[0];\n            this.from = top.from;\n            this.to = top.to;\n            this.value = top.value;\n            this.rank = top.rank;\n            if (top.value)\n                top.next();\n            heapBubble(this.heap, 0);\n        }\n    }\n}\nfunction heapBubble(heap, index) {\n    for (let cur = heap[index];;) {\n        let childIndex = (index << 1) + 1;\n        if (childIndex >= heap.length)\n            break;\n        let child = heap[childIndex];\n        if (childIndex + 1 < heap.length && child.compare(heap[childIndex + 1]) >= 0) {\n            child = heap[childIndex + 1];\n            childIndex++;\n        }\n        if (cur.compare(child) < 0)\n            break;\n        heap[childIndex] = cur;\n        heap[index] = child;\n        index = childIndex;\n    }\n}\nclass SpanCursor {\n    constructor(sets, skip, minPoint) {\n        this.minPoint = minPoint;\n        this.active = [];\n        this.activeTo = [];\n        this.activeRank = [];\n        this.minActive = -1;\n        // A currently active point range, if any\n        this.point = null;\n        this.pointFrom = 0;\n        this.pointRank = 0;\n        this.to = -1000000000 /* Far */;\n        this.endSide = 0;\n        this.openStart = -1;\n        this.cursor = HeapCursor.from(sets, skip, minPoint);\n    }\n    goto(pos, side = -1000000000 /* Far */) {\n        this.cursor.goto(pos, side);\n        this.active.length = this.activeTo.length = this.activeRank.length = 0;\n        this.minActive = -1;\n        this.to = pos;\n        this.endSide = side;\n        this.openStart = -1;\n        this.next();\n        return this;\n    }\n    forward(pos, side) {\n        while (this.minActive > -1 && (this.activeTo[this.minActive] - pos || this.active[this.minActive].endSide - side) < 0)\n            this.removeActive(this.minActive);\n        this.cursor.forward(pos, side);\n    }\n    removeActive(index) {\n        remove(this.active, index);\n        remove(this.activeTo, index);\n        remove(this.activeRank, index);\n        this.minActive = findMinIndex(this.active, this.activeTo);\n    }\n    addActive(trackOpen) {\n        let i = 0, { value, to, rank } = this.cursor;\n        while (i < this.activeRank.length && this.activeRank[i] <= rank)\n            i++;\n        insert(this.active, i, value);\n        insert(this.activeTo, i, to);\n        insert(this.activeRank, i, rank);\n        if (trackOpen)\n            insert(trackOpen, i, this.cursor.from);\n        this.minActive = findMinIndex(this.active, this.activeTo);\n    }\n    // After calling this, if `this.point` != null, the next range is a\n    // point. Otherwise, it's a regular range, covered by `this.active`.\n    next() {\n        let from = this.to;\n        this.point = null;\n        let trackOpen = this.openStart < 0 ? [] : null, trackExtra = 0;\n        for (;;) {\n            let a = this.minActive;\n            if (a > -1 && (this.activeTo[a] - this.cursor.from || this.active[a].endSide - this.cursor.startSide) < 0) {\n                if (this.activeTo[a] > from) {\n                    this.to = this.activeTo[a];\n                    this.endSide = this.active[a].endSide;\n                    break;\n                }\n                this.removeActive(a);\n                if (trackOpen)\n                    remove(trackOpen, a);\n            }\n            else if (!this.cursor.value) {\n                this.to = this.endSide = 1000000000 /* Far */;\n                break;\n            }\n            else if (this.cursor.from > from) {\n                this.to = this.cursor.from;\n                this.endSide = this.cursor.startSide;\n                break;\n            }\n            else {\n                let nextVal = this.cursor.value;\n                if (!nextVal.point) { // Opening a range\n                    this.addActive(trackOpen);\n                    this.cursor.next();\n                }\n                else { // New point\n                    this.point = nextVal;\n                    this.pointFrom = this.cursor.from;\n                    this.pointRank = this.cursor.rank;\n                    this.to = this.cursor.to;\n                    this.endSide = nextVal.endSide;\n                    if (this.cursor.from < from)\n                        trackExtra = 1;\n                    this.cursor.next();\n                    if (this.to > from)\n                        this.forward(this.to, this.endSide);\n                    break;\n                }\n            }\n        }\n        if (trackOpen) {\n            let openStart = 0;\n            while (openStart < trackOpen.length && trackOpen[openStart] < from)\n                openStart++;\n            this.openStart = openStart + trackExtra;\n        }\n    }\n    activeForPoint(to) {\n        if (!this.active.length)\n            return this.active;\n        let active = [];\n        for (let i = 0; i < this.active.length; i++) {\n            if (this.activeRank[i] > this.pointRank)\n                break;\n            if (this.activeTo[i] > to || this.activeTo[i] == to && this.active[i].endSide > this.point.endSide)\n                active.push(this.active[i]);\n        }\n        return active;\n    }\n    openEnd(to) {\n        let open = 0;\n        while (open < this.activeTo.length && this.activeTo[open] > to)\n            open++;\n        return open;\n    }\n}\nfunction compare(a, startA, b, startB, length, comparator) {\n    a.goto(startA);\n    b.goto(startB);\n    let endB = startB + length;\n    let pos = startB, dPos = startB - startA;\n    for (;;) {\n        let diff = (a.to + dPos) - b.to || a.endSide - b.endSide;\n        let end = diff < 0 ? a.to + dPos : b.to, clipEnd = Math.min(end, endB);\n        if (a.point || b.point) {\n            if (!(a.point && b.point && (a.point == b.point || a.point.eq(b.point))))\n                comparator.comparePoint(pos, clipEnd, a.point, b.point);\n        }\n        else {\n            if (clipEnd > pos && !sameValues(a.active, b.active))\n                comparator.compareRange(pos, clipEnd, a.active, b.active);\n        }\n        if (end > endB)\n            break;\n        pos = end;\n        if (diff <= 0)\n            a.next();\n        if (diff >= 0)\n            b.next();\n    }\n}\nfunction sameValues(a, b) {\n    if (a.length != b.length)\n        return false;\n    for (let i = 0; i < a.length; i++)\n        if (a[i] != b[i] && !a[i].eq(b[i]))\n            return false;\n    return true;\n}\nfunction remove(array, index) {\n    for (let i = index, e = array.length - 1; i < e; i++)\n        array[i] = array[i + 1];\n    array.pop();\n}\nfunction insert(array, index, value) {\n    for (let i = array.length - 1; i >= index; i--)\n        array[i + 1] = array[i];\n    array[index] = value;\n}\nfunction findMinIndex(value, array) {\n    let found = -1, foundPos = 1000000000 /* Far */;\n    for (let i = 0; i < array.length; i++)\n        if ((array[i] - foundPos || value[i].endSide - value[found].endSide) < 0) {\n            found = i;\n            foundPos = array[i];\n        }\n    return found;\n}\n\nexport { Range, RangeSet, RangeSetBuilder, RangeValue };\n","import { EditorSelection } from '@codemirror/next/state';\nimport { EditorView } from '@codemirror/next/view';\nimport { findColumn, countColumn } from '@codemirror/next/text';\n\n// Don't compute precise column positions for line offsets above this\n// (since it could get expensive). Assume offset==column for them.\nconst MaxOff = 2000;\nfunction rectangleFor(state, a, b) {\n    let startLine = Math.min(a.line, b.line), endLine = Math.max(a.line, b.line);\n    let ranges = [];\n    if (a.off > MaxOff || b.off > MaxOff || a.col < 0 || b.col < 0) {\n        let startOff = Math.min(a.off, b.off), endOff = Math.max(a.off, b.off);\n        for (let i = startLine; i <= endLine; i++) {\n            let line = state.doc.line(i);\n            if (line.length <= endOff)\n                ranges.push(EditorSelection.range(line.from + startOff, line.to + endOff));\n        }\n    }\n    else {\n        let startCol = Math.min(a.col, b.col), endCol = Math.max(a.col, b.col);\n        for (let i = startLine; i <= endLine; i++) {\n            let line = state.doc.line(i), str = line.length > MaxOff ? line.text.slice(0, 2 * endCol) : line.text;\n            let start = findColumn(str, 0, startCol, state.tabSize), end = findColumn(str, 0, endCol, state.tabSize);\n            if (!start.leftOver)\n                ranges.push(EditorSelection.range(line.from + start.offset, line.from + end.offset));\n        }\n    }\n    return ranges;\n}\nfunction absoluteColumn(view, x) {\n    let ref = view.coordsAtPos(view.viewport.from);\n    return ref ? Math.round(Math.abs((ref.left - x) / view.defaultCharacterWidth)) : -1;\n}\nfunction getPos(view, event) {\n    let offset = view.posAtCoords({ x: event.clientX, y: event.clientY });\n    if (offset == null)\n        return null;\n    let line = view.state.doc.lineAt(offset), off = offset - line.from;\n    let col = off > MaxOff ? -1\n        : off == line.length ? absoluteColumn(view, event.clientX)\n            : countColumn(line.text.slice(0, offset - line.from), 0, view.state.tabSize);\n    return { line: line.number, col, off };\n}\nfunction rectangleSelectionStyle(view, event) {\n    let start = getPos(view, event), startSel = view.state.selection;\n    if (!start)\n        return null;\n    return {\n        update(update) {\n            if (update.docChanged) {\n                let newStart = update.changes.mapPos(update.startState.doc.line(start.line).from);\n                let newLine = update.state.doc.lineAt(newStart);\n                start = { line: newLine.number, col: start.col, off: Math.min(start.off, newLine.length) };\n                startSel = startSel.map(update.changes);\n            }\n        },\n        get(event, _extend, multiple) {\n            let cur = getPos(view, event);\n            if (!cur)\n                return startSel;\n            let ranges = rectangleFor(view.state, start, cur);\n            if (!ranges.length)\n                return startSel;\n            if (multiple)\n                return EditorSelection.create(ranges.concat(startSel.ranges));\n            else\n                return EditorSelection.create(ranges);\n        }\n    };\n}\n/// Create an extension that enables rectangular selections. By\n/// default, it will react to left mouse drag with the Alt key held\n/// down. When such a selection occurs, the text within the rectangle\n/// that was dragged over will be selected, as one selection\n/// [range](#state.SelectionRange) per line.\nfunction rectangularSelection(options) {\n    let filter = (options === null || options === void 0 ? void 0 : options.eventFilter) || (e => e.altKey && e.button == 0);\n    return EditorView.mouseSelectionStyle.of((view, event) => filter(event) ? rectangleSelectionStyle(view, event) : null);\n}\n\nexport { rectangularSelection };\n","import { EditorView, themeClass, Decoration, ViewPlugin, runScopeHandlers } from '@codemirror/next/view';\nimport { StateEffect, StateField, EditorSelection, Facet, combineConfig, CharCategory, Prec } from '@codemirror/next/state';\nimport { showPanel, getPanel, panels } from '@codemirror/next/panel';\nimport { RangeSetBuilder } from '@codemirror/next/rangeset';\nimport elt from 'crelt';\nimport { findClusterBreak } from '@codemirror/next/text';\n\nconst basicNormalize = typeof String.prototype.normalize == \"function\" ? x => x.normalize(\"NFKD\") : x => x;\n/// A search cursor provides an iterator over text matches in a\n/// document.\nclass SearchCursor {\n    /// Create a text cursor. The query is the search string, `from` to\n    /// `to` provides the region to search.\n    ///\n    /// When `normalize` is given, it will be called, on both the query\n    /// string and the content it is matched against, before comparing.\n    /// You can, for example, create a case-insensitive search by\n    /// passing `s => s.toLowerCase()`.\n    ///\n    /// Text is always normalized with\n    /// [`.normalize(\"NFKD\")`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/normalize)\n    /// (when supported).\n    constructor(text, query, from = 0, to = text.length, normalize) {\n        /// The current match (only holds a meaningful value after\n        /// [`next`](#search.SearchCursor.next) has been called and when\n        /// `done` is false).\n        this.value = { from: 0, to: 0 };\n        /// Whether the end of the iterated region has been reached.\n        this.done = false;\n        this.matches = [];\n        this.buffer = \"\";\n        this.bufferPos = 0;\n        this.iter = text.iterRange(from, to);\n        this.bufferStart = from;\n        this.normalize = normalize ? x => normalize(basicNormalize(x)) : basicNormalize;\n        this.query = this.normalize(query);\n    }\n    peek() {\n        if (this.bufferPos == this.buffer.length) {\n            this.bufferStart += this.buffer.length;\n            this.iter.next();\n            if (this.iter.done)\n                return -1;\n            this.bufferPos = 0;\n            this.buffer = this.iter.value;\n        }\n        return this.buffer.charCodeAt(this.bufferPos);\n    }\n    /// Look for the next match. Updates the iterator's\n    /// [`value`](#search.SearchCursor.value) and\n    /// [`done`](#search.SearchCursor.done) properties. Should be called\n    /// at least once before using the cursor.\n    next() {\n        for (;;) {\n            let next = this.peek();\n            if (next < 0) {\n                this.done = true;\n                return this;\n            }\n            let str = String.fromCharCode(next), start = this.bufferStart + this.bufferPos;\n            this.bufferPos++;\n            for (;;) {\n                let peek = this.peek();\n                if (peek < 0xDC00 || peek >= 0xE000)\n                    break;\n                this.bufferPos++;\n                str += String.fromCharCode(peek);\n            }\n            let norm = this.normalize(str);\n            for (let i = 0, pos = start;; i++) {\n                let code = norm.charCodeAt(i);\n                let match = this.match(code, pos);\n                if (match) {\n                    this.value = match;\n                    return this;\n                }\n                if (i == norm.length - 1)\n                    break;\n                if (pos == start && i < str.length && str.charCodeAt(i) == code)\n                    pos++;\n            }\n        }\n    }\n    match(code, pos) {\n        let match = null;\n        for (let i = 0; i < this.matches.length; i += 2) {\n            let index = this.matches[i], keep = false;\n            if (this.query.charCodeAt(index) == code) {\n                if (index == this.query.length - 1) {\n                    match = { from: this.matches[i + 1], to: pos + 1 };\n                }\n                else {\n                    this.matches[i]++;\n                    keep = true;\n                }\n            }\n            if (!keep) {\n                this.matches.splice(i, 2);\n                i -= 2;\n            }\n        }\n        if (this.query.charCodeAt(0) == code) {\n            if (this.query.length == 1)\n                match = { from: pos, to: pos + 1 };\n            else\n                this.matches.push(1, pos);\n        }\n        return match;\n    }\n}\n\nfunction createLineDialog(view) {\n    let dom = document.createElement(\"form\");\n    dom.innerHTML = `<label>${view.state.phrase(\"Go to line:\")} <input class=${themeClass(\"textfield\")} name=line></label>\n<button class=${themeClass(\"button\")} type=submit>${view.state.phrase(\"go\")}</button>`;\n    let input = dom.querySelector(\"input\");\n    function go() {\n        let match = /^([+-])?(\\d+)?(:\\d+)?(%)?$/.exec(input.value);\n        if (!match)\n            return;\n        let { state } = view, startLine = state.doc.lineAt(state.selection.main.head);\n        let [, sign, ln, cl, percent] = match;\n        let col = cl ? +cl.slice(1) : 0;\n        let line = ln ? +ln : startLine.number;\n        if (ln && percent) {\n            let pc = line / 100;\n            if (sign)\n                pc = pc * (sign == \"-\" ? -1 : 1) + (startLine.number / state.doc.lines);\n            line = Math.round(state.doc.lines * pc);\n        }\n        else if (ln && sign) {\n            line = line * (sign == \"-\" ? -1 : 1) + startLine.number;\n        }\n        let docLine = state.doc.line(Math.max(1, Math.min(state.doc.lines, line)));\n        view.dispatch({\n            effects: dialogEffect.of(false),\n            selection: EditorSelection.cursor(docLine.from + Math.max(0, Math.min(col, docLine.length))),\n            scrollIntoView: true\n        });\n        view.focus();\n    }\n    dom.addEventListener(\"keydown\", event => {\n        if (event.keyCode == 27) { // Escape\n            event.preventDefault();\n            view.dispatch({ effects: dialogEffect.of(false) });\n            view.focus();\n        }\n        else if (event.keyCode == 13) { // Enter\n            event.preventDefault();\n            go();\n        }\n    });\n    dom.addEventListener(\"submit\", go);\n    return { dom, style: \"gotoLine\", pos: -10 };\n}\nconst dialogEffect = StateEffect.define();\nconst dialogField = StateField.define({\n    create() { return true; },\n    update(value, tr) {\n        for (let e of tr.effects)\n            if (e.is(dialogEffect))\n                value = e.value;\n        return value;\n    },\n    provide: f => showPanel.computeN([f], s => s.field(f) ? [createLineDialog] : [])\n});\n/// Command that shows a dialog asking the user for a line number, and\n/// when a valid position is provided, moves the cursor to that line.\n///\n/// Supports line numbers, relative line offsets prefixed with `+` or\n/// `-`, document percentages suffixed with `%`, and an optional\n/// column position by adding `:` and a second number after the line\n/// number.\n///\n/// The dialog can be styled with the `panel.gotoLine` theme\n/// selector.\nconst gotoLine = view => {\n    let panel = getPanel(view, createLineDialog);\n    if (!panel) {\n        view.dispatch({\n            reconfigure: view.state.field(dialogField, false) == null ? { append: [panels(), dialogField, baseTheme] } : undefined,\n            effects: dialogEffect.of(true)\n        });\n        panel = getPanel(view, createLineDialog);\n    }\n    if (panel)\n        panel.dom.querySelector(\"input\").focus();\n    return true;\n};\nconst baseTheme = EditorView.baseTheme({\n    \"$panel.gotoLine\": {\n        padding: \"2px 6px 4px\",\n        \"& label\": { fontSize: \"80%\" }\n    }\n});\n\nconst defaultHighlightOptions = {\n    highlightWordAroundCursor: false,\n    minSelectionLength: 1,\n    maxMatches: 100\n};\nconst highlightConfig = Facet.define({\n    combine(options) {\n        return combineConfig(options, defaultHighlightOptions, {\n            highlightWordAroundCursor: (a, b) => a || b,\n            minSelectionLength: Math.min,\n            maxMatches: Math.min\n        });\n    }\n});\n/// This extension highlights text that matches the selection. It uses\n/// the `$selectionMatch` theme class for the highlighting. When\n/// `highlightWordAroundCursor` is enabled, the word at the cursor\n/// itself will be highlighted with `selectionMatch.main`.\nfunction highlightSelectionMatches(options) {\n    let ext = [defaultTheme, matchHighlighter];\n    if (options)\n        ext.push(highlightConfig.of(options));\n    return ext;\n}\nfunction wordAt(doc, pos, check) {\n    let line = doc.lineAt(pos);\n    let from = pos - line.from, to = pos - line.from;\n    while (from > 0) {\n        let prev = findClusterBreak(line.text, from, false);\n        if (check(line.text.slice(prev, from)) != CharCategory.Word)\n            break;\n        from = prev;\n    }\n    while (to < line.length) {\n        let next = findClusterBreak(line.text, to);\n        if (check(line.text.slice(to, next)) != CharCategory.Word)\n            break;\n        to = next;\n    }\n    return from == to ? null : line.text.slice(from, to);\n}\nconst matchDeco = Decoration.mark({ class: themeClass(\"selectionMatch\") });\nconst mainMatchDeco = Decoration.mark({ class: themeClass(\"selectionMatch.main\") });\nconst matchHighlighter = ViewPlugin.fromClass(class {\n    constructor(view) {\n        this.decorations = this.getDeco(view);\n    }\n    update(update) {\n        if (update.selectionSet || update.docChanged || update.viewportChanged)\n            this.decorations = this.getDeco(update.view);\n    }\n    getDeco(view) {\n        let conf = view.state.facet(highlightConfig);\n        let { state } = view, sel = state.selection;\n        if (sel.ranges.length > 1)\n            return Decoration.none;\n        let range = sel.main, query, check = null;\n        if (range.empty) {\n            if (!conf.highlightWordAroundCursor)\n                return Decoration.none;\n            check = state.charCategorizer(range.head);\n            query = wordAt(state.doc, range.head, check);\n            if (!query)\n                return Decoration.none;\n        }\n        else {\n            let len = range.to - range.from;\n            if (len < conf.minSelectionLength || len > 200)\n                return Decoration.none;\n            query = state.sliceDoc(range.from, range.to).trim();\n            if (!query)\n                return Decoration.none;\n        }\n        let deco = [];\n        for (let part of view.visibleRanges) {\n            let cursor = new SearchCursor(state.doc, query, part.from, part.to);\n            while (!cursor.next().done) {\n                let { from, to } = cursor.value;\n                if (!check || ((from == 0 || check(state.sliceDoc(from - 1, from)) != CharCategory.Word) &&\n                    (to == state.doc.length || check(state.sliceDoc(to, to + 1)) != CharCategory.Word))) {\n                    if (check && from <= range.from && to >= range.to)\n                        deco.push(mainMatchDeco.range(from, to));\n                    else if (from >= range.to || to <= range.from)\n                        deco.push(matchDeco.range(from, to));\n                    if (deco.length > conf.maxMatches)\n                        return Decoration.none;\n                }\n            }\n        }\n        return Decoration.set(deco);\n    }\n}, {\n    decorations: v => v.decorations\n});\nconst defaultTheme = EditorView.baseTheme({\n    \"$selectionMatch\": { backgroundColor: \"#99ff7780\" },\n    \"$searchMatch $selectionMatch\": { backgroundColor: \"transparent\" }\n});\n\nclass Query {\n    constructor(search, replace, caseInsensitive) {\n        this.search = search;\n        this.replace = replace;\n        this.caseInsensitive = caseInsensitive;\n    }\n    eq(other) {\n        return this.search == other.search && this.replace == other.replace && this.caseInsensitive == other.caseInsensitive;\n    }\n    cursor(doc, from = 0, to = doc.length) {\n        return new SearchCursor(doc, this.search, from, to, this.caseInsensitive ? x => x.toLowerCase() : undefined);\n    }\n    get valid() { return !!this.search; }\n}\nconst setQuery = StateEffect.define();\nconst togglePanel = StateEffect.define();\nconst searchState = StateField.define({\n    create() {\n        return new SearchState(new Query(\"\", \"\", false), []);\n    },\n    update(value, tr) {\n        for (let effect of tr.effects) {\n            if (effect.is(setQuery))\n                value = new SearchState(effect.value, value.panel);\n            else if (effect.is(togglePanel))\n                value = new SearchState(value.query, effect.value ? [createSearchPanel] : []);\n        }\n        return value;\n    },\n    provide: f => showPanel.computeN([f], s => s.field(f).panel)\n});\nclass SearchState {\n    constructor(query, panel) {\n        this.query = query;\n        this.panel = panel;\n    }\n}\nconst matchMark = Decoration.mark({ class: themeClass(\"searchMatch\") }), selectedMatchMark = Decoration.mark({ class: themeClass(\"searchMatch.selected\") });\nconst searchHighlighter = ViewPlugin.fromClass(class {\n    constructor(view) {\n        this.view = view;\n        this.decorations = this.highlight(view.state.field(searchState));\n    }\n    update(update) {\n        let state = update.state.field(searchState);\n        if (state != update.startState.field(searchState) || update.docChanged || update.selectionSet)\n            this.decorations = this.highlight(state);\n    }\n    highlight({ query, panel }) {\n        if (!panel.length || !query.valid)\n            return Decoration.none;\n        let state = this.view.state, viewport = this.view.viewport;\n        let cursor = query.cursor(state.doc, Math.max(0, viewport.from - query.search.length), Math.min(viewport.to + query.search.length, state.doc.length));\n        let builder = new RangeSetBuilder();\n        while (!cursor.next().done) {\n            let { from, to } = cursor.value;\n            let selected = state.selection.ranges.some(r => r.from == from && r.to == to);\n            builder.add(from, to, selected ? selectedMatchMark : matchMark);\n        }\n        return builder.finish();\n    }\n}, {\n    decorations: v => v.decorations\n});\nfunction searchCommand(f) {\n    return view => {\n        let state = view.state.field(searchState, false);\n        return state && state.query.valid ? f(view, state) : openSearchPanel(view);\n    };\n}\nfunction findNextMatch(doc, from, query) {\n    let cursor = query.cursor(doc, from).next();\n    if (cursor.done) {\n        cursor = query.cursor(doc, 0, from + query.search.length - 1).next();\n        if (cursor.done)\n            return null;\n    }\n    return cursor.value;\n}\n/// Open the search panel if it isn't already open, and move the\n/// selection to the first match after the current main selection.\n/// Will wrap around to the start of the document when it reaches the\n/// end.\nconst findNext = searchCommand((view, state) => {\n    let { from, to } = view.state.selection.main;\n    let next = findNextMatch(view.state.doc, view.state.selection.main.from + 1, state.query);\n    if (!next || next.from == from && next.to == to)\n        return false;\n    view.dispatch({ selection: { anchor: next.from, head: next.to }, scrollIntoView: true });\n    maybeAnnounceMatch(view);\n    return true;\n});\nconst FindPrevChunkSize = 10000;\n// Searching in reverse is, rather than implementing inverted search\n// cursor, done by scanning chunk after chunk forward.\nfunction findPrevInRange(query, doc, from, to) {\n    for (let pos = to;;) {\n        let start = Math.max(from, pos - FindPrevChunkSize - query.search.length);\n        let cursor = query.cursor(doc, start, pos), range = null;\n        while (!cursor.next().done)\n            range = cursor.value;\n        if (range)\n            return range;\n        if (start == from)\n            return null;\n        pos -= FindPrevChunkSize;\n    }\n}\n/// Move the selection to the previous instance of the search query,\n/// before the current main selection. Will wrap past the start\n/// of the document to start searching at the end again.\nconst findPrevious = searchCommand((view, { query }) => {\n    let { state } = view;\n    let range = findPrevInRange(query, state.doc, 0, state.selection.main.to - 1) ||\n        findPrevInRange(query, state.doc, state.selection.main.from + 1, state.doc.length);\n    if (!range)\n        return false;\n    view.dispatch({ selection: { anchor: range.from, head: range.to }, scrollIntoView: true });\n    maybeAnnounceMatch(view);\n    return true;\n});\n/// Select all instances of the search query.\nconst selectMatches = searchCommand((view, { query }) => {\n    let cursor = query.cursor(view.state.doc), ranges = [];\n    while (!cursor.next().done)\n        ranges.push(EditorSelection.range(cursor.value.from, cursor.value.to));\n    if (!ranges.length)\n        return false;\n    view.dispatch({ selection: EditorSelection.create(ranges) });\n    return true;\n});\n/// Select all instances of the currently selected text.\nconst selectSelectionMatches = ({ state, dispatch }) => {\n    let sel = state.selection;\n    if (sel.ranges.length > 1 || sel.main.empty)\n        return false;\n    let { from, to } = sel.main;\n    let ranges = [], main = 0;\n    for (let cur = new SearchCursor(state.doc, state.sliceDoc(from, to)); !cur.next().done;) {\n        if (ranges.length > 1000)\n            return false;\n        if (cur.value.from == from)\n            main = ranges.length;\n        ranges.push(EditorSelection.range(cur.value.from, cur.value.to));\n    }\n    dispatch(state.update({ selection: new EditorSelection(ranges, main) }));\n    return true;\n};\n/// Replace the current match of the search query.\nconst replaceNext = searchCommand((view, { query }) => {\n    let { state } = view, next = findNextMatch(state.doc, state.selection.main.from, query);\n    if (!next)\n        return false;\n    let { from, to } = state.selection.main, changes = [], selection;\n    if (next.from == from && next.to == to) {\n        changes.push({ from: next.from, to: next.to, insert: query.replace });\n        next = findNextMatch(state.doc, next.to, query);\n    }\n    if (next) {\n        let off = changes.length == 0 || changes[0].from >= next.to ? 0 : next.to - next.from - query.replace.length;\n        selection = { anchor: next.from - off, head: next.to - off };\n    }\n    view.dispatch({ changes, selection, scrollIntoView: !!selection });\n    if (next)\n        maybeAnnounceMatch(view);\n    return true;\n});\n/// Replace all instances of the search query with the given\n/// replacement.\nconst replaceAll = searchCommand((view, { query }) => {\n    let cursor = query.cursor(view.state.doc), changes = [];\n    while (!cursor.next().done) {\n        let { from, to } = cursor.value;\n        changes.push({ from, to, insert: query.replace });\n    }\n    if (!changes.length)\n        return false;\n    view.dispatch({ changes });\n    return true;\n});\nfunction createSearchPanel(view) {\n    let { query } = view.state.field(searchState);\n    return {\n        dom: buildPanel({\n            view,\n            query,\n            updateQuery(q) {\n                if (!query.eq(q)) {\n                    query = q;\n                    view.dispatch({ effects: setQuery.of(query) });\n                }\n            }\n        }),\n        mount() {\n            this.dom.querySelector(\"[name=search]\").select();\n        },\n        pos: 80,\n        style: \"search\"\n    };\n}\n/// Make sure the search panel is open and focused.\nconst openSearchPanel = view => {\n    let state = view.state.field(searchState, false);\n    if (state && state.panel.length) {\n        let panel = getPanel(view, createSearchPanel);\n        if (!panel)\n            return false;\n        panel.dom.querySelector(\"[name=search]\").focus();\n    }\n    else {\n        view.dispatch({ effects: togglePanel.of(true),\n            reconfigure: state ? undefined : { append: searchExtensions } });\n    }\n    return true;\n};\n/// Close the search panel.\nconst closeSearchPanel = view => {\n    let state = view.state.field(searchState, false);\n    if (!state || !state.panel.length)\n        return false;\n    let panel = getPanel(view, createSearchPanel);\n    if (panel && panel.dom.contains(view.root.activeElement))\n        view.focus();\n    view.dispatch({ effects: togglePanel.of(false) });\n    return true;\n};\n/// Default search-related key bindings.\n///\n///  - Mod-f: [`openSearchPanel`](#search.openSearchPanel)\n///  - F3, Mod-g: [`findNext`](#search.findNext)\n///  - Shift-F3, Shift-Mod-g: [`findPrevious`](#search.findPrevious)\n///  - Alt-g: [`gotoLine`](#search.gotoLine)\nconst searchKeymap = [\n    { key: \"Mod-f\", run: openSearchPanel, scope: \"editor search-panel\" },\n    { key: \"F3\", run: findNext, shift: findPrevious, scope: \"editor search-panel\" },\n    { key: \"Mod-g\", run: findNext, shift: findPrevious, scope: \"editor search-panel\" },\n    { key: \"Escape\", run: closeSearchPanel, scope: \"editor search-panel\" },\n    { key: \"Mod-Shift-l\", run: selectSelectionMatches },\n    { key: \"Alt-g\", run: gotoLine }\n];\nfunction buildPanel(conf) {\n    function p(phrase) { return conf.view.state.phrase(phrase); }\n    let searchField = elt(\"input\", {\n        value: conf.query.search,\n        placeholder: p(\"Find\"),\n        \"aria-label\": p(\"Find\"),\n        class: themeClass(\"textfield\"),\n        name: \"search\",\n        onchange: update,\n        onkeyup: update\n    });\n    let replaceField = elt(\"input\", {\n        value: conf.query.replace,\n        placeholder: p(\"Replace\"),\n        \"aria-label\": p(\"Replace\"),\n        class: themeClass(\"textfield\"),\n        name: \"replace\",\n        onchange: update,\n        onkeyup: update\n    });\n    let caseField = elt(\"input\", {\n        type: \"checkbox\",\n        name: \"case\",\n        checked: !conf.query.caseInsensitive,\n        onchange: update\n    });\n    function update() {\n        conf.updateQuery(new Query(searchField.value, replaceField.value, !caseField.checked));\n    }\n    function keydown(e) {\n        if (runScopeHandlers(conf.view, e, \"search-panel\")) {\n            e.preventDefault();\n        }\n        else if (e.keyCode == 13 && e.target == searchField) {\n            e.preventDefault();\n            (e.shiftKey ? findPrevious : findNext)(conf.view);\n        }\n        else if (e.keyCode == 13 && e.target == replaceField) {\n            e.preventDefault();\n            replaceNext(conf.view);\n        }\n    }\n    function button(name, onclick, content) {\n        return elt(\"button\", { class: themeClass(\"button\"), name, onclick }, content);\n    }\n    let panel = elt(\"div\", { onkeydown: keydown }, [\n        searchField,\n        button(\"next\", () => findNext(conf.view), [p(\"next\")]),\n        button(\"prev\", () => findPrevious(conf.view), [p(\"previous\")]),\n        button(\"select\", () => selectMatches(conf.view), [p(\"all\")]),\n        elt(\"label\", null, [caseField, \"match case\"]),\n        elt(\"br\"),\n        replaceField,\n        button(\"replace\", () => replaceNext(conf.view), [p(\"replace\")]),\n        button(\"replaceAll\", () => replaceAll(conf.view), [p(\"replace all\")]),\n        elt(\"button\", { name: \"close\", onclick: () => closeSearchPanel(conf.view), \"aria-label\": p(\"close\") }, [\"×\"]),\n        elt(\"div\", { style: \"position: absolute; top: -10000px\", \"aria-live\": \"polite\" })\n    ]);\n    return panel;\n}\nconst AnnounceMargin = 30;\nconst Break = /[\\s\\.,:;?!]/;\n// FIXME this is a kludge\nfunction maybeAnnounceMatch(view) {\n    let { from, to } = view.state.selection.main;\n    let lineStart = view.state.doc.lineAt(from).from, lineEnd = view.state.doc.lineAt(to).to;\n    let start = Math.max(lineStart, from - AnnounceMargin), end = Math.min(lineEnd, to + AnnounceMargin);\n    let text = view.state.sliceDoc(start, end);\n    if (start != lineStart) {\n        for (let i = 0; i < AnnounceMargin; i++)\n            if (!Break.test(text[i + 1]) && Break.test(text[i])) {\n                text = text.slice(i);\n                break;\n            }\n    }\n    if (end != lineEnd) {\n        for (let i = text.length - 1; i > text.length - AnnounceMargin; i--)\n            if (!Break.test(text[i - 1]) && Break.test(text[i])) {\n                text = text.slice(0, i);\n                break;\n            }\n    }\n    let panel = getPanel(view, createSearchPanel);\n    if (!panel || !panel.dom.contains(view.root.activeElement))\n        return;\n    let live = panel.dom.querySelector(\"div[aria-live]\");\n    live.textContent = view.state.phrase(\"current match\") + \". \" + text;\n}\nconst baseTheme$1 = EditorView.baseTheme({\n    \"$panel.search\": {\n        padding: \"2px 6px 4px\",\n        position: \"relative\",\n        \"& [name=close]\": {\n            position: \"absolute\",\n            top: \"0\",\n            right: \"4px\",\n            backgroundColor: \"inherit\",\n            border: \"none\",\n            font: \"inherit\",\n            padding: 0,\n            margin: 0\n        },\n        \"& input, & button\": {\n            margin: \".2em .5em .2em 0\"\n        },\n        \"& label\": {\n            fontSize: \"80%\"\n        }\n    },\n    \"$$light $searchMatch\": { backgroundColor: \"#ffff0054\" },\n    \"$$dark $searchMatch\": { backgroundColor: \"#00ffff8a\" },\n    \"$$light $searchMatch.selected\": { backgroundColor: \"#ff6a0054\" },\n    \"$$dark $searchMatch.selected\": { backgroundColor: \"#ff00ff8a\" }\n});\nconst searchExtensions = [\n    searchState,\n    Prec.override(searchHighlighter),\n    panels(),\n    baseTheme$1\n];\n\nexport { SearchCursor, closeSearchPanel, findNext, findPrevious, gotoLine, highlightSelectionMatches, openSearchPanel, replaceAll, replaceNext, searchKeymap, selectMatches, selectSelectionMatches };\n","import { Text } from '@codemirror/next/text';\nexport { Text } from '@codemirror/next/text';\n\nconst DefaultSplit = /\\r\\n?|\\n/;\n/// Distinguishes different ways in which positions can be mapped.\nvar MapMode;\n(function (MapMode) {\n    /// Map a position to a valid new position, even when its context\n    /// was deleted.\n    MapMode[MapMode[\"Simple\"] = 0] = \"Simple\";\n    /// Return null if deletion happens across the position.\n    MapMode[MapMode[\"TrackDel\"] = 1] = \"TrackDel\";\n    /// Return null if the character _before_ the position is deleted.\n    MapMode[MapMode[\"TrackBefore\"] = 2] = \"TrackBefore\";\n    /// Return null if the character _after_ the position is deleted.\n    MapMode[MapMode[\"TrackAfter\"] = 3] = \"TrackAfter\";\n})(MapMode || (MapMode = {}));\n/// A change description is a variant of [change set](#state.ChangeSet)\n/// that doesn't store the inserted text. As such, it can't be\n/// applied, but is cheaper to store and manipulate.\nclass ChangeDesc {\n    // Sections are encoded as pairs of integers. The first is the\n    // length in the current document, and the second is -1 for\n    // unaffected sections, and the length of the replacement content\n    // otherwise. So an insertion would be (0, n>0), a deletion (n>0,\n    // 0), and a replacement two positive numbers.\n    /// @internal\n    constructor(\n    /// @internal\n    sections) {\n        this.sections = sections;\n    }\n    /// The length of the document before the change.\n    get length() {\n        let result = 0;\n        for (let i = 0; i < this.sections.length; i += 2)\n            result += this.sections[i];\n        return result;\n    }\n    /// The length of the document after the change.\n    get newLength() {\n        let result = 0;\n        for (let i = 0; i < this.sections.length; i += 2) {\n            let ins = this.sections[i + 1];\n            result += ins < 0 ? this.sections[i] : ins;\n        }\n        return result;\n    }\n    /// False when there are actual changes in this set.\n    get empty() { return this.sections.length == 0 || this.sections.length == 2 && this.sections[1] < 0; }\n    /// Iterate over the unchanged parts left by these changes.\n    iterGaps(f) {\n        for (let i = 0, posA = 0, posB = 0; i < this.sections.length;) {\n            let len = this.sections[i++], ins = this.sections[i++];\n            if (ins < 0) {\n                f(posA, posB, len);\n                posB += len;\n            }\n            else {\n                posB += ins;\n            }\n            posA += len;\n        }\n    }\n    /// Iterate over the ranges changed by these changes. (See\n    /// [`ChangeSet.iterChanges`](#state.ChangeSet.iterChanges) for a\n    /// variant that also provides you with the inserted text.)\n    ///\n    /// When `individual` is true, adjacent changes (which are kept\n    /// separate for [position mapping](#state.ChangeDesc.mapPos)) are\n    /// reported separately.\n    iterChangedRanges(f, individual = false) {\n        iterChanges(this, f, individual);\n    }\n    /// Get a description of the inverted form of these changes.\n    get invertedDesc() {\n        let sections = [];\n        for (let i = 0; i < this.sections.length;) {\n            let len = this.sections[i++], ins = this.sections[i++];\n            if (ins < 0)\n                sections.push(len, ins);\n            else\n                sections.push(ins, len);\n        }\n        return new ChangeDesc(sections);\n    }\n    /// Compute the combined effect of applying another set of changes\n    /// after this one. The length of the document after this set should\n    /// match the length before `other`.\n    composeDesc(other) { return this.empty ? other : other.empty ? this : composeSets(this, other); }\n    /// Map this description, which should start with the same document\n    /// as `other`, over another set of changes, so that it can be\n    /// applied after it. When `before` is true, map as if the changes\n    /// in `other` happened before the ones in `this`.\n    mapDesc(other, before = false) { return other.empty ? this : mapSet(this, other, before); }\n    mapPos(pos, assoc = -1, mode = MapMode.Simple) {\n        let posA = 0, posB = 0;\n        for (let i = 0; i < this.sections.length;) {\n            let len = this.sections[i++], ins = this.sections[i++], endA = posA + len;\n            if (ins < 0) {\n                if (endA > pos)\n                    return posB + (pos - posA);\n                posB += len;\n            }\n            else {\n                if (mode != MapMode.Simple && endA >= pos &&\n                    (mode == MapMode.TrackDel && posA < pos && endA > pos ||\n                        mode == MapMode.TrackBefore && posA < pos ||\n                        mode == MapMode.TrackAfter && endA > pos))\n                    return null;\n                if (endA > pos || endA == pos && assoc < 0 && !len)\n                    return pos == posA || assoc < 0 ? posB : posB + ins;\n                posB += ins;\n            }\n            posA = endA;\n        }\n        if (pos > posA)\n            throw new RangeError(`Position ${pos} is out of range for changeset of length ${posA}`);\n        return posB;\n    }\n    /// Check whether these changes touch a given range. When one of the\n    /// changes entirely covers the range, the string `\"cover\"` is\n    /// returned.\n    touchesRange(from, to = from) {\n        for (let i = 0, pos = 0; i < this.sections.length && pos <= to;) {\n            let len = this.sections[i++], ins = this.sections[i++], end = pos + len;\n            if (ins >= 0 && pos <= to && end >= from)\n                return pos < from && end > to ? \"cover\" : true;\n            pos = end;\n        }\n        return false;\n    }\n    /// @internal\n    toString() {\n        let result = \"\";\n        for (let i = 0; i < this.sections.length;) {\n            let len = this.sections[i++], ins = this.sections[i++];\n            result += (result ? \" \" : \"\") + len + (ins >= 0 ? \":\" + ins : \"\");\n        }\n        return result;\n    }\n}\n/// A change set represents a group of modifications to a document. It\n/// stores the document length, and can only be applied to documents\n/// with exactly that length.\nclass ChangeSet extends ChangeDesc {\n    /// @internal\n    constructor(sections, \n    /// @internal\n    inserted) {\n        super(sections);\n        this.inserted = inserted;\n    }\n    /// Apply the changes to a document, returning the modified\n    /// document.\n    apply(doc) {\n        if (this.length != doc.length)\n            throw new RangeError(\"Applying change set to a document with the wrong length\");\n        iterChanges(this, (fromA, toA, fromB, _toB, text) => doc = doc.replace(fromB, fromB + (toA - fromA), text), false);\n        return doc;\n    }\n    mapDesc(other, before = false) { return mapSet(this, other, before, true); }\n    /// Given the document as it existed _before_ the changes, return a\n    /// change set that represents the inverse of this set, which could\n    /// be used to go from the document created by the changes back to\n    /// the document as it existed before the changes.\n    invert(doc) {\n        let sections = this.sections.slice(), inserted = [];\n        for (let i = 0, pos = 0; i < sections.length; i += 2) {\n            let len = sections[i], ins = sections[i + 1];\n            if (ins >= 0) {\n                sections[i] = ins;\n                sections[i + 1] = len;\n                let index = i >> 1;\n                while (inserted.length < index)\n                    inserted.push(Text.empty);\n                inserted.push(len ? doc.slice(pos, pos + len) : Text.empty);\n            }\n            pos += len;\n        }\n        return new ChangeSet(sections, inserted);\n    }\n    /// Combine two subsequent change sets into a single set. `other`\n    /// must start in the document produced by `this`. If `this` goes\n    /// `docA` → `docB` and `other` represents `docB` → `docC`, the\n    /// returned value will represent the change `docA` → `docC`.\n    compose(other) { return this.empty ? other : other.empty ? this : composeSets(this, other, true); }\n    /// Given another change set starting in the same document, maps this\n    /// change set over the other, producing a new change set that can be\n    /// applied to the document produced by applying `other`. When\n    /// `before` is `true`, order changes as if `this` comes before\n    /// `other`, otherwise (the default) treat `other` as coming first.\n    ///\n    /// Given two changes `A` and `B`, `A.compose(B.map(A))` and\n    /// `B.compose(A.map(B, true))` will produce the same document. This\n    /// provides a basic form of [operational\n    /// transformation](https://en.wikipedia.org/wiki/Operational_transformation),\n    /// and can be used for collaborative editing.\n    map(other, before = false) { return other.empty ? this : mapSet(this, other, before, true); }\n    /// Iterate over the changed ranges in the document, calling `f` for\n    /// each.\n    ///\n    /// When `individual` is true, adjacent changes are reported\n    /// separately.\n    iterChanges(f, individual = false) {\n        iterChanges(this, f, individual);\n    }\n    /// Get a [change description](#state.ChangeDesc) for this change\n    /// set.\n    get desc() { return new ChangeDesc(this.sections); }\n    /// @internal\n    filter(ranges) {\n        let resultSections = [], resultInserted = [], filteredSections = [];\n        let iter = new SectionIter(this);\n        done: for (let i = 0, pos = 0;;) {\n            let next = i == ranges.length ? 1e9 : ranges[i++];\n            while (pos < next || pos == next && iter.len == 0) {\n                if (iter.done)\n                    break done;\n                let len = Math.min(iter.len, next - pos);\n                addSection(filteredSections, len, -1);\n                let ins = iter.ins == -1 ? -1 : iter.off == 0 ? iter.ins : 0;\n                addSection(resultSections, len, ins);\n                if (ins > 0)\n                    addInsert(resultInserted, resultSections, iter.text);\n                iter.forward(len);\n                pos += len;\n            }\n            let end = ranges[i++];\n            while (pos < end) {\n                if (iter.done)\n                    break done;\n                let len = Math.min(iter.len, end - pos);\n                addSection(resultSections, len, -1);\n                addSection(filteredSections, len, iter.ins == -1 ? -1 : iter.off == 0 ? iter.ins : 0);\n                iter.forward(len);\n                pos += len;\n            }\n        }\n        return { changes: new ChangeSet(resultSections, resultInserted),\n            filtered: new ChangeDesc(filteredSections) };\n    }\n    /// Serialize this change set to a JSON-representable value.\n    toJSON() {\n        let parts = [];\n        for (let i = 0; i < this.sections.length; i += 2) {\n            let len = this.sections[i], ins = this.sections[i + 1];\n            if (ins < 0)\n                parts.push(len);\n            else if (ins == 0)\n                parts.push([len]);\n            else\n                parts.push([len].concat(this.inserted[i >> 1].toJSON()));\n        }\n        return parts;\n    }\n    /// Create a change set for the given changes, for a document of the\n    /// given length, using `lineSep` as line separator.\n    static of(changes, length, lineSep) {\n        let sections = [], inserted = [], pos = 0;\n        let total = null;\n        function flush(force = false) {\n            if (!force && !sections.length)\n                return;\n            if (pos < length)\n                addSection(sections, length - pos, -1);\n            let set = new ChangeSet(sections, inserted);\n            total = total ? total.compose(set.map(total)) : set;\n            sections = [];\n            inserted = [];\n            pos = 0;\n        }\n        function process(spec) {\n            if (Array.isArray(spec)) {\n                for (let sub of spec)\n                    process(sub);\n            }\n            else if (spec instanceof ChangeSet) {\n                if (spec.length != length)\n                    throw new RangeError(`Mismatched change set length (got ${spec.length}, expected ${length})`);\n                flush();\n                total = total ? total.compose(spec.map(total)) : spec;\n            }\n            else {\n                let { from, to = from, insert } = spec;\n                if (from > to || from < 0 || to > length)\n                    throw new RangeError(`Invalid change range ${from} to ${to} (in doc of length ${length})`);\n                let insText = !insert ? Text.empty : typeof insert == \"string\" ? Text.of(insert.split(lineSep || DefaultSplit)) : insert;\n                let insLen = insText.length;\n                if (from == to && insLen == 0)\n                    return;\n                if (from < pos)\n                    flush();\n                if (from > pos)\n                    addSection(sections, from - pos, -1);\n                addSection(sections, to - from, insLen);\n                addInsert(inserted, sections, insText);\n                pos = to;\n            }\n        }\n        process(changes);\n        flush(!total);\n        return total;\n    }\n    /// Create an empty changeset of the given length.\n    static empty(length) {\n        return new ChangeSet(length ? [length, -1] : [], []);\n    }\n    /// Create a changeset from its JSON representation (as produced by\n    /// [`toJSON`](#state.ChangeSet.toJSON).\n    static fromJSON(json) {\n        if (!Array.isArray(json))\n            throw new RangeError(\"Invalid JSON representation of ChangeSet\");\n        let sections = [], inserted = [];\n        for (let i = 0; i < json.length; i++) {\n            let part = json[i];\n            if (typeof part == \"number\") {\n                sections.push(part, -1);\n            }\n            else if (!Array.isArray(part) || typeof part[0] != \"number\" || part.some((e, i) => i && typeof e != \"string\")) {\n                throw new RangeError(\"Invalid JSON representation of ChangeSet\");\n            }\n            else if (part.length == 1) {\n                sections.push(part[0], 0);\n            }\n            else {\n                while (inserted.length < i)\n                    inserted.push(Text.empty);\n                inserted[i] = Text.of(part.slice(1));\n                sections.push(part[0], inserted[i].length);\n            }\n        }\n        return new ChangeSet(sections, inserted);\n    }\n}\nfunction addSection(sections, len, ins, forceJoin = false) {\n    if (len == 0 && ins <= 0)\n        return;\n    let last = sections.length - 2;\n    if (last >= 0 && ins <= 0 && ins == sections[last + 1])\n        sections[last] += len;\n    else if (len == 0 && sections[last] == 0)\n        sections[last + 1] += ins;\n    else if (forceJoin) {\n        sections[last] += len;\n        sections[last + 1] += ins;\n    }\n    else\n        sections.push(len, ins);\n}\nfunction addInsert(values, sections, value) {\n    if (value.length == 0)\n        return;\n    let index = (sections.length - 2) >> 1;\n    if (index < values.length) {\n        values[values.length - 1] = values[values.length - 1].append(value);\n    }\n    else {\n        while (values.length < index)\n            values.push(Text.empty);\n        values.push(value);\n    }\n}\nfunction iterChanges(desc, f, individual) {\n    let inserted = desc.inserted;\n    for (let posA = 0, posB = 0, i = 0; i < desc.sections.length;) {\n        let len = desc.sections[i++], ins = desc.sections[i++];\n        if (ins < 0) {\n            posA += len;\n            posB += len;\n        }\n        else {\n            let endA = posA, endB = posB, text = Text.empty;\n            for (;;) {\n                endA += len;\n                endB += ins;\n                if (ins && inserted)\n                    text = text.append(inserted[(i - 2) >> 1]);\n                if (individual || i == desc.sections.length || desc.sections[i + 1] < 0)\n                    break;\n                len = desc.sections[i++];\n                ins = desc.sections[i++];\n            }\n            f(posA, endA, posB, endB, text);\n            posA = endA;\n            posB = endB;\n        }\n    }\n}\nfunction mapSet(setA, setB, before, mkSet = false) {\n    let sections = [], insert = mkSet ? [] : null;\n    let a = new SectionIter(setA), b = new SectionIter(setB);\n    for (let posA = 0, posB = 0;;) {\n        if (a.ins == -1) {\n            posA += a.len;\n            a.next();\n        }\n        else if (b.ins == -1 && posB < posA) {\n            let skip = Math.min(b.len, posA - posB);\n            b.forward(skip);\n            addSection(sections, skip, -1);\n            posB += skip;\n        }\n        else if (b.ins >= 0 && (a.done || posB < posA || posB == posA && (b.len < a.len || b.len == a.len && !before))) {\n            addSection(sections, b.ins, -1);\n            while (posA > posB && !a.done && posA + a.len < posB + b.len) {\n                posA += a.len;\n                a.next();\n            }\n            posB += b.len;\n            b.next();\n        }\n        else if (a.ins >= 0) {\n            let len = 0, end = posA + a.len;\n            for (;;) {\n                if (b.ins >= 0 && posB > posA && posB + b.len < end) {\n                    len += b.ins;\n                    posB += b.len;\n                    b.next();\n                }\n                else if (b.ins == -1 && posB < end) {\n                    let skip = Math.min(b.len, end - posB);\n                    len += skip;\n                    b.forward(skip);\n                    posB += skip;\n                }\n                else {\n                    break;\n                }\n            }\n            addSection(sections, len, a.ins);\n            if (insert)\n                addInsert(insert, sections, a.text);\n            posA = end;\n            a.next();\n        }\n        else if (a.done && b.done) {\n            return insert ? new ChangeSet(sections, insert) : new ChangeDesc(sections);\n        }\n        else {\n            throw new Error(\"Mismatched change set lengths\");\n        }\n    }\n}\nfunction composeSets(setA, setB, mkSet = false) {\n    let sections = [];\n    let insert = mkSet ? [] : null;\n    let a = new SectionIter(setA), b = new SectionIter(setB);\n    for (let open = false;;) {\n        if (a.done && b.done) {\n            return insert ? new ChangeSet(sections, insert) : new ChangeDesc(sections);\n        }\n        else if (a.ins == 0) { // Deletion in A\n            addSection(sections, a.len, 0, open);\n            a.next();\n        }\n        else if (b.len == 0 && !b.done) { // Insertion in B\n            addSection(sections, 0, b.ins, open);\n            if (insert)\n                addInsert(insert, sections, b.text);\n            b.next();\n        }\n        else if (a.done || b.done) {\n            throw new Error(\"Mismatched change set lengths\");\n        }\n        else {\n            let len = Math.min(a.len2, b.len), sectionLen = sections.length;\n            if (a.ins == -1) {\n                let insB = b.ins == -1 ? -1 : b.off ? 0 : b.ins;\n                addSection(sections, len, insB, open);\n                if (insert && insB)\n                    addInsert(insert, sections, b.text);\n            }\n            else if (b.ins == -1) {\n                addSection(sections, a.off ? 0 : a.len, len, open);\n                if (insert)\n                    addInsert(insert, sections, a.textBit(len));\n            }\n            else {\n                addSection(sections, a.off ? 0 : a.len, b.off ? 0 : b.ins, open);\n                if (insert && !b.off)\n                    addInsert(insert, sections, b.text);\n            }\n            open = (a.ins > len || b.ins >= 0 && b.len > len) && (open || sections.length > sectionLen);\n            a.forward2(len);\n            b.forward(len);\n        }\n    }\n}\nclass SectionIter {\n    constructor(set) {\n        this.set = set;\n        this.i = 0;\n        this.next();\n    }\n    next() {\n        let { sections } = this.set;\n        if (this.i < sections.length) {\n            this.len = sections[this.i++];\n            this.ins = sections[this.i++];\n        }\n        else {\n            this.len = 0;\n            this.ins = -2;\n        }\n        this.off = 0;\n    }\n    get done() { return this.ins == -2; }\n    get len2() { return this.ins < 0 ? this.len : this.ins; }\n    get text() {\n        let { inserted } = this.set, index = (this.i - 2) >> 1;\n        return index >= inserted.length ? Text.empty : inserted[index];\n    }\n    textBit(len) {\n        let { inserted } = this.set, index = (this.i - 2) >> 1;\n        return index >= inserted.length && !len ? Text.empty\n            : inserted[index].slice(this.off, len == null ? undefined : this.off + len);\n    }\n    forward(len) {\n        if (len == this.len)\n            this.next();\n        else {\n            this.len -= len;\n            this.off += len;\n        }\n    }\n    forward2(len) {\n        if (this.ins == -1)\n            this.forward(len);\n        else if (len == this.ins)\n            this.next();\n        else {\n            this.ins -= len;\n            this.off += len;\n        }\n    }\n}\n\n/// A single selection range. When\n/// [`allowMultipleSelections`](#state.EditorState^allowMultipleSelections)\n/// is enabled, a [selection](#state.EditorSelection) may hold\n/// multiple ranges. By default, selections hold exactly one range.\nclass SelectionRange {\n    /// @internal\n    constructor(\n    /// The lower boundary of the range.\n    from, \n    /// The upper boundary of the range.\n    to, flags) {\n        this.from = from;\n        this.to = to;\n        this.flags = flags;\n    }\n    /// The anchor of the range—the side that doesn't move when you\n    /// extend it.\n    get anchor() { return this.flags & 16 /* Inverted */ ? this.to : this.from; }\n    /// The head of the range, which is moved when the range is\n    /// [extended](#state.SelectionRange.extend).\n    get head() { return this.flags & 16 /* Inverted */ ? this.from : this.to; }\n    /// True when `anchor` and `head` are at the same position.\n    get empty() { return this.from == this.to; }\n    /// If this is a cursor that is explicitly associated with the\n    /// character on one of its sides, this returns the side. -1 means\n    /// the character before its position, 1 the character after, and 0\n    /// means no association.\n    get assoc() { return this.flags & 4 /* AssocBefore */ ? -1 : this.flags & 8 /* AssocAfter */ ? 1 : 0; }\n    /// The bidirectional text level associated with this cursor, if\n    /// any.\n    get bidiLevel() {\n        let level = this.flags & 3 /* BidiLevelMask */;\n        return level == 3 ? null : level;\n    }\n    /// The goal column (stored vertical offset) associated with a\n    /// cursor. This is used to preserve the vertical position when\n    /// [moving](#view.EditorView.moveVertically) across\n    /// lines of different length.\n    get goalColumn() {\n        let value = this.flags >> 5 /* GoalColumnOffset */;\n        return value == 33554431 /* NoGoalColumn */ ? undefined : value;\n    }\n    /// Map this range through a change, producing a valid range in the\n    /// updated document.\n    map(change) {\n        let from = change.mapPos(this.from), to = change.mapPos(this.to);\n        return from == this.from && to == this.to ? this : new SelectionRange(from, to, this.flags);\n    }\n    /// Extend this range to cover at least `from` to `to`.\n    extend(from, to = from) {\n        if (from <= this.anchor && to >= this.anchor)\n            return EditorSelection.range(from, to);\n        let head = Math.abs(from - this.anchor) > Math.abs(to - this.anchor) ? from : to;\n        return EditorSelection.range(this.anchor, head);\n    }\n    /// Compare this range to another range.\n    eq(other) {\n        return this.anchor == other.anchor && this.head == other.head;\n    }\n    /// Return a JSON-serializable object representing the range.\n    toJSON() { return { anchor: this.anchor, head: this.head }; }\n    /// Convert a JSON representation of a range to a `SelectionRange`\n    /// instance.\n    static fromJSON(json) {\n        if (!json || typeof json.anchor != \"number\" || typeof json.head != \"number\")\n            throw new RangeError(\"Invalid JSON representation for SelectionRange\");\n        return EditorSelection.range(json.anchor, json.head);\n    }\n}\n/// An editor selection holds one or more selection ranges.\nclass EditorSelection {\n    /// @internal\n    constructor(\n    /// The ranges in the selection, sorted by position. Ranges cannot\n    /// overlap (but they may touch, if they aren't empty).\n    ranges, \n    /// The index of the _main_ range in the selection (which is\n    /// usually the range that was added last).\n    mainIndex = 0) {\n        this.ranges = ranges;\n        this.mainIndex = mainIndex;\n    }\n    /// Map a selection through a change. Used to adjust the selection\n    /// position for changes.\n    map(change) {\n        if (change.empty)\n            return this;\n        return EditorSelection.create(this.ranges.map(r => r.map(change)), this.mainIndex);\n    }\n    /// Compare this selection to another selection.\n    eq(other) {\n        if (this.ranges.length != other.ranges.length ||\n            this.mainIndex != other.mainIndex)\n            return false;\n        for (let i = 0; i < this.ranges.length; i++)\n            if (!this.ranges[i].eq(other.ranges[i]))\n                return false;\n        return true;\n    }\n    /// Get the primary selection range. Usually, you should make sure\n    /// your code applies to _all_ ranges, by using methods like\n    /// [`changeByRange`](#state.EditorState.changeByRange).\n    get main() { return this.ranges[this.mainIndex]; }\n    /// Make sure the selection only has one range. Returns a selection\n    /// holding only the main range from this selection.\n    asSingle() {\n        return this.ranges.length == 1 ? this : new EditorSelection([this.main]);\n    }\n    /// Extend this selection with an extra range.\n    addRange(range, main = true) {\n        return EditorSelection.create([range].concat(this.ranges), main ? 0 : this.mainIndex + 1);\n    }\n    /// Replace a given range with another range, and then normalize the\n    /// selection to merge and sort ranges if necessary.\n    replaceRange(range, which = this.mainIndex) {\n        let ranges = this.ranges.slice();\n        ranges[which] = range;\n        return EditorSelection.create(ranges, this.mainIndex);\n    }\n    /// Convert this selection to an object that can be serialized to\n    /// JSON.\n    toJSON() {\n        return { ranges: this.ranges.map(r => r.toJSON()), main: this.mainIndex };\n    }\n    /// Create a selection from a JSON representation.\n    static fromJSON(json) {\n        if (!json || !Array.isArray(json.ranges) || typeof json.main != \"number\" || json.main >= json.ranges.length)\n            throw new RangeError(\"Invalid JSON representation for EditorSelection\");\n        return new EditorSelection(json.ranges.map((r) => SelectionRange.fromJSON(r)), json.main);\n    }\n    /// Create a selection holding a single range.\n    static single(anchor, head = anchor) {\n        return new EditorSelection([EditorSelection.range(anchor, head)], 0);\n    }\n    /// Sort and merge the given set of ranges, creating a valid\n    /// selection.\n    static create(ranges, mainIndex = 0) {\n        if (ranges.length == 0)\n            throw new RangeError(\"A selection needs at least one range\");\n        for (let pos = 0, i = 0; i < ranges.length; i++) {\n            let range = ranges[i];\n            if (range.empty ? range.from <= pos : range.from < pos)\n                return normalized(ranges.slice(), mainIndex);\n            pos = range.to;\n        }\n        return new EditorSelection(ranges, mainIndex);\n    }\n    /// Create a cursor selection range at the given position. You can\n    /// safely ignore the optional arguments in most situations.\n    static cursor(pos, assoc = 0, bidiLevel, goalColumn) {\n        return new SelectionRange(pos, pos, (assoc == 0 ? 0 : assoc < 0 ? 4 /* AssocBefore */ : 8 /* AssocAfter */) |\n            (bidiLevel == null ? 3 : Math.min(2, bidiLevel)) |\n            ((goalColumn !== null && goalColumn !== void 0 ? goalColumn : 33554431 /* NoGoalColumn */) << 5 /* GoalColumnOffset */));\n    }\n    /// Create a selection range.\n    static range(anchor, head, goalColumn) {\n        let goal = (goalColumn !== null && goalColumn !== void 0 ? goalColumn : 33554431 /* NoGoalColumn */) << 5 /* GoalColumnOffset */;\n        return head < anchor ? new SelectionRange(head, anchor, 16 /* Inverted */ | goal) : new SelectionRange(anchor, head, goal);\n    }\n}\nfunction normalized(ranges, mainIndex = 0) {\n    let main = ranges[mainIndex];\n    ranges.sort((a, b) => a.from - b.from);\n    mainIndex = ranges.indexOf(main);\n    for (let i = 1; i < ranges.length; i++) {\n        let range = ranges[i], prev = ranges[i - 1];\n        if (range.empty ? range.from <= prev.to : range.from < prev.to) {\n            let from = prev.from, to = Math.max(range.to, prev.to);\n            if (i <= mainIndex)\n                mainIndex--;\n            ranges.splice(--i, 2, range.anchor > range.head ? EditorSelection.range(to, from) : EditorSelection.range(from, to));\n        }\n    }\n    return new EditorSelection(ranges, mainIndex);\n}\nfunction checkSelection(selection, docLength) {\n    for (let range of selection.ranges)\n        if (range.to > docLength)\n            throw new RangeError(\"Selection points outside of document\");\n}\n\nlet nextID = 0;\n/// A facet is a labeled value that is associated with an editor\n/// state. It takes inputs from any number of extensions, and combines\n/// those into a single output value.\n///\n/// Examples of facets are the [theme](#view.EditorView^theme) styles\n/// associated with an editor or the [tab\n/// size](#state.EditorState^tabSize) (which is reduced to a single\n/// value, using the input with the hightest precedence).\nclass Facet {\n    constructor(\n    /// @internal\n    combine, \n    /// @internal\n    compareInput, \n    /// @internal\n    compare, isStatic, \n    /// @internal\n    extensions) {\n        this.combine = combine;\n        this.compareInput = compareInput;\n        this.compare = compare;\n        this.isStatic = isStatic;\n        this.extensions = extensions;\n        /// @internal\n        this.id = nextID++;\n        this.default = combine([]);\n    }\n    /// Define a new facet.\n    static define(config = {}) {\n        return new Facet(config.combine || ((a) => a), config.compareInput || ((a, b) => a === b), config.compare || (!config.combine ? sameArray : (a, b) => a === b), !!config.static, config.enables);\n    }\n    /// Returns an extension that adds the given value for this facet.\n    of(value) {\n        return new FacetProvider([], this, 0 /* Static */, value);\n    }\n    /// Create an extension that computes a value for the facet from a\n    /// state. You must take care to declare the parts of the state that\n    /// this value depends on, since your function is only called again\n    /// for a new state when one of those parts changed.\n    ///\n    /// In most cases, you'll want to use the\n    /// [`provide`](#state.StateField^define^config.provide) option when\n    /// defining a field instead.\n    compute(deps, get) {\n        if (this.isStatic)\n            throw new Error(\"Can't compute a static facet\");\n        return new FacetProvider(deps, this, 1 /* Single */, get);\n    }\n    /// Create an extension that computes zero or more values for this\n    /// facet from a state.\n    computeN(deps, get) {\n        if (this.isStatic)\n            throw new Error(\"Can't compute a static facet\");\n        return new FacetProvider(deps, this, 2 /* Multi */, get);\n    }\n    from(field, get) {\n        if (!get)\n            get = x => x;\n        return this.compute([field], state => get(state.field(field)));\n    }\n}\nfunction sameArray(a, b) {\n    return a == b || a.length == b.length && a.every((e, i) => e === b[i]);\n}\nclass FacetProvider {\n    constructor(dependencies, facet, type, value) {\n        this.dependencies = dependencies;\n        this.facet = facet;\n        this.type = type;\n        this.value = value;\n        this.id = nextID++;\n    }\n    dynamicSlot(addresses) {\n        var _a;\n        let getter = this.value;\n        let compare = this.facet.compareInput;\n        let idx = addresses[this.id] >> 1, multi = this.type == 2 /* Multi */;\n        let depDoc = false, depSel = false, depAddrs = [];\n        for (let dep of this.dependencies) {\n            if (dep == \"doc\")\n                depDoc = true;\n            else if (dep == \"selection\")\n                depSel = true;\n            else if ((((_a = addresses[dep.id]) !== null && _a !== void 0 ? _a : 1) & 1) == 0)\n                depAddrs.push(addresses[dep.id]);\n        }\n        return (state, tr) => {\n            if (!tr || tr.reconfigure) {\n                state.values[idx] = getter(state);\n                return 1 /* Changed */;\n            }\n            else {\n                let depChanged = (depDoc && tr.docChanged) || (depSel && (tr.docChanged || tr.selection)) ||\n                    depAddrs.some(addr => (ensureAddr(state, addr) & 1 /* Changed */) > 0);\n                if (!depChanged)\n                    return 0;\n                let newVal = getter(state), oldVal = tr.startState.values[idx];\n                if (multi ? compareArray(newVal, oldVal, compare) : compare(newVal, oldVal))\n                    return 0;\n                state.values[idx] = newVal;\n                return 1 /* Changed */;\n            }\n        };\n    }\n}\nfunction compareArray(a, b, compare) {\n    if (a.length != b.length)\n        return false;\n    for (let i = 0; i < a.length; i++)\n        if (!compare(a[i], b[i]))\n            return false;\n    return true;\n}\nfunction dynamicFacetSlot(addresses, facet, providers) {\n    let providerAddrs = providers.map(p => addresses[p.id]);\n    let providerTypes = providers.map(p => p.type);\n    let dynamic = providerAddrs.filter(p => !(p & 1));\n    let idx = addresses[facet.id] >> 1;\n    return (state, tr) => {\n        let oldAddr = !tr ? null : tr.reconfigure ? tr.startState.config.address[facet.id] : idx << 1;\n        let changed = oldAddr == null;\n        for (let dynAddr of dynamic) {\n            if (ensureAddr(state, dynAddr) & 1 /* Changed */)\n                changed = true;\n        }\n        if (!changed)\n            return 0;\n        let values = [];\n        for (let i = 0; i < providerAddrs.length; i++) {\n            let value = getAddr(state, providerAddrs[i]);\n            if (providerTypes[i] == 2 /* Multi */)\n                for (let val of value)\n                    values.push(val);\n            else\n                values.push(value);\n        }\n        let newVal = facet.combine(values);\n        if (oldAddr != null && facet.compare(newVal, getAddr(tr.startState, oldAddr)))\n            return 0;\n        state.values[idx] = newVal;\n        return 1 /* Changed */;\n    };\n}\nfunction maybeIndex(state, id) {\n    let found = state.config.address[id];\n    return found == null ? null : found >> 1;\n}\nconst initField = Facet.define({ static: true });\n/// Fields can store additional information in an editor state, and\n/// keep it in sync with the rest of the state.\nclass StateField {\n    constructor(\n    /// @internal\n    id, createF, updateF, compareF, \n    /// @internal\n    spec) {\n        this.id = id;\n        this.createF = createF;\n        this.updateF = updateF;\n        this.compareF = compareF;\n        this.spec = spec;\n        /// @internal\n        this.provides = undefined;\n    }\n    /// Define a state field.\n    static define(config) {\n        let field = new StateField(nextID++, config.create, config.update, config.compare || ((a, b) => a === b), config);\n        if (config.provide)\n            field.provides = config.provide(field);\n        return field;\n    }\n    create(state) {\n        let init = state.facet(initField).find(i => i.field == this);\n        return ((init === null || init === void 0 ? void 0 : init.create) || this.createF)(state);\n    }\n    /// @internal\n    slot(addresses) {\n        let idx = addresses[this.id] >> 1;\n        return (state, tr) => {\n            if (!tr) {\n                state.values[idx] = this.create(state);\n                return 1 /* Changed */;\n            }\n            let oldVal, changed = 0;\n            if (tr.reconfigure) {\n                let oldIdx = maybeIndex(tr.startState, this.id);\n                oldVal = oldIdx == null ? this.create(tr.startState) : tr.startState.values[oldIdx];\n                changed = 1 /* Changed */;\n            }\n            else {\n                oldVal = tr.startState.values[idx];\n            }\n            let value = this.updateF(oldVal, tr);\n            if (!changed && !this.compareF(oldVal, value))\n                changed = 1 /* Changed */;\n            if (changed)\n                state.values[idx] = value;\n            return changed;\n        };\n    }\n    /// Returns an extension that enables this field and overrides the\n    /// way it is initialized. Can be useful when you need to provide a\n    /// non-default starting value for the field.\n    init(create) {\n        return [this, initField.of({ field: this, create })];\n    }\n}\nconst Prec_ = { fallback: 3, default: 2, extend: 1, override: 0 };\nfunction prec(value) {\n    return (ext) => new PrecExtension(ext, value);\n}\n/// By default extensions are registered in the order they are found\n/// in the flattened form of nested array that was provided.\n/// Individual extension values can be assigned a precedence to\n/// override this. Extensions that do not have a precedence set get\n/// the precedence of the nearest parent with a precedence, or\n/// [`default`](#state.Prec.default) if there is no such parent. The\n/// final ordering of extensions is determined by first sorting by\n/// precedence and then by order within each precedence.\nconst Prec = {\n    /// A precedence below the default precedence, which will cause\n    /// default-precedence extensions to override it even if they are\n    /// specified later in the extension ordering.\n    fallback: prec(Prec_.fallback),\n    /// The regular default precedence.\n    default: prec(Prec_.default),\n    /// A higher-than-default precedence.\n    extend: prec(Prec_.extend),\n    /// Precedence above the `default` and `extend` precedences.\n    override: prec(Prec_.override)\n};\nclass PrecExtension {\n    constructor(inner, prec) {\n        this.inner = inner;\n        this.prec = prec;\n    }\n}\nclass TaggedExtension {\n    constructor(tag, inner) {\n        this.tag = tag;\n        this.inner = inner;\n    }\n}\n/// Tagged extensions can be used to make a configuration dynamic.\n/// Tagging an extension allows you to later\n/// [replace](#state.TransactionSpec.reconfigure) it with\n/// another extension. A given tag may only occur once within a given\n/// configuration.\nfunction tagExtension(tag, extension) {\n    return new TaggedExtension(tag, extension);\n}\nclass Configuration {\n    constructor(source, replacements, dynamicSlots, address, staticValues) {\n        this.source = source;\n        this.replacements = replacements;\n        this.dynamicSlots = dynamicSlots;\n        this.address = address;\n        this.staticValues = staticValues;\n        this.statusTemplate = [];\n        while (this.statusTemplate.length < dynamicSlots.length)\n            this.statusTemplate.push(0 /* Uninitialized */);\n    }\n    staticFacet(facet) {\n        let addr = this.address[facet.id];\n        return addr == null ? facet.default : this.staticValues[addr >> 1];\n    }\n    static resolve(extension, replacements = Object.create(null), oldState) {\n        let fields = [];\n        let facets = Object.create(null);\n        for (let ext of flatten(extension, replacements)) {\n            if (ext instanceof StateField)\n                fields.push(ext);\n            else\n                (facets[ext.facet.id] || (facets[ext.facet.id] = [])).push(ext);\n        }\n        let address = Object.create(null);\n        let staticValues = [];\n        let dynamicSlots = [];\n        for (let field of fields) {\n            address[field.id] = dynamicSlots.length << 1;\n            dynamicSlots.push(a => field.slot(a));\n        }\n        for (let id in facets) {\n            let providers = facets[id], facet = providers[0].facet;\n            if (providers.every(p => p.type == 0 /* Static */)) {\n                address[facet.id] = (staticValues.length << 1) | 1;\n                let value = facet.combine(providers.map(p => p.value));\n                let oldAddr = oldState ? oldState.config.address[facet.id] : null;\n                if (oldAddr != null) {\n                    let oldVal = getAddr(oldState, oldAddr);\n                    if (facet.compare(value, oldVal))\n                        value = oldVal;\n                }\n                staticValues.push(value);\n            }\n            else {\n                for (let p of providers) {\n                    if (p.type == 0 /* Static */) {\n                        address[p.id] = (staticValues.length << 1) | 1;\n                        staticValues.push(p.value);\n                    }\n                    else {\n                        address[p.id] = dynamicSlots.length << 1;\n                        dynamicSlots.push(a => p.dynamicSlot(a));\n                    }\n                }\n                address[facet.id] = dynamicSlots.length << 1;\n                dynamicSlots.push(a => dynamicFacetSlot(a, facet, providers));\n            }\n        }\n        return new Configuration(extension, replacements, dynamicSlots.map(f => f(address)), address, staticValues);\n    }\n}\nfunction allKeys(obj) {\n    return (Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(obj) : []).concat(Object.keys(obj));\n}\nfunction flatten(extension, replacements) {\n    let result = [[], [], [], []];\n    let seen = new Map();\n    let tagsSeen = Object.create(null);\n    function inner(ext, prec) {\n        let known = seen.get(ext);\n        if (known != null) {\n            if (known >= prec)\n                return;\n            let found = result[known].indexOf(ext);\n            if (found > -1)\n                result[known].splice(found, 1);\n        }\n        seen.set(ext, prec);\n        if (Array.isArray(ext)) {\n            for (let e of ext)\n                inner(e, prec);\n        }\n        else if (ext instanceof TaggedExtension) {\n            if (ext.tag in tagsSeen)\n                throw new RangeError(`Duplicate use of tag '${String(ext.tag)}' in extensions`);\n            tagsSeen[ext.tag] = true;\n            inner(replacements[ext.tag] || ext.inner, prec);\n        }\n        else if (ext instanceof PrecExtension) {\n            inner(ext.inner, ext.prec);\n        }\n        else if (ext instanceof StateField) {\n            result[prec].push(ext);\n            if (ext.provides)\n                inner(ext.provides, prec);\n        }\n        else if (ext instanceof FacetProvider) {\n            result[prec].push(ext);\n            if (ext.facet.extensions)\n                inner(ext.facet.extensions, prec);\n        }\n        else {\n            inner(ext.extension, prec);\n        }\n    }\n    inner(extension, Prec_.default);\n    for (let key of allKeys(replacements))\n        if (!(key in tagsSeen) && key != \"full\" && replacements[key]) {\n            tagsSeen[key] = true;\n            inner(replacements[key], Prec_.default);\n        }\n    return result.reduce((a, b) => a.concat(b));\n}\nfunction ensureAddr(state, addr) {\n    if (addr & 1)\n        return 2 /* Computed */;\n    let idx = addr >> 1;\n    let status = state.status[idx];\n    if (status == 4 /* Computing */)\n        throw new Error(\"Cyclic dependency between fields and/or facets\");\n    if (status & 2 /* Computed */)\n        return status;\n    state.status[idx] = 4 /* Computing */;\n    let changed = state.config.dynamicSlots[idx](state, state.applying);\n    return state.status[idx] = 2 /* Computed */ | changed;\n}\nfunction getAddr(state, addr) {\n    return addr & 1 ? state.config.staticValues[addr >> 1] : state.values[addr >> 1];\n}\n\nconst languageData = Facet.define();\nconst allowMultipleSelections = Facet.define({\n    combine: values => values.some(v => v),\n    static: true\n});\nconst lineSeparator = Facet.define({\n    combine: values => values.length ? values[0] : undefined,\n    static: true\n});\nconst changeFilter = Facet.define();\nconst transactionFilter = Facet.define();\nconst transactionExtender = Facet.define();\n\n/// Annotations are tagged values that are used to add metadata to\n/// transactions in an extensible way. They should be used to model\n/// things that effect the entire transaction (such as its [time\n/// stamp](#state.Transaction^time) or information about its\n/// [origin](#state.Transaction^userEvent)). For effects that happen\n/// _alongside_ the other changes made by the transaction, [state\n/// effects](#state.StateEffect) are more appropriate.\nclass Annotation {\n    /// @internal\n    constructor(\n    /// The annotation type.\n    type, \n    /// The value of this annotation.\n    value) {\n        this.type = type;\n        this.value = value;\n    }\n    /// Define a new type of annotation.\n    static define() { return new AnnotationType(); }\n}\n/// Marker that identifies a type of [annotation](#state.Annotation).\nclass AnnotationType {\n    /// Create an instance of this annotation.\n    of(value) { return new Annotation(this, value); }\n}\n/// State effects can be used to represent additional effects\n/// associated with a [transaction](#state.Transaction.effects). They\n/// are often useful to model changes to custom [state\n/// fields](#state.StateField), when those changes aren't implicit in\n/// document or selection changes.\nclass StateEffect {\n    /// @internal\n    constructor(\n    /// @internal\n    type, \n    /// The value of this effect.\n    value) {\n        this.type = type;\n        this.value = value;\n    }\n    /// Map this effect through a position mapping. Will return\n    /// `undefined` when that ends up deleting the effect.\n    map(mapping) {\n        let mapped = this.type.map(this.value, mapping);\n        return mapped === undefined ? undefined : mapped == this.value ? this : new StateEffect(this.type, mapped);\n    }\n    /// Tells you whether this effect object is of a given\n    /// [type](#state.StateEffectType).\n    is(type) { return this.type == type; }\n    /// Define a new effect type. The type parameter indicates the type\n    /// of values that his effect holds.\n    static define(spec = {}) {\n        return new StateEffectType(spec.map || (v => v));\n    }\n    /// Map an array of effects through a change set.\n    static mapEffects(effects, mapping) {\n        if (!effects.length)\n            return effects;\n        let result = [];\n        for (let effect of effects) {\n            let mapped = effect.map(mapping);\n            if (mapped)\n                result.push(mapped);\n        }\n        return result;\n    }\n}\n/// Representation of a type of state effect. Defined with\n/// [`StateEffect.define`](#state.StateEffect^define).\nclass StateEffectType {\n    /// @internal\n    constructor(\n    // The `any` types in these function types are there to work\n    // around TypeScript issue #37631, where the type guard on\n    // `StateEffect.is` mysteriously stops working when these properly\n    // have type `Value`.\n    /// @internal\n    map) {\n        this.map = map;\n    }\n    /// Create a [state effect](#state.StateEffect) instance of this\n    /// type.\n    of(value) { return new StateEffect(this, value); }\n}\n/// Changes to the editor state are grouped into transactions.\n/// Typically, a user action creates a single transaction, which may\n/// contain any number of document changes, may change the selection,\n/// or have other effects. Create a transaction by calling\n/// [`EditorState.update`](#state.EditorState.update).\nclass Transaction {\n    /// @internal\n    constructor(\n    /// The state from which the transaction starts.\n    startState, \n    /// The document changes made by this transaction.\n    changes, \n    /// The selection set by this transaction, or undefined if it\n    /// doesn't explicitly set a selection.\n    selection, \n    /// The effects added to the transaction.\n    effects, \n    /// @internal\n    annotations, \n    /// Holds an object when this transaction\n    /// [reconfigures](#state.ReconfigurationSpec) the state.\n    reconfigure, \n    /// Whether the selection should be scrolled into view after this\n    /// transaction is dispatched.\n    scrollIntoView) {\n        this.startState = startState;\n        this.changes = changes;\n        this.selection = selection;\n        this.effects = effects;\n        this.annotations = annotations;\n        this.reconfigure = reconfigure;\n        this.scrollIntoView = scrollIntoView;\n        /// @internal\n        this._doc = null;\n        /// @internal\n        this._state = null;\n        if (selection)\n            checkSelection(selection, changes.newLength);\n        if (!annotations.some((a) => a.type == Transaction.time))\n            this.annotations = annotations.concat(Transaction.time.of(Date.now()));\n    }\n    /// The new document produced by the transaction. Contrary to\n    /// [`.state`](#state.Transaction.state)`.doc`, accessing this won't\n    /// force the entire new state to be computed right away, so it is\n    /// recommended that [transaction\n    /// filters](#state.EditorState^transactionFilter) use this getter\n    /// when they need to look at the new document.\n    get newDoc() {\n        return this._doc || (this._doc = this.changes.apply(this.startState.doc));\n    }\n    /// The new selection produced by the transaction. If\n    /// [`this.selection`](#state.Transaction.selection) is undefined,\n    /// this will [map](#state.EditorSelection.map) the start state's\n    /// current selection through the changes made by the transaction.\n    get newSelection() {\n        return this.selection || this.startState.selection.map(this.changes);\n    }\n    /// The new state created by the transaction. Computed on demand\n    /// (but retained for subsequent access), so itis recommended not to\n    /// access it in [transaction\n    /// filters](#state.EditorState^transactionFilter) when possible.\n    get state() {\n        if (!this._state)\n            this.startState.applyTransaction(this);\n        return this._state;\n    }\n    /// Get the value of the given annotation type, if any.\n    annotation(type) {\n        for (let ann of this.annotations)\n            if (ann.type == type)\n                return ann.value;\n        return undefined;\n    }\n    /// Indicates whether the transaction changed the document.\n    get docChanged() { return !this.changes.empty; }\n}\n/// Annotation used to store transaction timestamps.\nTransaction.time = Annotation.define();\n/// Annotation used to associate a transaction with a user interface\n/// event. The view will set this to...\n///\n///  - `\"input\"` when the user types text\n///  - `\"delete\"` when the user deletes the selection or text near the selection\n///  - `\"keyboardselection\"` when moving the selection via the keyboard\n///  - `\"pointerselection\"` when moving the selection through the pointing device\n///  - `\"paste\"` when pasting content\n///  - `\"cut\"` when cutting\n///  - `\"drop\"` when content is inserted via drag-and-drop\nTransaction.userEvent = Annotation.define();\n/// Annotation indicating whether a transaction should be added to\n/// the undo history or not.\nTransaction.addToHistory = Annotation.define();\nfunction joinRanges(a, b) {\n    let result = [];\n    for (let iA = 0, iB = 0;;) {\n        let from, to;\n        if (iA < a.length && (iB == b.length || b[iB] >= a[iA])) {\n            from = a[iA++];\n            to = a[iA++];\n        }\n        else if (iB < b.length) {\n            from = b[iB++];\n            to = b[iB++];\n        }\n        else\n            return result;\n        if (!result.length || result[result.length - 1] < from)\n            result.push(from, to);\n        else if (result[result.length - 1] < to)\n            result[result.length - 1] = to;\n    }\n}\nfunction mergeTransaction(a, b, sequential) {\n    var _a;\n    let mapForA, mapForB, changes;\n    if (sequential) {\n        mapForA = b.changes;\n        mapForB = ChangeSet.empty(b.changes.length);\n        changes = a.changes.compose(b.changes);\n    }\n    else {\n        mapForA = b.changes.map(a.changes);\n        mapForB = a.changes.mapDesc(b.changes, true);\n        changes = a.changes.compose(mapForA);\n    }\n    return {\n        changes,\n        selection: b.selection ? b.selection.map(mapForB) : (_a = a.selection) === null || _a === void 0 ? void 0 : _a.map(mapForA),\n        effects: StateEffect.mapEffects(a.effects, mapForA).concat(StateEffect.mapEffects(b.effects, mapForB)),\n        annotations: a.annotations.length ? a.annotations.concat(b.annotations) : b.annotations,\n        scrollIntoView: a.scrollIntoView || b.scrollIntoView,\n        reconfigure: !b.reconfigure ? a.reconfigure : b.reconfigure.full || !a.reconfigure ? b.reconfigure\n            : Object.assign({}, a.reconfigure, b.reconfigure)\n    };\n}\nfunction resolveTransactionInner(state, spec, docSize) {\n    let reconf = spec.reconfigure;\n    if (reconf && reconf.append) {\n        reconf = Object.assign({}, reconf);\n        let tag = typeof Symbol == \"undefined\" ? \"__append\" + Math.floor(Math.random() * 0xffffffff) : Symbol(\"appendConf\");\n        reconf[tag] = reconf.append;\n        reconf.append = undefined;\n    }\n    let sel = spec.selection;\n    return {\n        changes: spec.changes instanceof ChangeSet ? spec.changes\n            : ChangeSet.of(spec.changes || [], docSize, state.facet(lineSeparator)),\n        selection: sel && (sel instanceof EditorSelection ? sel : EditorSelection.single(sel.anchor, sel.head)),\n        effects: asArray(spec.effects),\n        annotations: asArray(spec.annotations),\n        scrollIntoView: !!spec.scrollIntoView,\n        reconfigure: reconf\n    };\n}\nfunction resolveTransaction(state, specs, filter) {\n    let s = resolveTransactionInner(state, specs.length ? specs[0] : {}, state.doc.length);\n    if (specs.length && specs[0].filter === false)\n        filter = false;\n    for (let i = 1; i < specs.length; i++) {\n        if (specs[i].filter === false)\n            filter = false;\n        let seq = !!specs[i].sequential;\n        s = mergeTransaction(s, resolveTransactionInner(state, specs[i], seq ? s.changes.newLength : state.doc.length), seq);\n    }\n    let tr = new Transaction(state, s.changes, s.selection, s.effects, s.annotations, s.reconfigure, s.scrollIntoView);\n    return extendTransaction(filter ? filterTransaction(tr) : tr);\n}\n// Finish a transaction by applying filters if necessary.\nfunction filterTransaction(tr) {\n    let state = tr.startState;\n    // Change filters\n    let result = true;\n    for (let filter of state.facet(changeFilter)) {\n        let value = filter(tr);\n        if (value === false) {\n            result = false;\n            break;\n        }\n        if (Array.isArray(value))\n            result = result === true ? value : joinRanges(result, value);\n    }\n    if (result !== true) {\n        let changes, back;\n        if (result === false) {\n            back = tr.changes.invertedDesc;\n            changes = ChangeSet.empty(state.doc.length);\n        }\n        else {\n            let filtered = tr.changes.filter(result);\n            changes = filtered.changes;\n            back = filtered.filtered.invertedDesc;\n        }\n        tr = new Transaction(state, changes, tr.selection && tr.selection.map(back), StateEffect.mapEffects(tr.effects, back), tr.annotations, tr.reconfigure, tr.scrollIntoView);\n    }\n    // Transaction filters\n    let filters = state.facet(transactionFilter);\n    for (let i = filters.length - 1; i >= 0; i--) {\n        let filtered = filters[i](tr);\n        if (filtered instanceof Transaction)\n            tr = filtered;\n        else if (Array.isArray(filtered) && filtered.length == 1 && filtered[0] instanceof Transaction)\n            tr = filtered[0];\n        else\n            tr = resolveTransaction(state, asArray(filtered), false);\n    }\n    return tr;\n}\nfunction extendTransaction(tr) {\n    let state = tr.startState, extenders = state.facet(transactionExtender), spec = tr;\n    for (let i = extenders.length - 1; i >= 0; i--) {\n        let extension = extenders[i](tr);\n        if (extension && Object.keys(extension).length)\n            spec = mergeTransaction(tr, resolveTransactionInner(state, extension, tr.changes.newLength), true);\n    }\n    return spec == tr ? tr : new Transaction(state, tr.changes, tr.selection, spec.effects, spec.annotations, spec.reconfigure, spec.scrollIntoView);\n}\nconst none = [];\nfunction asArray(value) {\n    return value == null ? none : Array.isArray(value) ? value : [value];\n}\n\n/// The categories produced by a [character\n/// categorizer](#state.EditorState.charCategorizer). These are used\n/// do things like selecting by word.\nvar CharCategory;\n(function (CharCategory) {\n    /// Word characters.\n    CharCategory[CharCategory[\"Word\"] = 0] = \"Word\";\n    /// Whitespace.\n    CharCategory[CharCategory[\"Space\"] = 1] = \"Space\";\n    /// Anything else.\n    CharCategory[CharCategory[\"Other\"] = 2] = \"Other\";\n})(CharCategory || (CharCategory = {}));\nconst nonASCIISingleCaseWordChar = /[\\u00df\\u0587\\u0590-\\u05f4\\u0600-\\u06ff\\u3040-\\u309f\\u30a0-\\u30ff\\u3400-\\u4db5\\u4e00-\\u9fcc\\uac00-\\ud7af]/;\nlet wordChar;\ntry {\n    wordChar = new RegExp(\"[\\\\p{Alphabetic}\\\\p{Number}_]\", \"u\");\n}\ncatch (_) { }\nfunction hasWordChar(str) {\n    if (wordChar)\n        return wordChar.test(str);\n    for (let i = 0; i < str.length; i++) {\n        let ch = str[i];\n        if (/\\w/.test(ch) || ch > \"\\x80\" && (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch)))\n            return true;\n    }\n    return false;\n}\nfunction makeCategorizer(wordChars) {\n    return (char) => {\n        if (!/\\S/.test(char))\n            return CharCategory.Space;\n        if (hasWordChar(char))\n            return CharCategory.Word;\n        for (let i = 0; i < wordChars.length; i++)\n            if (char.indexOf(wordChars[i]) > -1)\n                return CharCategory.Word;\n        return CharCategory.Other;\n    };\n}\n\n/// The editor state class is a persistent (immutable) data structure.\n/// To update a state, you [create](#state.EditorState.update) a\n/// [transaction](#state.Transaction), which produces a _new_ state\n/// instance, without modifying the original object.\n///\n/// As such, _never_ mutate properties of a state directly. That'll\n/// just break things.\nclass EditorState {\n    /// @internal\n    constructor(\n    /// @internal\n    config, \n    /// The current document.\n    doc, \n    /// The current selection.\n    selection, tr = null) {\n        this.config = config;\n        this.doc = doc;\n        this.selection = selection;\n        /// @internal\n        this.applying = null;\n        this.status = config.statusTemplate.slice();\n        if (tr && !tr.reconfigure) {\n            this.values = tr.startState.values.slice();\n        }\n        else {\n            this.values = config.dynamicSlots.map(_ => null);\n            // Copy over old values for shared facets/fields if this is a reconfigure\n            if (tr)\n                for (let id in config.address) {\n                    let cur = config.address[id], prev = tr.startState.config.address[id];\n                    if (prev != null && (cur & 1) == 0)\n                        this.values[cur >> 1] = getAddr(tr.startState, prev);\n                }\n        }\n        this.applying = tr;\n        // Fill in the computed state immediately, so that further queries\n        // for it made during the update return this state\n        if (tr)\n            tr._state = this;\n        for (let i = 0; i < this.config.dynamicSlots.length; i++)\n            ensureAddr(this, i << 1);\n        this.applying = null;\n    }\n    field(field, require = true) {\n        let addr = this.config.address[field.id];\n        if (addr == null) {\n            if (require)\n                throw new RangeError(\"Field is not present in this state\");\n            return undefined;\n        }\n        ensureAddr(this, addr);\n        return getAddr(this, addr);\n    }\n    /// Create a [transaction](#state.Transaction) that updates this\n    /// state. Any number of [transaction specs](#state.TransactionSpec)\n    /// can be passed. Unless\n    /// [`sequential`](#state.TransactionSpec.sequential) is set, the\n    /// [changes](#state.TransactionSpec.changes) (if any) of each spec\n    /// are assumed to start in the _current_ document (not the document\n    /// produced by previous specs), and its\n    /// [selection](#state.TransactionSpec.selection) and\n    /// [effects](#state.TransactionSpec.effects) are assumed to refer\n    /// to the document created by its _own_ changes. The resulting\n    /// transaction contains the combined effect of all the different\n    /// specs. For things like\n    /// [selection](#state.TransactionSpec.selection) or\n    /// [reconfiguration](#state.TransactionSpec.reconfigure), later\n    /// specs take precedence over earlier ones.\n    update(...specs) {\n        return resolveTransaction(this, specs, true);\n    }\n    /// @internal\n    applyTransaction(tr) {\n        let conf = this.config;\n        if (tr.reconfigure)\n            conf = Configuration.resolve(tr.reconfigure.full || conf.source, Object.assign(conf.replacements, tr.reconfigure, { full: undefined }), this);\n        new EditorState(conf, tr.newDoc, tr.newSelection, tr);\n    }\n    /// Create a [transaction spec](#state.TransactionSpec) that\n    /// replaces every selection range with the given content.\n    replaceSelection(text) {\n        if (typeof text == \"string\")\n            text = this.toText(text);\n        return this.changeByRange(range => ({ changes: { from: range.from, to: range.to, insert: text },\n            range: EditorSelection.cursor(range.from + text.length) }));\n    }\n    /// Create a set of changes and a new selection by running the given\n    /// function for each range in the active selection. The function\n    /// can return an optional set of changes (in the coordinate space\n    /// of the start document), plus an updated range (in the coordinate\n    /// space of the document produced by the call's own changes). This\n    /// method will merge all the changes and ranges into a single\n    /// changeset and selection, and return it as a [transaction\n    /// spec](#state.TransactionSpec), which can be passed to\n    /// [`update`](#state.EditorState.update).\n    changeByRange(f) {\n        let sel = this.selection;\n        let result1 = f(sel.ranges[0]);\n        let changes = this.changes(result1.changes), ranges = [result1.range];\n        let effects = asArray(result1.effects);\n        for (let i = 1; i < sel.ranges.length; i++) {\n            let result = f(sel.ranges[i]);\n            let newChanges = this.changes(result.changes), newMapped = newChanges.map(changes);\n            for (let j = 0; j < i; j++)\n                ranges[j] = ranges[j].map(newMapped);\n            let mapBy = changes.mapDesc(newChanges, true);\n            ranges.push(result.range.map(mapBy));\n            changes = changes.compose(newMapped);\n            effects = StateEffect.mapEffects(effects, newMapped).concat(StateEffect.mapEffects(asArray(result.effects), mapBy));\n        }\n        return {\n            changes,\n            selection: EditorSelection.create(ranges, sel.mainIndex),\n            effects\n        };\n    }\n    /// Create a [change set](#state.ChangeSet) from the given change\n    /// description, taking the state's document length and line\n    /// separator into account.\n    changes(spec = []) {\n        if (spec instanceof ChangeSet)\n            return spec;\n        return ChangeSet.of(spec, this.doc.length, this.facet(EditorState.lineSeparator));\n    }\n    /// Using the state's [line\n    /// separator](#state.EditorState^lineSeparator), create a\n    /// [`Text`](#text.Text) instance from the given string.\n    toText(string) {\n        return Text.of(string.split(this.facet(EditorState.lineSeparator) || DefaultSplit));\n    }\n    /// Return the given range of the document as a string.\n    sliceDoc(from = 0, to = this.doc.length) {\n        return this.doc.sliceString(from, to, this.lineBreak);\n    }\n    /// Get the value of a state [facet](#state.Facet).\n    facet(facet) {\n        let addr = this.config.address[facet.id];\n        if (addr == null)\n            return facet.default;\n        ensureAddr(this, addr);\n        return getAddr(this, addr);\n    }\n    /// Convert this state to a JSON-serializable object. When custom\n    /// fields should be serialized, you can pass them in as an object\n    /// mapping property names (in the resulting object, which should\n    /// not use `doc` or `selection`) to fields.\n    toJSON(fields) {\n        let result = {\n            doc: this.sliceDoc(),\n            selection: this.selection.toJSON()\n        };\n        if (fields)\n            for (let prop in fields)\n                result[prop] = fields[prop].spec.toJSON(this.field(fields[prop]), this);\n        return result;\n    }\n    /// Deserialize a state from its JSON representation. When custom\n    /// fields should be deserialized, pass the same object you passed\n    /// to [`toJSON`](#state.EditorState.toJSON) when serializing as\n    /// third argument.\n    static fromJSON(json, config = {}, fields) {\n        if (!json || typeof json.doc != \"string\")\n            throw new RangeError(\"Invalid JSON representation for EditorState\");\n        let fieldInit = [];\n        if (fields)\n            for (let prop in fields) {\n                let field = fields[prop], value = json[prop];\n                fieldInit.push(field.init(state => field.spec.fromJSON(value, state)));\n            }\n        return EditorState.create({\n            doc: json.doc,\n            selection: EditorSelection.fromJSON(json.selection),\n            extensions: config.extensions ? fieldInit.concat([config.extensions]) : fieldInit\n        });\n    }\n    /// Create a new state. You'll usually only need this when\n    /// initializing an editor—updated states are created by applying\n    /// transactions.\n    static create(config = {}) {\n        let configuration = Configuration.resolve(config.extensions || []);\n        let doc = config.doc instanceof Text ? config.doc\n            : Text.of((config.doc || \"\").split(configuration.staticFacet(EditorState.lineSeparator) || DefaultSplit));\n        let selection = !config.selection ? EditorSelection.single(0)\n            : config.selection instanceof EditorSelection ? config.selection\n                : EditorSelection.single(config.selection.anchor, config.selection.head);\n        checkSelection(selection, doc.length);\n        if (!configuration.staticFacet(allowMultipleSelections))\n            selection = selection.asSingle();\n        return new EditorState(configuration, doc, selection);\n    }\n    /// The size (in columns) of a tab in the document, determined by\n    /// the [`tabSize`](#state.EditorState^tabSize) facet.\n    get tabSize() { return this.facet(EditorState.tabSize); }\n    /// Get the proper [line-break](#state.EditorState^lineSeparator)\n    /// string for this state.\n    get lineBreak() { return this.facet(EditorState.lineSeparator) || \"\\n\"; }\n    /// Look up a translation for the given phrase (via the\n    /// [`phrases`](#state.EditorState^phrases) facet), or return the\n    /// original string if no translation is found.\n    phrase(phrase) {\n        for (let map of this.facet(EditorState.phrases))\n            if (Object.prototype.hasOwnProperty.call(map, phrase))\n                return map[phrase];\n        return phrase;\n    }\n    /// Find the values for a given language data field, provided by the\n    /// the [`languageData`](#state.EditorState^languageData) facet.\n    languageDataAt(name, pos) {\n        let values = [];\n        for (let provider of this.facet(languageData)) {\n            for (let result of provider(this, pos)) {\n                if (Object.prototype.hasOwnProperty.call(result, name))\n                    values.push(result[name]);\n            }\n        }\n        return values;\n    }\n    /// Return a function that can categorize strings (expected to\n    /// represent a single [grapheme cluster](#text.findClusterBreak))\n    /// into one of:\n    ///\n    ///  - Word (contains an alphanumeric character or a character\n    ///    explicitly listed in the local language's `\"wordChars\"`\n    ///    language data, which should be a string)\n    ///  - Space (contains only whitespace)\n    ///  - Other (anything else)\n    charCategorizer(at) {\n        return makeCategorizer(this.languageDataAt(\"wordChars\", at).join(\"\"));\n    }\n}\n/// A facet that, when enabled, causes the editor to allow multiple\n/// ranges to be selected. Be careful though, because by default the\n/// editor relies on the native DOM selection, which cannot handle\n/// multiple selections. An extension like\n/// [`drawSelection`](#view.drawSelection) can be used to make\n/// secondary selections visible to the user.\nEditorState.allowMultipleSelections = allowMultipleSelections;\n/// Configures the tab size to use in this state. The first\n/// (highest-precedence) value of the facet is used. If no value is\n/// given, this defaults to 4.\nEditorState.tabSize = Facet.define({\n    combine: values => values.length ? values[0] : 4\n});\n/// The line separator to use. By default, any of `\"\\n\"`, `\"\\r\\n\"`\n/// and `\"\\r\"` is treated as a separator when splitting lines, and\n/// lines are joined with `\"\\n\"`.\n///\n/// When you configure a value here, only that precise separator\n/// will be used, allowing you to round-trip documents through the\n/// editor without normalizing line separators.\nEditorState.lineSeparator = lineSeparator;\n/// Registers translation phrases. The\n/// [`phrase`](#state.EditorState.phrase) method will look through\n/// all objects registered with this facet to find translations for\n/// its argument.\nEditorState.phrases = Facet.define();\n/// A facet used to register [language\n/// data](#state.EditorState.languageDataAt) providers.\nEditorState.languageData = languageData;\n/// Facet used to register change filters, which are called for each\n/// transaction (unless explicitly\n/// [disabled](#state.TransactionSpec.filter)), and can suppress\n/// part of the transaction's changes.\n///\n/// Such a function can return `true` to indicate that it doesn't\n/// want to do anything, `false` to completely stop the changes in\n/// the transaction, or a set of ranges in which changes should be\n/// suppressed. Such ranges are represented as an array of numbers,\n/// with each pair of two number indicating the start and end of a\n/// range. So for example `[10, 20, 100, 110]` suppresses changes\n/// between 10 and 20, and between 100 and 110.\nEditorState.changeFilter = changeFilter;\n/// Facet used to register a hook that gets a chance to update or\n/// replace transaction specs before they are applied. This will\n/// only be applied for transactions that don't have\n/// [`filter`](#state.TransactionSpec.filter) set to `false`. You\n/// can either return a single (possibly the input transaction), or\n/// an array of specs (which will be combined in the same way as the\n/// arguments to [`EditorState.update`](#state.EditorState.update)).\n///\n/// When possible, it is recommended to avoid accessing\n/// [`Transaction.state`](#state.Transaction.state) in a filter,\n/// since it will force creation of a state that will then be\n/// discarded again, if the transaction is actually filtered.\n///\n/// (This functionality should be used with care. Indiscriminately\n/// modifying transaction is likely to break something or degrade\n/// the user experience.)\nEditorState.transactionFilter = transactionFilter;\n/// This is a more limited form of\n/// [`transactionFilter`](#state.EditorState^transactionFilter),\n/// which can only add\n/// [annotations](#state.TransactionSpec.annotations),\n/// [effects](#state.TransactionSpec.effects), and\n/// [configuration](#state.TransactionSpec.reconfigure) info. _But_,\n/// this type of filter runs even the transaction has disabled\n/// regular [filtering](#state.TransactionSpec.filter), making it\n/// suitable for effects that don't need to touch the changes or\n/// selection, but do want to process every transaction.\n///\n/// Extenders run _after_ filters, when both are applied.\nEditorState.transactionExtender = transactionExtender;\n\n/// Utility function for combining behaviors to fill in a config\n/// object from an array of provided configs. Will, by default, error\n/// when a field gets two values that aren't `===`-equal, but you can\n/// provide combine functions per field to do something else.\nfunction combineConfig(configs, defaults, // Should hold only the optional properties of Config, but I haven't managed to express that\ncombine = {}) {\n    let result = {};\n    for (let config of configs)\n        for (let key of Object.keys(config)) {\n            let value = config[key], current = result[key];\n            if (current === undefined)\n                result[key] = value;\n            else if (current === value || value === undefined) ; // No conflict\n            else if (Object.hasOwnProperty.call(combine, key))\n                result[key] = combine[key](current, value);\n            else\n                throw new Error(\"Config merge conflict for field \" + key);\n        }\n    for (let key in defaults)\n        if (result[key] === undefined)\n            result[key] = defaults[key];\n    return result;\n}\n\nexport { Annotation, AnnotationType, ChangeDesc, ChangeSet, CharCategory, EditorSelection, EditorState, Facet, MapMode, Prec, SelectionRange, StateEffect, StateEffectType, StateField, Transaction, combineConfig, tagExtension };\n","// Compressed representation of the Grapheme_Cluster_Break=Extend\n// information from\n// http://www.unicode.org/Public/13.0.0/ucd/auxiliary/GraphemeBreakProperty.txt.\n// Each pair of elements represents a range, as an offet from the\n// previous range and a length. Numbers are in base-36, with the empty\n// string being a shorthand for 1.\nlet extend = \"lc,34,7n,7,7b,19,,,,2,,2,,,20,b,1c,l,g,,2t,7,2,6,2,2,,4,z,,u,r,2j,b,1m,9,9,,o,4,,9,,3,,5,17,3,3b,f,,w,1j,,,,4,8,4,,3,7,a,2,t,,1m,,,,2,4,8,,9,,a,2,q,,2,2,1l,,4,2,4,2,2,3,3,,u,2,3,,b,2,1l,,4,5,,2,4,,k,2,m,6,,,1m,,,2,,4,8,,7,3,a,2,u,,1n,,,,c,,9,,14,,3,,1l,3,5,3,,4,7,2,b,2,t,,1m,,2,,2,,3,,5,2,7,2,b,2,s,2,1l,2,,,2,4,8,,9,,a,2,t,,20,,4,,2,3,,,8,,29,,2,7,c,8,2q,,2,9,b,6,22,2,r,,,,,,1j,e,,5,,2,5,b,,10,9,,2u,4,,6,,2,2,2,p,2,4,3,g,4,d,,2,2,6,,f,,jj,3,qa,3,t,3,t,2,u,2,1s,2,,7,8,,2,b,9,,19,3,3b,2,y,,3a,3,4,2,9,,6,3,63,2,2,,1m,,,7,,,,,2,8,6,a,2,,1c,h,1r,4,1c,7,,,5,,14,9,c,2,w,4,2,2,,3,1k,,,2,3,,,3,1m,8,2,2,48,3,,d,,7,4,,6,,3,2,5i,1m,,5,ek,,5f,x,2da,3,3x,,2o,w,fe,6,2x,2,n9w,4,,a,w,2,28,2,7k,,3,,4,,p,2,5,,47,2,q,i,d,,12,8,p,b,1a,3,1c,,2,4,2,2,13,,1v,6,2,2,2,2,c,,8,,1b,,1f,,,3,2,2,5,2,,,16,2,8,,6m,,2,,4,,fn4,,kh,g,g,g,a6,2,gt,,6a,,45,5,1ae,3,,2,5,4,14,3,4,,4l,2,fx,4,ar,2,49,b,4w,,1i,f,1k,3,1d,4,2,2,1x,3,10,5,,8,1q,,c,2,1g,9,a,4,2,,2n,3,2,,,2,6,,4g,,3,8,l,2,1l,2,,,,,m,,e,7,3,5,5f,8,2,3,,,n,,29,,2,6,,,2,,,2,,2,6j,,2,4,6,2,,2,r,2,2d,8,2,,,2,2y,,,,2,6,,,2t,3,2,4,,5,77,9,,2,6t,,a,2,,,4,,40,4,2,2,4,,w,a,14,6,2,4,8,,9,6,2,3,1a,d,,2,ba,7,,6,,,2a,m,2,7,,2,,2,3e,6,3,,,2,,7,,,20,2,3,,,,9n,2,f0b,5,1n,7,t4,,1r,4,29,,f5k,2,43q,,,3,4,5,8,8,2,7,u,4,44,3,1iz,1j,4,1e,8,,e,,m,5,,f,11s,7,,h,2,7,,2,,5,79,7,c5,4,15s,7,31,7,240,5,gx7k,2o,3k,6o\".split(\",\").map(s => s ? parseInt(s, 36) : 1);\n// Convert offsets into absolute values\nfor (let i = 1; i < extend.length; i++)\n    extend[i] += extend[i - 1];\nfunction isExtendingChar(code) {\n    for (let i = 1; i < extend.length; i += 2)\n        if (extend[i] > code)\n            return extend[i - 1] <= code;\n    return false;\n}\nfunction isRegionalIndicator(code) {\n    return code >= 0x1F1E6 && code <= 0x1F1FF;\n}\nconst ZWJ = 0x200d;\n/// Returns a next grapheme cluster break _after_ (not equal to)\n/// `pos`, if `forward` is true, or before otherwise. Returns `pos`\n/// itself if no further cluster break is available in the string.\n/// Moves across surrogate pairs, extending characters, characters\n/// joined with zero-width joiners, and flag emoji.\nfunction findClusterBreak(str, pos, forward = true) {\n    return (forward ? nextClusterBreak : prevClusterBreak)(str, pos);\n}\nfunction nextClusterBreak(str, pos) {\n    if (pos == str.length)\n        return pos;\n    // If pos is in the middle of a surrogate pair, move to its start\n    if (pos && surrogateLow(str.charCodeAt(pos)) && surrogateHigh(str.charCodeAt(pos - 1)))\n        pos--;\n    let prev = codePointAt(str, pos);\n    pos += codePointSize(prev);\n    while (pos < str.length) {\n        let next = codePointAt(str, pos);\n        if (prev == ZWJ || next == ZWJ || isExtendingChar(next)) {\n            pos += codePointSize(next);\n            prev = next;\n        }\n        else if (isRegionalIndicator(next)) {\n            let countBefore = 0, i = pos - 2;\n            while (i >= 0 && isRegionalIndicator(codePointAt(str, i))) {\n                countBefore++;\n                i -= 2;\n            }\n            if (countBefore % 2 == 0)\n                break;\n            else\n                pos += 2;\n        }\n        else {\n            break;\n        }\n    }\n    return pos;\n}\nfunction prevClusterBreak(str, pos) {\n    while (pos > 0) {\n        let found = nextClusterBreak(str, pos - 2);\n        if (found < pos)\n            return found;\n        pos--;\n    }\n    return 0;\n}\nfunction surrogateLow(ch) { return ch >= 0xDC00 && ch < 0xE000; }\nfunction surrogateHigh(ch) { return ch >= 0xD800 && ch < 0xDC00; }\n/// Find the code point at the given position in a string (like the\n/// [`codePointAt`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/codePointAt)\n/// string method).\nfunction codePointAt(str, pos) {\n    let code0 = str.charCodeAt(pos);\n    if (!surrogateHigh(code0) || pos + 1 == str.length)\n        return code0;\n    let code1 = str.charCodeAt(pos + 1);\n    if (!surrogateLow(code1))\n        return code0;\n    return ((code0 - 0xd800) << 10) + (code1 - 0xdc00) + 0x10000;\n}\n/// Given a Unicode codepoint, return the JavaScript string that\n/// respresents it (like\n/// [`String.fromCodePoint`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/fromCodePoint)).\nfunction fromCodePoint(code) {\n    if (code <= 0xffff)\n        return String.fromCharCode(code);\n    code -= 0x10000;\n    return String.fromCharCode((code >> 10) + 0xd800, (code & 1023) + 0xdc00);\n}\n/// The first character that takes up two positions in a JavaScript\n/// string. It is often useful to compare with this after calling\n/// `codePointAt`, to figure out whether your character takes up 1 or\n/// 2 index positions.\nfunction codePointSize(code) { return code < 0x10000 ? 1 : 2; }\n\n/// Count the column position at the given offset into the string,\n/// taking extending characters and tab size into account.\nfunction countColumn(string, n, tabSize) {\n    for (let i = 0; i < string.length;) {\n        if (string.charCodeAt(i) == 9) {\n            n += tabSize - (n % tabSize);\n            i++;\n        }\n        else {\n            n++;\n            i = findClusterBreak(string, i);\n        }\n    }\n    return n;\n}\n/// Find the offset that corresponds to the given column position in a\n/// string, taking extending characters and tab size into account.\nfunction findColumn(string, n, col, tabSize) {\n    for (let i = 0; i < string.length;) {\n        if (n >= col)\n            return { offset: i, leftOver: 0 };\n        n += string.charCodeAt(i) == 9 ? tabSize - (n % tabSize) : 1;\n        i = findClusterBreak(string, i);\n    }\n    return { offset: string.length, leftOver: col - n };\n}\n\n/// The data structure for documents.\nclass Text {\n    /// @internal\n    constructor() { }\n    /// Get the line description around the given position.\n    lineAt(pos) {\n        if (pos < 0 || pos > this.length)\n            throw new RangeError(`Invalid position ${pos} in document of length ${this.length}`);\n        return this.lineInner(pos, false, 1, 0);\n    }\n    /// Get the description for the given (1-based) line number.\n    line(n) {\n        if (n < 1 || n > this.lines)\n            throw new RangeError(`Invalid line number ${n} in ${this.lines}-line document`);\n        return this.lineInner(n, true, 1, 0);\n    }\n    /// Replace a range of the text with the given content.\n    replace(from, to, text) {\n        let parts = [];\n        if (from)\n            this.decompose(0, from, parts, 2 /* To */);\n        if (text.length)\n            text.decompose(0, text.length, parts, (from ? 1 /* From */ : 0) | (to < this.length ? 2 /* To */ : 0));\n        if (to < this.length)\n            this.decompose(to, this.length, parts, parts.length ? 1 /* From */ : 0);\n        return TextNode.from(parts, this.length - (to - from) + text.length);\n    }\n    /// Append another document to this one.\n    append(other) {\n        return this.replace(this.length, this.length, other);\n    }\n    /// Retrieve the text between the given points.\n    slice(from, to = this.length) {\n        let parts = [];\n        this.decompose(from, to, parts, 0);\n        return TextNode.from(parts, to - from);\n    }\n    /// Test whether this text is equal to another instance.\n    eq(other) {\n        if (other == this)\n            return true;\n        if (other.length != this.length || other.lines != this.lines)\n            return false;\n        let a = new RawTextCursor(this), b = new RawTextCursor(other);\n        for (;;) {\n            a.next();\n            b.next();\n            if (a.lineBreak != b.lineBreak || a.done != b.done || a.value != b.value)\n                return false;\n            if (a.done)\n                return true;\n        }\n    }\n    /// Iterate over the text. When `dir` is `-1`, iteration happens\n    /// from end to start. This will return lines and the breaks between\n    /// them as separate strings, and for long lines, might split lines\n    /// themselves into multiple chunks as well.\n    iter(dir = 1) { return new RawTextCursor(this, dir); }\n    /// Iterate over a range of the text. When `from` > `to`, the\n    /// iterator will run in reverse.\n    iterRange(from, to = this.length) { return new PartialTextCursor(this, from, to); }\n    /// @internal\n    toString() { return this.sliceString(0); }\n    /// Convert the document to an array of lines (which can be\n    /// deserialized again via [`Text.of`](#text.Text^of)).\n    toJSON() {\n        let lines = [];\n        this.flatten(lines);\n        return lines;\n    }\n    /// Create a `Text` instance for the given array of lines.\n    static of(text) {\n        if (text.length == 0)\n            throw new RangeError(\"A document must have at least one line\");\n        if (text.length == 1 && !text[0])\n            return Text.empty;\n        return text.length <= 32 /* Branch */ ? new TextLeaf(text) : TextNode.from(TextLeaf.split(text, []));\n    }\n}\nif (typeof Symbol != \"undefined\")\n    Text.prototype[Symbol.iterator] = function () { return this.iter(); };\n// Leaves store an array of line strings. There are always line breaks\n// between these strings. Leaves are limited in size and have to be\n// contained in TextNode instances for bigger documents.\nclass TextLeaf extends Text {\n    constructor(text, length = textLength(text)) {\n        super();\n        this.text = text;\n        this.length = length;\n    }\n    get lines() { return this.text.length; }\n    get children() { return null; }\n    lineInner(target, isLine, line, offset) {\n        for (let i = 0;; i++) {\n            let string = this.text[i], end = offset + string.length;\n            if ((isLine ? line : end) >= target)\n                return new Line(offset, end, line, string);\n            offset = end + 1;\n            line++;\n        }\n    }\n    decompose(from, to, target, open) {\n        let text = from <= 0 && to >= this.length ? this\n            : new TextLeaf(sliceText(this.text, from, to), Math.min(to, this.length) - Math.max(0, from));\n        if (open & 1 /* From */) {\n            let prev = target.pop();\n            let joined = appendText(text.text, prev.text.slice(), 0, text.length);\n            if (joined.length <= 32 /* Branch */) {\n                target.push(new TextLeaf(joined, prev.length + text.length));\n            }\n            else {\n                let mid = joined.length >> 1;\n                target.push(new TextLeaf(joined.slice(0, mid)), new TextLeaf(joined.slice(mid)));\n            }\n        }\n        else {\n            target.push(text);\n        }\n    }\n    replace(from, to, text) {\n        if (!(text instanceof TextLeaf))\n            return super.replace(from, to, text);\n        let lines = appendText(this.text, appendText(text.text, sliceText(this.text, 0, from)), to);\n        let newLen = this.length + text.length - (to - from);\n        if (lines.length <= 32 /* Branch */)\n            return new TextLeaf(lines, newLen);\n        return TextNode.from(TextLeaf.split(lines, []), newLen);\n    }\n    sliceString(from, to = this.length, lineSep = \"\\n\") {\n        let result = \"\";\n        for (let pos = 0, i = 0; pos <= to && i < this.text.length; i++) {\n            let line = this.text[i], end = pos + line.length;\n            if (pos > from && i)\n                result += lineSep;\n            if (from < end && to > pos)\n                result += line.slice(Math.max(0, from - pos), to - pos);\n            pos = end + 1;\n        }\n        return result;\n    }\n    flatten(target) {\n        for (let line of this.text)\n            target.push(line);\n    }\n    static split(text, target) {\n        let part = [], len = -1;\n        for (let line of text) {\n            part.push(line);\n            len += line.length + 1;\n            if (part.length == 32 /* Branch */) {\n                target.push(new TextLeaf(part, len));\n                part = [];\n                len = -1;\n            }\n        }\n        if (len > -1)\n            target.push(new TextLeaf(part, len));\n        return target;\n    }\n}\n// Nodes provide the tree structure of the `Text` type. They store a\n// number of other nodes or leaves, taking care to balance themselves\n// on changes. There are implied line breaks _between_ the children of\n// a node (but not before the first or after the last child).\nclass TextNode extends Text {\n    constructor(children, length) {\n        super();\n        this.children = children;\n        this.length = length;\n        this.lines = 0;\n        for (let child of children)\n            this.lines += child.lines;\n    }\n    lineInner(target, isLine, line, offset) {\n        for (let i = 0;; i++) {\n            let child = this.children[i], end = offset + child.length, endLine = line + child.lines - 1;\n            if ((isLine ? endLine : end) >= target)\n                return child.lineInner(target, isLine, line, offset);\n            offset = end + 1;\n            line = endLine + 1;\n        }\n    }\n    decompose(from, to, target, open) {\n        for (let i = 0, pos = 0; pos <= to && i < this.children.length; i++) {\n            let child = this.children[i], end = pos + child.length;\n            if (from <= end && to >= pos) {\n                let childOpen = open & ((pos <= from ? 1 /* From */ : 0) | (end >= to ? 2 /* To */ : 0));\n                if (pos >= from && end <= to && !childOpen)\n                    target.push(child);\n                else\n                    child.decompose(from - pos, to - pos, target, childOpen);\n            }\n            pos = end + 1;\n        }\n    }\n    replace(from, to, text) {\n        if (text.lines < this.lines)\n            for (let i = 0, pos = 0; i < this.children.length; i++) {\n                let child = this.children[i], end = pos + child.length;\n                // Fast path: if the change only affects one child and the\n                // child's size remains in the acceptable range, only update\n                // that child\n                if (from >= pos && to <= end) {\n                    let updated = child.replace(from - pos, to - pos, text);\n                    let totalLines = this.lines - child.lines + updated.lines;\n                    if (updated.lines < (totalLines >> (5 /* BranchShift */ - 1)) &&\n                        updated.lines > (totalLines >> (5 /* BranchShift */ + 1))) {\n                        let copy = this.children.slice();\n                        copy[i] = updated;\n                        return new TextNode(copy, this.length - (to - from) + text.length);\n                    }\n                    return super.replace(pos, end, updated);\n                }\n                pos = end + 1;\n            }\n        return super.replace(from, to, text);\n    }\n    sliceString(from, to = this.length, lineSep = \"\\n\") {\n        let result = \"\";\n        for (let i = 0, pos = 0; i < this.children.length && pos <= to; i++) {\n            let child = this.children[i], end = pos + child.length;\n            if (pos > from && i)\n                result += lineSep;\n            if (from < end && to > pos)\n                result += child.sliceString(from - pos, to - pos, lineSep);\n            pos = end + 1;\n        }\n        return result;\n    }\n    flatten(target) {\n        for (let child of this.children)\n            child.flatten(target);\n    }\n    static from(children, length = children.reduce((l, ch) => l + ch.length + 1, -1)) {\n        let lines = 0;\n        for (let ch of children)\n            lines += ch.lines;\n        if (lines < 32 /* Branch */) {\n            let flat = [];\n            for (let ch of children)\n                ch.flatten(flat);\n            return new TextLeaf(flat, length);\n        }\n        let chunk = Math.max(32 /* Branch */, lines >> 5 /* BranchShift */), maxChunk = chunk << 1, minChunk = chunk >> 1;\n        let chunked = [], currentLines = 0, currentLen = -1, currentChunk = [];\n        function add(child) {\n            let last;\n            if (child.lines > maxChunk && child instanceof TextNode) {\n                for (let node of child.children)\n                    add(node);\n            }\n            else if (child.lines > minChunk && (currentLines > minChunk || !currentLines)) {\n                flush();\n                chunked.push(child);\n            }\n            else if (child instanceof TextLeaf && currentLines &&\n                (last = currentChunk[currentChunk.length - 1]) instanceof TextLeaf &&\n                child.lines + last.lines <= 32 /* Branch */) {\n                currentLines += child.lines;\n                currentLen += child.length + 1;\n                currentChunk[currentChunk.length - 1] = new TextLeaf(last.text.concat(child.text), last.length + 1 + child.length);\n            }\n            else {\n                if (currentLines + child.lines > chunk)\n                    flush();\n                currentLines += child.lines;\n                currentLen += child.length + 1;\n                currentChunk.push(child);\n            }\n        }\n        function flush() {\n            if (currentLines == 0)\n                return;\n            chunked.push(currentChunk.length == 1 ? currentChunk[0] : TextNode.from(currentChunk, currentLen));\n            currentLen = -1;\n            currentLines = currentChunk.length = 0;\n        }\n        for (let child of children)\n            add(child);\n        flush();\n        return chunked.length == 1 ? chunked[0] : new TextNode(chunked, length);\n    }\n}\nText.empty = new TextLeaf([\"\"], 0);\nfunction textLength(text) {\n    let length = -1;\n    for (let line of text)\n        length += line.length + 1;\n    return length;\n}\nfunction appendText(text, target, from = 0, to = 1e9) {\n    for (let pos = 0, i = 0, first = true; i < text.length && pos <= to; i++) {\n        let line = text[i], end = pos + line.length;\n        if (end >= from) {\n            if (end > to)\n                line = line.slice(0, to - pos);\n            if (pos < from)\n                line = line.slice(from - pos);\n            if (first) {\n                target[target.length - 1] += line;\n                first = false;\n            }\n            else\n                target.push(line);\n        }\n        pos = end + 1;\n    }\n    return target;\n}\nfunction sliceText(text, from, to) {\n    return appendText(text, [\"\"], from, to);\n}\nclass RawTextCursor {\n    constructor(text, dir = 1) {\n        this.dir = dir;\n        this.done = false;\n        this.lineBreak = false;\n        this.value = \"\";\n        this.nodes = [text];\n        this.offsets = [dir > 0 ? 0 : text instanceof TextLeaf ? text.text.length : text.children.length];\n    }\n    next(skip = 0) {\n        for (;;) {\n            let last = this.nodes.length - 1;\n            if (last < 0) {\n                this.done = true;\n                this.value = \"\";\n                this.lineBreak = false;\n                return this;\n            }\n            let top = this.nodes[last], offset = this.offsets[last];\n            let size = top instanceof TextLeaf ? top.text.length : top.children.length;\n            if (offset == (this.dir > 0 ? size : 0)) {\n                this.nodes.pop();\n                this.offsets.pop();\n            }\n            else if (!this.lineBreak && offset != (this.dir > 0 ? 0 : size)) {\n                // Internal offset with lineBreak == false means we have to\n                // count the line break at this position\n                this.lineBreak = true;\n                if (skip == 0) {\n                    this.value = \"\\n\";\n                    return this;\n                }\n                skip--;\n            }\n            else if (top instanceof TextLeaf) {\n                // Move to the next string\n                let next = top.text[offset - (this.dir < 0 ? 1 : 0)];\n                this.offsets[last] = (offset += this.dir);\n                this.lineBreak = false;\n                if (next.length > Math.max(0, skip)) {\n                    this.value = skip == 0 ? next : this.dir > 0 ? next.slice(skip) : next.slice(0, next.length - skip);\n                    return this;\n                }\n                skip -= next.length;\n            }\n            else {\n                let next = top.children[this.dir > 0 ? offset : offset - 1];\n                this.offsets[last] = offset + this.dir;\n                this.lineBreak = false;\n                if (skip > next.length) {\n                    skip -= next.length;\n                }\n                else {\n                    this.nodes.push(next);\n                    this.offsets.push(this.dir > 0 ? 0 : next instanceof TextLeaf ? next.text.length : next.children.length);\n                }\n            }\n        }\n    }\n}\nclass PartialTextCursor {\n    constructor(text, start, end) {\n        this.value = \"\";\n        this.cursor = new RawTextCursor(text, start > end ? -1 : 1);\n        if (start > end) {\n            this.skip = text.length - start;\n            this.limit = start - end;\n        }\n        else {\n            this.skip = start;\n            this.limit = end - start;\n        }\n    }\n    next(skip = 0) {\n        if (this.limit <= 0) {\n            this.limit = -1;\n        }\n        else {\n            let { value, lineBreak, done } = this.cursor.next(this.skip + skip);\n            this.skip = 0;\n            this.value = value;\n            let len = lineBreak ? 1 : value.length;\n            if (len > this.limit)\n                this.value = this.cursor.dir > 0 ? value.slice(0, this.limit) : value.slice(len - this.limit);\n            if (done || this.value.length == 0)\n                this.limit = -1;\n            else\n                this.limit -= this.value.length;\n        }\n        return this;\n    }\n    get lineBreak() { return this.cursor.lineBreak; }\n    get done() { return this.limit < 0; }\n}\n/// This type describes a line in the document. It is created\n/// on-demand when lines are [queried](#text.Text.lineAt).\nclass Line {\n    /// @internal\n    constructor(\n    /// The position of the start of the line.\n    from, \n    /// The position at the end of the line (_before_ the line break,\n    /// or at the end of document for the last line).\n    to, \n    /// This line's line number (1-based).\n    number, \n    /// The line's content.\n    text) {\n        this.from = from;\n        this.to = to;\n        this.number = number;\n        this.text = text;\n    }\n    /// The length of the line (not including any line break after it).\n    get length() { return this.to - this.from; }\n}\n\nexport { Line, Text, codePointAt, codePointSize, countColumn, findClusterBreak, findColumn, fromCodePoint };\n","import { ViewPlugin, themeClass, Direction, EditorView } from '@codemirror/next/view';\nimport { Facet, StateEffect, StateField, MapMode } from '@codemirror/next/state';\n\nconst Outside = \"-10000px\";\nconst tooltipPlugin = ViewPlugin.fromClass(class {\n    constructor(view) {\n        this.view = view;\n        this.inView = true;\n        this.measureReq = { read: this.readMeasure.bind(this), write: this.writeMeasure.bind(this), key: this };\n        this.tooltips = view.state.facet(showTooltip);\n        this.tooltipViews = this.tooltips.map(tp => this.createTooltip(tp));\n    }\n    update(update) {\n        let tooltips = update.state.facet(showTooltip);\n        if (tooltips == this.tooltips) {\n            for (let t of this.tooltipViews)\n                if (t.update)\n                    t.update(update);\n        }\n        else {\n            let views = [];\n            for (let i = 0; i < tooltips.length; i++) {\n                let tip = tooltips[i], known = -1;\n                for (let i = 0; i < this.tooltips.length; i++)\n                    if (this.tooltips[i].create == tip.create)\n                        known = i;\n                if (known < 0) {\n                    views[i] = this.createTooltip(tip);\n                }\n                else {\n                    let tooltipView = views[i] = this.tooltipViews[known];\n                    if (tooltipView.update)\n                        tooltipView.update(update);\n                }\n            }\n            for (let t of this.tooltipViews)\n                if (views.indexOf(t) < 0)\n                    t.dom.remove();\n            this.tooltips = tooltips;\n            this.tooltipViews = views;\n            this.maybeMeasure();\n        }\n    }\n    createTooltip(tooltip) {\n        let tooltipView = tooltip.create(this.view);\n        tooltipView.dom.className = themeClass(\"tooltip\" + (tooltip.style ? \".\" + tooltip.style : \"\"));\n        this.view.dom.appendChild(tooltipView.dom);\n        if (tooltipView.mount)\n            tooltipView.mount(this.view);\n        return tooltipView;\n    }\n    destroy() {\n        for (let { dom } of this.tooltipViews)\n            dom.remove();\n    }\n    readMeasure() {\n        return {\n            editor: this.view.dom.getBoundingClientRect(),\n            pos: this.tooltips.map(t => this.view.coordsAtPos(t.pos)),\n            size: this.tooltipViews.map(({ dom }) => dom.getBoundingClientRect()),\n            innerWidth: window.innerWidth,\n            innerHeight: window.innerHeight\n        };\n    }\n    writeMeasure(measured) {\n        let { editor } = measured;\n        for (let i = 0; i < this.tooltipViews.length; i++) {\n            let tooltip = this.tooltips[i], tView = this.tooltipViews[i], { dom } = tView;\n            let pos = measured.pos[i], size = measured.size[i];\n            // Hide tooltips that are outside of the editor.\n            if (!pos || pos.bottom <= editor.top || pos.top >= editor.bottom || pos.right <= editor.left || pos.left >= editor.right) {\n                dom.style.top = Outside;\n                continue;\n            }\n            let width = size.right - size.left, height = size.bottom - size.top;\n            let left = this.view.textDirection == Direction.LTR ? Math.min(pos.left, measured.innerWidth - width)\n                : Math.max(0, pos.left - width);\n            let above = !!tooltip.above;\n            if (!tooltip.strictSide &&\n                (above ? pos.top - (size.bottom - size.top) < 0 : pos.bottom + (size.bottom - size.top) > measured.innerHeight))\n                above = !above;\n            dom.style.top = (above ? pos.top - height : pos.bottom) + \"px\";\n            dom.style.left = left + \"px\";\n            dom.classList.toggle(\"cm-tooltip-above\", above);\n            dom.classList.toggle(\"cm-tooltip-below\", !above);\n            if (tView.positioned)\n                tView.positioned();\n        }\n    }\n    maybeMeasure() {\n        if (this.tooltips.length) {\n            if (this.view.inView || this.inView)\n                this.view.requestMeasure(this.measureReq);\n            this.inView = this.view.inView;\n        }\n    }\n}, {\n    eventHandlers: {\n        scroll() { this.maybeMeasure(); }\n    }\n});\nconst baseTheme = EditorView.baseTheme({\n    $tooltip: {\n        position: \"fixed\",\n        border: \"1px solid #ddd\",\n        backgroundColor: \"#f5f5f5\",\n        zIndex: 100\n    }\n});\n/// Supporting extension for displaying tooltips. Allows\n/// [`showTooltip`](#tooltip.showTooltip) to be used to create\n/// tooltips.\nfunction tooltips() {\n    return [tooltipPlugin, baseTheme];\n}\n/// Behavior by which an extension can provide a tooltip to be shown.\nconst showTooltip = Facet.define();\nconst HoverTime = 750, HoverMaxDist = 10;\nclass HoverPlugin {\n    constructor(view, source, field, setHover) {\n        this.view = view;\n        this.source = source;\n        this.field = field;\n        this.setHover = setHover;\n        this.lastMouseMove = null;\n        this.hoverTimeout = -1;\n        this.checkHover = this.checkHover.bind(this);\n        view.dom.addEventListener(\"mouseleave\", this.mouseleave = this.mouseleave.bind(this));\n        view.dom.addEventListener(\"mousemove\", this.mousemove = this.mousemove.bind(this));\n    }\n    get active() {\n        return this.view.state.field(this.field);\n    }\n    checkHover() {\n        this.hoverTimeout = -1;\n        if (this.active)\n            return;\n        let now = Date.now(), lastMove = this.lastMouseMove;\n        if (now - lastMove.timeStamp < HoverTime) {\n            this.hoverTimeout = setTimeout(this.checkHover, HoverTime - (now - lastMove.timeStamp));\n            return;\n        }\n        let coords = { x: lastMove.clientX, y: lastMove.clientY };\n        let pos = this.view.contentDOM.contains(lastMove.target)\n            ? this.view.posAtCoords(coords) : null;\n        if (pos == null)\n            return;\n        let posCoords = this.view.coordsAtPos(pos);\n        if (posCoords == null || coords.y < posCoords.top || coords.y > posCoords.bottom ||\n            coords.x < posCoords.left - this.view.defaultCharacterWidth ||\n            coords.x > posCoords.right + this.view.defaultCharacterWidth)\n            return;\n        let bidi = this.view.bidiSpans(this.view.state.doc.lineAt(pos)).find(s => s.from <= pos && s.to >= pos);\n        let rtl = bidi && bidi.dir == Direction.RTL ? -1 : 1;\n        let open = this.source(this.view, pos, (coords.x < posCoords.left ? -rtl : rtl));\n        if (open)\n            this.view.dispatch({ effects: this.setHover.of(open) });\n    }\n    mousemove(event) {\n        var _a;\n        this.lastMouseMove = event;\n        if (this.hoverTimeout < 0)\n            this.hoverTimeout = setTimeout(this.checkHover, HoverTime);\n        let tooltip = this.active;\n        if (tooltip && !isInTooltip(event.target)) {\n            let { pos } = tooltip, end = (_a = tooltip.end) !== null && _a !== void 0 ? _a : pos;\n            if ((pos == end ? this.view.posAtCoords({ x: event.clientX, y: event.clientY }) != pos\n                : !isOverRange(this.view, pos, end, event.clientX, event.clientY, HoverMaxDist)))\n                this.view.dispatch({ effects: this.setHover.of(null) });\n        }\n    }\n    mouseleave() {\n        clearTimeout(this.hoverTimeout);\n        this.hoverTimeout = -1;\n        if (this.active)\n            this.view.dispatch({ effects: this.setHover.of(null) });\n    }\n    destroy() {\n        clearTimeout(this.hoverTimeout);\n        this.view.dom.removeEventListener(\"mouseleave\", this.mouseleave);\n        this.view.dom.removeEventListener(\"mousemove\", this.mousemove);\n    }\n}\nfunction isInTooltip(elt) {\n    for (let cur = elt; cur; cur = cur.parentNode)\n        if (cur.nodeType == 1 && cur.classList.contains(\"cm-tooltip\"))\n            return true;\n    return false;\n}\nfunction isOverRange(view, from, to, x, y, margin) {\n    let range = document.createRange();\n    let fromDOM = view.domAtPos(from), toDOM = view.domAtPos(to);\n    range.setEnd(toDOM.node, toDOM.offset);\n    range.setStart(fromDOM.node, fromDOM.offset);\n    let rects = range.getClientRects();\n    range.detach();\n    for (let i = 0; i < rects.length; i++) {\n        let rect = rects[i];\n        let dist = Math.max(rect.top - y, y - rect.bottom, rect.left - x, x - rect.right);\n        if (dist <= margin)\n            return true;\n    }\n    return false;\n}\n/// Enable a hover tooltip, which shows up when the pointer hovers\n/// over ranges of text. The callback is called when the mouse overs\n/// over the document text. It should, if there is a tooltip\n/// associated with position `pos` return the tooltip description. The\n/// `side` argument indicates on which side of the position the\n/// pointer is—it will be -1 if the pointer is before\n/// the position, 1 if after the position.\nfunction hoverTooltip(source, options = {}) {\n    const setHover = StateEffect.define();\n    const hoverState = StateField.define({\n        create() { return null; },\n        update(value, tr) {\n            if (value && (options.hideOnChange && (tr.docChanged || tr.selection)))\n                return null;\n            for (let effect of tr.effects)\n                if (effect.is(setHover))\n                    return effect.value;\n            if (value && tr.docChanged) {\n                let newPos = tr.changes.mapPos(value.pos, -1, MapMode.TrackDel);\n                if (newPos == null)\n                    return null;\n                let copy = Object.assign(Object.create(null), value);\n                copy.pos = newPos;\n                if (value.end != null)\n                    copy.end = tr.changes.mapPos(value.end);\n                return copy;\n            }\n            return value;\n        },\n        provide: f => showTooltip.computeN([f], s => { let val = s.field(f); return val ? [val] : []; })\n    });\n    return [\n        hoverState,\n        ViewPlugin.define(view => new HoverPlugin(view, source, hoverState, setHover)),\n        tooltips()\n    ];\n}\n\nexport { hoverTooltip, showTooltip, tooltips };\n","import { MapMode, Facet, Text as Text$1, EditorSelection, ChangeSet, Transaction, CharCategory, EditorState, Prec, combineConfig } from '@codemirror/next/state';\nimport { StyleModule } from 'style-mod';\nimport { RangeValue, RangeSet } from '@codemirror/next/rangeset';\nexport { Range } from '@codemirror/next/rangeset';\nimport { Text, findClusterBreak, countColumn, findColumn, codePointAt } from '@codemirror/next/text';\nimport { keyName, base } from 'w3c-keyname';\n\nlet [nav, doc] = typeof navigator != \"undefined\"\n    ? [navigator, document]\n    : [{ userAgent: \"\", vendor: \"\", platform: \"\" }, { documentElement: { style: {} } }];\nconst ie_edge = /Edge\\/(\\d+)/.exec(nav.userAgent);\nconst ie_upto10 = /MSIE \\d/.test(nav.userAgent);\nconst ie_11up = /Trident\\/(?:[7-9]|\\d{2,})\\..*rv:(\\d+)/.exec(nav.userAgent);\nconst ie = !!(ie_upto10 || ie_11up || ie_edge);\nconst gecko = !ie && /gecko\\/(\\d+)/i.test(nav.userAgent);\nconst chrome = !ie && /Chrome\\/(\\d+)/.exec(nav.userAgent);\nconst webkit = \"webkitFontSmoothing\" in doc.documentElement.style;\nconst safari = !ie && /Apple Computer/.test(nav.vendor);\nvar browser = {\n    mac: /Mac/.test(nav.platform),\n    ie,\n    ie_version: ie_upto10 ? doc.documentMode || 6 : ie_11up ? +ie_11up[1] : ie_edge ? +ie_edge[1] : 0,\n    gecko,\n    gecko_version: gecko ? +(/Firefox\\/(\\d+)/.exec(nav.userAgent) || [0, 0])[1] : 0,\n    chrome: !!chrome,\n    chrome_version: chrome ? +chrome[1] : 0,\n    ios: safari && (/Mobile\\/\\w+/.test(nav.userAgent) || nav.maxTouchPoints > 2),\n    android: /Android\\b/.test(nav.userAgent),\n    webkit,\n    safari,\n    webkit_version: webkit ? +(/\\bAppleWebKit\\/(\\d+)/.exec(navigator.userAgent) || [0, 0])[1] : 0,\n    tabSize: doc.documentElement.style.tabSize != null ? \"tab-size\" : \"-moz-tab-size\"\n};\n\nfunction getSelection(root) {\n    return (root.getSelection ? root.getSelection() : document.getSelection());\n}\n// Work around Chrome issue https://bugs.chromium.org/p/chromium/issues/detail?id=447523\n// (isCollapsed inappropriately returns true in shadow dom)\nfunction selectionCollapsed(domSel) {\n    let collapsed = domSel.isCollapsed;\n    if (collapsed && browser.chrome && domSel.rangeCount && !domSel.getRangeAt(0).collapsed)\n        collapsed = false;\n    return collapsed;\n}\nfunction hasSelection(dom, selection) {\n    if (!selection.anchorNode)\n        return false;\n    try {\n        // Firefox will raise 'permission denied' errors when accessing\n        // properties of `sel.anchorNode` when it's in a generated CSS\n        // element.\n        return dom.contains(selection.anchorNode.nodeType == 3 ? selection.anchorNode.parentNode : selection.anchorNode);\n    }\n    catch (_) {\n        return false;\n    }\n}\nfunction clientRectsFor(dom) {\n    if (dom.nodeType == 3) {\n        let range = tempRange();\n        range.setEnd(dom, dom.nodeValue.length);\n        range.setStart(dom, 0);\n        return range.getClientRects();\n    }\n    else if (dom.nodeType == 1) {\n        return dom.getClientRects();\n    }\n    else {\n        return [];\n    }\n}\n// Scans forward and backward through DOM positions equivalent to the\n// given one to see if the two are in the same place (i.e. after a\n// text node vs at the end of that text node)\nfunction isEquivalentPosition(node, off, targetNode, targetOff) {\n    return targetNode ? (scanFor(node, off, targetNode, targetOff, -1) ||\n        scanFor(node, off, targetNode, targetOff, 1)) : false;\n}\nfunction domIndex(node) {\n    for (var index = 0;; index++) {\n        node = node.previousSibling;\n        if (!node)\n            return index;\n    }\n}\nfunction scanFor(node, off, targetNode, targetOff, dir) {\n    for (;;) {\n        if (node == targetNode && off == targetOff)\n            return true;\n        if (off == (dir < 0 ? 0 : maxOffset(node))) {\n            if (node.nodeName == \"DIV\")\n                return false;\n            let parent = node.parentNode;\n            if (!parent || parent.nodeType != 1)\n                return false;\n            off = domIndex(node) + (dir < 0 ? 0 : 1);\n            node = parent;\n        }\n        else if (node.nodeType == 1) {\n            node = node.childNodes[off + (dir < 0 ? -1 : 0)];\n            off = dir < 0 ? maxOffset(node) : 0;\n        }\n        else {\n            return false;\n        }\n    }\n}\nfunction maxOffset(node) {\n    return node.nodeType == 3 ? node.nodeValue.length : node.childNodes.length;\n}\nfunction flattenRect(rect, left) {\n    let x = left ? rect.left : rect.right;\n    return { left: x, right: x, top: rect.top, bottom: rect.bottom };\n}\nfunction windowRect(win) {\n    return { left: 0, right: win.innerWidth,\n        top: 0, bottom: win.innerHeight };\n}\nconst ScrollSpace = 5;\nfunction scrollRectIntoView(dom, rect) {\n    let doc = dom.ownerDocument, win = doc.defaultView;\n    for (let cur = dom.parentNode; cur;) {\n        if (cur.nodeType == 1) { // Element\n            let bounding, top = cur == document.body;\n            if (top) {\n                bounding = windowRect(win);\n            }\n            else {\n                if (cur.scrollHeight <= cur.clientHeight && cur.scrollWidth <= cur.clientWidth) {\n                    cur = cur.parentNode;\n                    continue;\n                }\n                let rect = cur.getBoundingClientRect();\n                // Make sure scrollbar width isn't included in the rectangle\n                bounding = { left: rect.left, right: rect.left + cur.clientWidth,\n                    top: rect.top, bottom: rect.top + cur.clientHeight };\n            }\n            let moveX = 0, moveY = 0;\n            if (rect.top < bounding.top)\n                moveY = -(bounding.top - rect.top + ScrollSpace);\n            else if (rect.bottom > bounding.bottom)\n                moveY = rect.bottom - bounding.bottom + ScrollSpace;\n            if (rect.left < bounding.left)\n                moveX = -(bounding.left - rect.left + ScrollSpace);\n            else if (rect.right > bounding.right)\n                moveX = rect.right - bounding.right + ScrollSpace;\n            if (moveX || moveY) {\n                if (top) {\n                    win.scrollBy(moveX, moveY);\n                }\n                else {\n                    if (moveY) {\n                        let start = cur.scrollTop;\n                        cur.scrollTop += moveY;\n                        moveY = cur.scrollTop - start;\n                    }\n                    if (moveX) {\n                        let start = cur.scrollLeft;\n                        cur.scrollLeft += moveX;\n                        moveX = cur.scrollLeft - start;\n                    }\n                    rect = { left: rect.left - moveX, top: rect.top - moveY,\n                        right: rect.right - moveX, bottom: rect.bottom - moveY };\n                }\n            }\n            if (top)\n                break;\n            cur = cur.parentNode;\n        }\n        else if (cur.nodeType == 11) { // A shadow root\n            cur = cur.host;\n        }\n        else {\n            break;\n        }\n    }\n}\nclass DOMSelection {\n    constructor() {\n        this.anchorNode = null;\n        this.anchorOffset = 0;\n        this.focusNode = null;\n        this.focusOffset = 0;\n    }\n    eq(domSel) {\n        return this.anchorNode == domSel.anchorNode && this.anchorOffset == domSel.anchorOffset &&\n            this.focusNode == domSel.focusNode && this.focusOffset == domSel.focusOffset;\n    }\n    set(domSel) {\n        this.anchorNode = domSel.anchorNode;\n        this.anchorOffset = domSel.anchorOffset;\n        this.focusNode = domSel.focusNode;\n        this.focusOffset = domSel.focusOffset;\n    }\n}\nlet preventScrollSupported = null;\n// Feature-detects support for .focus({preventScroll: true}), and uses\n// a fallback kludge when not supported.\nfunction focusPreventScroll(dom) {\n    if (dom.setActive)\n        return dom.setActive(); // in IE\n    if (preventScrollSupported)\n        return dom.focus(preventScrollSupported);\n    let stack = [];\n    for (let cur = dom; cur; cur = cur.parentNode) {\n        stack.push(cur, cur.scrollTop, cur.scrollLeft);\n        if (cur == cur.ownerDocument)\n            break;\n    }\n    dom.focus(preventScrollSupported == null ? {\n        get preventScroll() {\n            preventScrollSupported = { preventScroll: true };\n            return true;\n        }\n    } : undefined);\n    if (!preventScrollSupported) {\n        preventScrollSupported = false;\n        for (let i = 0; i < stack.length;) {\n            let elt = stack[i++], top = stack[i++], left = stack[i++];\n            if (elt.scrollTop != top)\n                elt.scrollTop = top;\n            if (elt.scrollLeft != left)\n                elt.scrollLeft = left;\n        }\n    }\n}\nlet scratchRange;\nfunction tempRange() { return scratchRange || (scratchRange = document.createRange()); }\n\nclass DOMPos {\n    constructor(node, offset, precise = true) {\n        this.node = node;\n        this.offset = offset;\n        this.precise = precise;\n    }\n    static before(dom, precise) { return new DOMPos(dom.parentNode, domIndex(dom), precise); }\n    static after(dom, precise) { return new DOMPos(dom.parentNode, domIndex(dom) + 1, precise); }\n}\nconst none = [];\nclass ContentView {\n    constructor() {\n        this.parent = null;\n        this.dom = null;\n        this.dirty = 2 /* Node */;\n    }\n    get editorView() {\n        if (!this.parent)\n            throw new Error(\"Accessing view in orphan content view\");\n        return this.parent.editorView;\n    }\n    get overrideDOMText() { return null; }\n    get posAtStart() {\n        return this.parent ? this.parent.posBefore(this) : 0;\n    }\n    get posAtEnd() {\n        return this.posAtStart + this.length;\n    }\n    posBefore(view) {\n        let pos = this.posAtStart;\n        for (let child of this.children) {\n            if (child == view)\n                return pos;\n            pos += child.length + child.breakAfter;\n        }\n        throw new RangeError(\"Invalid child in posBefore\");\n    }\n    posAfter(view) {\n        return this.posBefore(view) + view.length;\n    }\n    // Will return a rectangle directly before (when side < 0), after\n    // (side > 0) or directly on (when the browser supports it) the\n    // given position.\n    coordsAt(_pos, _side) { return null; }\n    sync(track) {\n        if (this.dirty & 2 /* Node */) {\n            let parent = this.dom, pos = null;\n            for (let child of this.children) {\n                if (child.dirty) {\n                    let next = pos ? pos.nextSibling : parent.firstChild;\n                    if (next && !child.dom && !ContentView.get(next))\n                        child.reuseDOM(next);\n                    child.sync(track);\n                    child.dirty = 0 /* Not */;\n                }\n                if (track && track.node == parent && pos != child.dom)\n                    track.written = true;\n                syncNodeInto(parent, pos, child.dom);\n                pos = child.dom;\n            }\n            let next = pos ? pos.nextSibling : parent.firstChild;\n            if (next && track && track.node == parent)\n                track.written = true;\n            while (next)\n                next = rm(next);\n        }\n        else if (this.dirty & 1 /* Child */) {\n            for (let child of this.children)\n                if (child.dirty) {\n                    child.sync(track);\n                    child.dirty = 0 /* Not */;\n                }\n        }\n    }\n    reuseDOM(_dom) { return false; }\n    localPosFromDOM(node, offset) {\n        let after;\n        if (node == this.dom) {\n            after = this.dom.childNodes[offset];\n        }\n        else {\n            let bias = maxOffset(node) == 0 ? 0 : offset == 0 ? -1 : 1;\n            for (;;) {\n                let parent = node.parentNode;\n                if (parent == this.dom)\n                    break;\n                if (bias == 0 && parent.firstChild != parent.lastChild) {\n                    if (node == parent.firstChild)\n                        bias = -1;\n                    else\n                        bias = 1;\n                }\n                node = parent;\n            }\n            if (bias < 0)\n                after = node;\n            else\n                after = node.nextSibling;\n        }\n        if (after == this.dom.firstChild)\n            return 0;\n        while (after && !ContentView.get(after))\n            after = after.nextSibling;\n        if (!after)\n            return this.length;\n        for (let i = 0, pos = 0;; i++) {\n            let child = this.children[i];\n            if (child.dom == after)\n                return pos;\n            pos += child.length + child.breakAfter;\n        }\n    }\n    domBoundsAround(from, to, offset = 0) {\n        let fromI = -1, fromStart = -1, toI = -1, toEnd = -1;\n        for (let i = 0, pos = offset; i < this.children.length; i++) {\n            let child = this.children[i], end = pos + child.length;\n            if (pos < from && end > to)\n                return child.domBoundsAround(from, to, pos);\n            if (end >= from && fromI == -1) {\n                fromI = i;\n                fromStart = pos;\n            }\n            if (end >= to && end != pos && toI == -1) {\n                toI = i;\n                toEnd = end;\n                break;\n            }\n            pos = end + child.breakAfter;\n        }\n        return { from: fromStart, to: toEnd < 0 ? offset + this.length : toEnd, startDOM: (fromI ? this.children[fromI - 1].dom.nextSibling : null) || this.dom.firstChild, endDOM: toI < this.children.length - 1 && toI >= 0 ? this.children[toI + 1].dom : null };\n    }\n    markDirty(andParent = false) {\n        if (this.dirty & 2 /* Node */)\n            return;\n        this.dirty |= 2 /* Node */;\n        this.markParentsDirty(andParent);\n    }\n    markParentsDirty(childList) {\n        for (let parent = this.parent; parent; parent = parent.parent) {\n            if (childList)\n                parent.dirty |= 2 /* Node */;\n            if (parent.dirty & 1 /* Child */)\n                return;\n            parent.dirty |= 1 /* Child */;\n            childList = false;\n        }\n    }\n    setParent(parent) {\n        if (this.parent != parent) {\n            this.parent = parent;\n            if (this.dirty)\n                this.markParentsDirty(true);\n        }\n    }\n    setDOM(dom) {\n        this.dom = dom;\n        dom.cmView = this;\n    }\n    get rootView() {\n        for (let v = this;;) {\n            let parent = v.parent;\n            if (!parent)\n                return v;\n            v = parent;\n        }\n    }\n    replaceChildren(from, to, children = none) {\n        this.markDirty();\n        for (let i = from; i < to; i++)\n            this.children[i].parent = null;\n        this.children.splice(from, to - from, ...children);\n        for (let i = 0; i < children.length; i++)\n            children[i].setParent(this);\n    }\n    ignoreMutation(_rec) { return false; }\n    ignoreEvent(_event) { return false; }\n    childCursor(pos = this.length) {\n        return new ChildCursor(this.children, pos, this.children.length);\n    }\n    childPos(pos, bias = 1) {\n        return this.childCursor().findPos(pos, bias);\n    }\n    toString() {\n        let name = this.constructor.name.replace(\"View\", \"\");\n        return name + (this.children.length ? \"(\" + this.children.join() + \")\" :\n            this.length ? \"[\" + (name == \"Text\" ? this.text : this.length) + \"]\" : \"\") +\n            (this.breakAfter ? \"#\" : \"\");\n    }\n    static get(node) { return node.cmView; }\n}\nContentView.prototype.breakAfter = 0;\n// Remove a DOM node and return its next sibling.\nfunction rm(dom) {\n    let next = dom.nextSibling;\n    dom.parentNode.removeChild(dom);\n    return next;\n}\nfunction syncNodeInto(parent, after, dom) {\n    let next = after ? after.nextSibling : parent.firstChild;\n    if (dom.parentNode == parent)\n        while (next != dom)\n            next = rm(next);\n    else\n        parent.insertBefore(dom, next);\n}\nclass ChildCursor {\n    constructor(children, pos, i) {\n        this.children = children;\n        this.pos = pos;\n        this.i = i;\n        this.off = 0;\n    }\n    findPos(pos, bias = 1) {\n        for (;;) {\n            if (pos > this.pos || pos == this.pos &&\n                (bias > 0 || this.i == 0 || this.children[this.i - 1].breakAfter)) {\n                this.off = pos - this.pos;\n                return this;\n            }\n            let next = this.children[--this.i];\n            this.pos -= next.length + next.breakAfter;\n        }\n    }\n}\n\nconst none$1 = [];\nclass InlineView extends ContentView {\n    /// Return true when this view is equivalent to `other` and can take\n    /// on its role.\n    become(_other) { return false; }\n    // When this is a zero-length view with a side, this should return a\n    // negative number to indicate it is before its position, or a\n    // positive number when after its position.\n    getSide() { return 0; }\n}\nInlineView.prototype.children = none$1;\nconst MaxJoinLen = 256;\nclass TextView extends InlineView {\n    constructor(text) {\n        super();\n        this.text = text;\n    }\n    get length() { return this.text.length; }\n    createDOM(textDOM) {\n        this.setDOM(textDOM || document.createTextNode(this.text));\n    }\n    sync(track) {\n        if (!this.dom)\n            this.createDOM();\n        if (this.dom.nodeValue != this.text) {\n            if (track && track.node == this.dom)\n                track.written = true;\n            this.dom.nodeValue = this.text;\n        }\n    }\n    reuseDOM(dom) {\n        if (dom.nodeType != 3)\n            return false;\n        this.createDOM(dom);\n        return true;\n    }\n    merge(from, to, source) {\n        if (source && (!(source instanceof TextView) || this.length - (to - from) + source.length > MaxJoinLen))\n            return false;\n        this.text = this.text.slice(0, from) + (source ? source.text : \"\") + this.text.slice(to);\n        this.markDirty();\n        return true;\n    }\n    slice(from) {\n        return new TextView(this.text.slice(from));\n    }\n    localPosFromDOM(node, offset) {\n        return node == this.dom ? offset : offset ? this.text.length : 0;\n    }\n    domAtPos(pos) { return new DOMPos(this.dom, pos); }\n    domBoundsAround(_from, _to, offset) {\n        return { from: offset, to: offset + this.length, startDOM: this.dom, endDOM: this.dom.nextSibling };\n    }\n    coordsAt(pos, side) {\n        return textCoords(this.dom, pos, side, this.length);\n    }\n}\nclass MarkView extends InlineView {\n    constructor(mark, children = [], length = 0) {\n        super();\n        this.mark = mark;\n        this.children = children;\n        this.length = length;\n        for (let ch of children)\n            ch.setParent(this);\n    }\n    createDOM() {\n        let dom = document.createElement(this.mark.tagName);\n        if (this.mark.class)\n            dom.className = this.mark.class;\n        if (this.mark.attrs)\n            for (let name in this.mark.attrs)\n                dom.setAttribute(name, this.mark.attrs[name]);\n        this.setDOM(dom);\n    }\n    sync(track) {\n        if (!this.dom)\n            this.createDOM();\n        super.sync(track);\n    }\n    merge(from, to, source, openStart, openEnd) {\n        if (source && (!(source instanceof MarkView && source.mark.eq(this.mark)) ||\n            (from && openStart <= 0) || (to < this.length && openEnd <= 0)))\n            return false;\n        mergeInlineChildren(this, from, to, source ? source.children : none$1, openStart - 1, openEnd - 1);\n        this.markDirty();\n        return true;\n    }\n    slice(from) {\n        return new MarkView(this.mark, sliceInlineChildren(this.children, from), this.length - from);\n    }\n    domAtPos(pos) {\n        return inlineDOMAtPos(this.dom, this.children, pos);\n    }\n    coordsAt(pos, side) {\n        return coordsInChildren(this, pos, side);\n    }\n}\nfunction textCoords(text, pos, side, length) {\n    let from = pos, to = pos, flatten = 0;\n    if (pos == 0 && side < 0 || pos == length && side >= 0) {\n        if (!(browser.chrome || browser.gecko)) { // These browsers reliably return valid rectangles for empty ranges\n            if (pos) {\n                from--;\n                flatten = 1;\n            } // FIXME this is wrong in RTL text\n            else {\n                to++;\n                flatten = -1;\n            }\n        }\n    }\n    else {\n        if (side < 0)\n            from--;\n        else\n            to++;\n    }\n    let range = tempRange();\n    range.setEnd(text, to);\n    range.setStart(text, from);\n    let rects = range.getClientRects(), rect = rects[(flatten ? flatten < 0 : side >= 0) ? 0 : rects.length - 1];\n    if (browser.safari && !flatten && rect.width == 0)\n        rect = Array.prototype.find.call(rects, r => r.width) || rect;\n    return flatten ? flattenRect(rect, flatten < 0) : rect;\n}\n// Also used for collapsed ranges that don't have a placeholder widget!\nclass WidgetView extends InlineView {\n    constructor(widget, length, side) {\n        super();\n        this.widget = widget;\n        this.length = length;\n        this.side = side;\n    }\n    static create(widget, length, side) {\n        return new (widget.customView || WidgetView)(widget, length, side);\n    }\n    slice(from) { return WidgetView.create(this.widget, this.length - from, this.side); }\n    sync() {\n        if (!this.dom || !this.widget.updateDOM(this.dom)) {\n            this.setDOM(this.widget.toDOM(this.editorView));\n            this.dom.contentEditable = \"false\";\n        }\n    }\n    getSide() { return this.side; }\n    merge(from, to, source, openStart, openEnd) {\n        if (source && (!(source instanceof WidgetView) || !this.widget.compare(source.widget) ||\n            from > 0 && openStart <= 0 || to < this.length && openEnd <= 0))\n            return false;\n        this.length = from + (source ? source.length : 0) + (this.length - to);\n        return true;\n    }\n    become(other) {\n        if (other.length == this.length && other instanceof WidgetView && other.side == this.side) {\n            if (this.widget.constructor == other.widget.constructor) {\n                if (!this.widget.eq(other.widget))\n                    this.markDirty(true);\n                this.widget = other.widget;\n                return true;\n            }\n        }\n        return false;\n    }\n    ignoreMutation() { return true; }\n    ignoreEvent(event) { return this.widget.ignoreEvent(event); }\n    get overrideDOMText() {\n        if (this.length == 0)\n            return Text.empty;\n        let top = this;\n        while (top.parent)\n            top = top.parent;\n        let view = top.editorView, text = view && view.state.doc, start = this.posAtStart;\n        return text ? text.slice(start, start + this.length) : Text.empty;\n    }\n    domAtPos(pos) {\n        return pos == 0 ? DOMPos.before(this.dom) : DOMPos.after(this.dom, pos == this.length);\n    }\n    domBoundsAround() { return null; }\n    coordsAt(pos, side) {\n        let rects = this.dom.getClientRects(), rect = null;\n        for (let i = pos > 0 ? rects.length - 1 : 0;; i += (pos > 0 ? -1 : 1)) {\n            rect = rects[i];\n            if (pos > 0 ? i == 0 : i == rects.length - 1 || rect.top < rect.bottom)\n                break;\n        }\n        return (pos == 0 && side > 0 || pos == this.length && side <= 0) ? rect : flattenRect(rect, pos == 0);\n    }\n}\nclass CompositionView extends WidgetView {\n    domAtPos(pos) { return new DOMPos(this.widget.text, pos); }\n    sync() { if (!this.dom)\n        this.setDOM(this.widget.toDOM()); }\n    localPosFromDOM(node, offset) {\n        return !offset ? 0 : node.nodeType == 3 ? Math.min(offset, this.length) : this.length;\n    }\n    ignoreMutation() { return false; }\n    get overrideDOMText() { return null; }\n    coordsAt(pos, side) { return textCoords(this.widget.text, pos, side, this.length); }\n}\nfunction mergeInlineChildren(parent, from, to, elts, openStart, openEnd) {\n    let cur = parent.childCursor();\n    let { i: toI, off: toOff } = cur.findPos(to, 1);\n    let { i: fromI, off: fromOff } = cur.findPos(from, -1);\n    let dLen = from - to;\n    for (let view of elts)\n        dLen += view.length;\n    parent.length += dLen;\n    let { children } = parent;\n    // Both from and to point into the same text view\n    if (fromI == toI && fromOff) {\n        let start = children[fromI];\n        // Maybe just update that view and be done\n        if (elts.length == 1 && start.merge(fromOff, toOff, elts[0], openStart, openEnd))\n            return;\n        if (elts.length == 0) {\n            start.merge(fromOff, toOff, null, openStart, openEnd);\n            return;\n        }\n        // Otherwise split it, so that we don't have to worry about aliasing front/end afterwards\n        let after = start.slice(toOff);\n        if (after.merge(0, 0, elts[elts.length - 1], 0, openEnd))\n            elts[elts.length - 1] = after;\n        else\n            elts.push(after);\n        toI++;\n        openEnd = toOff = 0;\n    }\n    // Make sure start and end positions fall on node boundaries\n    // (fromOff/toOff are no longer used after this), and that if the\n    // start or end of the elts can be merged with adjacent nodes,\n    // this is done\n    if (toOff) {\n        let end = children[toI];\n        if (elts.length && end.merge(0, toOff, elts[elts.length - 1], 0, openEnd)) {\n            elts.pop();\n            openEnd = 0;\n        }\n        else {\n            end.merge(0, toOff, null, 0, 0);\n        }\n    }\n    else if (toI < children.length && elts.length &&\n        children[toI].merge(0, 0, elts[elts.length - 1], 0, openEnd)) {\n        elts.pop();\n        openEnd = 0;\n    }\n    if (fromOff) {\n        let start = children[fromI];\n        if (elts.length && start.merge(fromOff, start.length, elts[0], openStart, 0)) {\n            elts.shift();\n            openStart = 0;\n        }\n        else {\n            start.merge(fromOff, start.length, null, 0, 0);\n        }\n        fromI++;\n    }\n    else if (fromI && elts.length) {\n        let end = children[fromI - 1];\n        if (end.merge(end.length, end.length, elts[0], openStart, 0)) {\n            elts.shift();\n            openStart = 0;\n        }\n    }\n    // Then try to merge any mergeable nodes at the start and end of\n    // the changed range\n    while (fromI < toI && elts.length && children[toI - 1].become(elts[elts.length - 1])) {\n        elts.pop();\n        toI--;\n        openEnd = 0;\n    }\n    while (fromI < toI && elts.length && children[fromI].become(elts[0])) {\n        elts.shift();\n        fromI++;\n        openStart = 0;\n    }\n    if (!elts.length && fromI && toI < children.length && openStart && openEnd &&\n        children[toI].merge(0, 0, children[fromI - 1], openStart, openEnd))\n        fromI--;\n    // And if anything remains, splice the child array to insert the new elts\n    if (elts.length || fromI != toI)\n        parent.replaceChildren(fromI, toI, elts);\n}\nfunction sliceInlineChildren(children, from) {\n    let result = [], off = 0;\n    for (let elt of children) {\n        let end = off + elt.length;\n        if (end > from)\n            result.push(off < from ? elt.slice(from - off) : elt);\n        off = end;\n    }\n    return result;\n}\nfunction inlineDOMAtPos(dom, children, pos) {\n    let i = 0;\n    for (let off = 0; i < children.length; i++) {\n        let child = children[i], end = off + child.length;\n        if (end == off && child.getSide() <= 0)\n            continue;\n        if (pos > off && pos < end && child.dom.parentNode == dom)\n            return child.domAtPos(pos - off);\n        if (pos <= off)\n            break;\n        off = end;\n    }\n    for (; i > 0; i--) {\n        let before = children[i - 1].dom;\n        if (before.parentNode == dom)\n            return DOMPos.after(before);\n    }\n    return new DOMPos(dom, 0);\n}\n// Assumes `view`, if a mark view, has precisely 1 child.\nfunction joinInlineInto(parent, view, open) {\n    let last, { children } = parent;\n    if (open > 0 && view instanceof MarkView && children.length &&\n        (last = children[children.length - 1]) instanceof MarkView && last.mark.eq(view.mark)) {\n        joinInlineInto(last, view.children[0], open - 1);\n    }\n    else {\n        children.push(view);\n        view.setParent(parent);\n    }\n    parent.length += view.length;\n}\nfunction coordsInChildren(view, pos, side) {\n    for (let off = 0, i = 0; i < view.children.length; i++) {\n        let child = view.children[i], end = off + child.length;\n        if (end == off && child.getSide() <= 0)\n            continue;\n        if (side <= 0 || end == view.length ? end >= pos : end > pos)\n            return child.coordsAt(pos - off, side);\n        off = end;\n    }\n    return (view.dom.lastChild || view.dom).getBoundingClientRect();\n}\n\nfunction combineAttrs(source, target) {\n    for (let name in source) {\n        if (name == \"class\" && target.class)\n            target.class += \" \" + source.class;\n        else if (name == \"style\" && target.style)\n            target.style += \";\" + source.style;\n        else\n            target[name] = source[name];\n    }\n    return target;\n}\nfunction attrsEq(a, b) {\n    if (a == b)\n        return true;\n    if (!a || !b)\n        return false;\n    let keysA = Object.keys(a), keysB = Object.keys(b);\n    if (keysA.length != keysB.length)\n        return false;\n    for (let key of keysA) {\n        if (keysB.indexOf(key) == -1 || a[key] !== b[key])\n            return false;\n    }\n    return true;\n}\nfunction updateAttrs(dom, prev, attrs) {\n    if (prev)\n        for (let name in prev)\n            if (!(attrs && name in attrs))\n                dom.removeAttribute(name);\n    if (attrs)\n        for (let name in attrs)\n            if (!(prev && prev[name] == attrs[name]))\n                dom.setAttribute(name, attrs[name]);\n}\n\n/// Widgets added to the content are described by subclasses of this\n/// class. Using a description object like that makes it possible to\n/// delay creating of the DOM structure for a widget until it is\n/// needed, and to avoid redrawing widgets even when the decorations\n/// that define them are recreated.\nclass WidgetType {\n    /// Compare this instance to another instance of the same type.\n    /// (TypeScript can't express this, but only instances of the same\n    /// specific class will be passed to this method.) This is used to\n    /// avoid redrawing widgets when they are replaced by a new\n    /// decoration of the same type. The default implementation just\n    /// returns `false`, which will cause new instances of the widget to\n    /// always be redrawn.\n    eq(_widget) { return false; }\n    /// Update a DOM element created by a widget of the same type (but\n    /// different, non-`eq` content) to reflect this widget. May return\n    /// true to indicate that it could update, false to indicate it\n    /// couldn't (in which case the widget will be redrawn). The default\n    /// implementation just returns false.\n    updateDOM(_dom) { return false; }\n    /// @internal\n    compare(other) {\n        return this == other || this.constructor == other.constructor && this.eq(other);\n    }\n    /// The estimated height this widget will have, to be used when\n    /// estimating the height of content that hasn't been drawn. May\n    /// return -1 to indicate you don't know. The default implementation\n    /// returns -1.\n    get estimatedHeight() { return -1; }\n    /// Can be used to configure which kinds of events inside the widget\n    /// should be ignored by the editor. The default is to ignore all\n    /// events.\n    ignoreEvent(_event) { return true; }\n    //// @internal\n    get customView() { return null; }\n}\n/// The different types of blocks that can occur in an editor view.\nvar BlockType;\n(function (BlockType) {\n    /// A line of text.\n    BlockType[BlockType[\"Text\"] = 0] = \"Text\";\n    /// A block widget associated with the position after it.\n    BlockType[BlockType[\"WidgetBefore\"] = 1] = \"WidgetBefore\";\n    /// A block widget associated with the position before it.\n    BlockType[BlockType[\"WidgetAfter\"] = 2] = \"WidgetAfter\";\n    /// A block widget [replacing](#view.Decoration^replace) a range of content.\n    BlockType[BlockType[\"WidgetRange\"] = 3] = \"WidgetRange\";\n})(BlockType || (BlockType = {}));\n/// A decoration provides information on how to draw or style a piece\n/// of content. You'll usually use it wrapped in a\n/// [`Range`](#rangeset.Range), which adds a start and end position.\nclass Decoration extends RangeValue {\n    /// @internal\n    constructor(\n    /// @internal\n    startSide, \n    /// @internal\n    endSide, \n    /// @internal\n    widget, \n    /// The config object used to create this decoration. You can\n    /// include additional properties in there to store metadata about\n    /// your decoration.\n    spec) {\n        super();\n        this.startSide = startSide;\n        this.endSide = endSide;\n        this.widget = widget;\n        this.spec = spec;\n    }\n    /// @internal\n    get heightRelevant() { return false; }\n    /// Create a mark decoration, which influences the styling of the\n    /// content in its range. Nested mark decorations will cause nested\n    /// DOM elements to be created. Nesting order is determined by\n    /// precedence of the [facet](#view.EditorView^decorations) or\n    /// (below the facet-provided decorations) [view\n    /// plugin](#view.PluginSpec.decorations). Such elements are split\n    /// on line boundaries and on the boundaries of higher-precedence\n    /// decorations.\n    static mark(spec) {\n        return new MarkDecoration(spec);\n    }\n    /// Create a widget decoration, which adds an element at the given\n    /// position.\n    static widget(spec) {\n        let side = spec.side || 0;\n        if (spec.block)\n            side += (200000000 /* BigBlock */ + 1) * (side > 0 ? 1 : -1);\n        return new PointDecoration(spec, side, side, !!spec.block, spec.widget || null, false);\n    }\n    /// Create a replace decoration which replaces the given range with\n    /// a widget, or simply hides it.\n    static replace(spec) {\n        let block = !!spec.block;\n        let { start, end } = getInclusive(spec);\n        let startSide = block ? -200000000 /* BigBlock */ * (start ? 2 : 1) : 100000000 /* BigInline */ * (start ? -1 : 1);\n        let endSide = block ? 200000000 /* BigBlock */ * (end ? 2 : 1) : 100000000 /* BigInline */ * (end ? 1 : -1);\n        return new PointDecoration(spec, startSide, endSide, block, spec.widget || null, true);\n    }\n    /// Create a line decoration, which can add DOM attributes to the\n    /// line starting at the given position.\n    static line(spec) {\n        return new LineDecoration(spec);\n    }\n    /// Build a [`DecorationSet`](#view.DecorationSet) from the given\n    /// decorated range or ranges. If the ranges aren't already sorted,\n    /// pass `true` for `sort` to make the library sort them for you.\n    static set(of, sort = false) {\n        return RangeSet.of(of, sort);\n    }\n    /// @internal\n    hasHeight() { return this.widget ? this.widget.estimatedHeight > -1 : false; }\n}\n/// The empty set of decorations.\nDecoration.none = RangeSet.empty;\nclass MarkDecoration extends Decoration {\n    constructor(spec) {\n        let { start, end } = getInclusive(spec);\n        super(100000000 /* BigInline */ * (start ? -1 : 1), 100000000 /* BigInline */ * (end ? 1 : -1), null, spec);\n        this.tagName = spec.tagName || \"span\";\n        this.class = spec.class || \"\";\n        this.attrs = spec.attributes || null;\n    }\n    eq(other) {\n        return this == other ||\n            other instanceof MarkDecoration &&\n                this.tagName == other.tagName &&\n                this.class == other.class &&\n                attrsEq(this.attrs, other.attrs);\n    }\n    range(from, to = from) {\n        if (from >= to)\n            throw new RangeError(\"Mark decorations may not be empty\");\n        return super.range(from, to);\n    }\n}\nMarkDecoration.prototype.point = false;\nclass LineDecoration extends Decoration {\n    constructor(spec) {\n        super(-100000000 /* BigInline */, -100000000 /* BigInline */, null, spec);\n    }\n    eq(other) {\n        return other instanceof LineDecoration && attrsEq(this.spec.attributes, other.spec.attributes);\n    }\n    range(from, to = from) {\n        if (to != from)\n            throw new RangeError(\"Line decoration ranges must be zero-length\");\n        return super.range(from, to);\n    }\n}\nLineDecoration.prototype.mapMode = MapMode.TrackBefore;\nLineDecoration.prototype.point = true;\nclass PointDecoration extends Decoration {\n    constructor(spec, startSide, endSide, block, widget, isReplace) {\n        super(startSide, endSide, widget, spec);\n        this.block = block;\n        this.isReplace = isReplace;\n        this.mapMode = !block ? MapMode.TrackDel : startSide < 0 ? MapMode.TrackBefore : MapMode.TrackAfter;\n    }\n    // Only relevant when this.block == true\n    get type() {\n        return this.startSide < this.endSide ? BlockType.WidgetRange\n            : this.startSide < 0 ? BlockType.WidgetBefore : BlockType.WidgetAfter;\n    }\n    get heightRelevant() { return this.block || !!this.widget && this.widget.estimatedHeight >= 5; }\n    eq(other) {\n        return other instanceof PointDecoration &&\n            widgetsEq(this.widget, other.widget) &&\n            this.block == other.block &&\n            this.startSide == other.startSide && this.endSide == other.endSide;\n    }\n    range(from, to = from) {\n        if (this.isReplace && (from > to || (from == to && this.startSide > 0 && this.endSide < 0)))\n            throw new RangeError(\"Invalid range for replacement decoration\");\n        if (!this.isReplace && to != from)\n            throw new RangeError(\"Widget decorations can only have zero-length ranges\");\n        return super.range(from, to);\n    }\n}\nPointDecoration.prototype.point = true;\nfunction getInclusive(spec) {\n    let { inclusiveStart: start, inclusiveEnd: end } = spec;\n    if (start == null)\n        start = spec.inclusive;\n    if (end == null)\n        end = spec.inclusive;\n    return { start: start || false, end: end || false };\n}\nfunction widgetsEq(a, b) {\n    return a == b || !!(a && b && a.compare(b));\n}\nfunction addRange(from, to, ranges, margin = 0) {\n    let last = ranges.length - 1;\n    if (last >= 0 && ranges[last] + margin > from)\n        ranges[last] = Math.max(ranges[last], to);\n    else\n        ranges.push(from, to);\n}\n\nconst theme = Facet.define({ combine: strs => strs.join(\" \") });\nconst darkTheme = Facet.define({ combine: values => values.indexOf(true) > -1 });\nconst baseThemeID = StyleModule.newName();\nfunction expandThemeClasses(sel) {\n    return sel.replace(/\\$\\w[\\w\\.]*/g, cls => {\n        let parts = cls.slice(1).split(\".\"), result = \"\";\n        for (let i = 1; i <= parts.length; i++)\n            result += \".cm-\" + parts.slice(0, i).join(\"-\");\n        return result;\n    });\n}\nfunction buildTheme(main, spec) {\n    return new StyleModule(spec, {\n        process(sel) {\n            sel = expandThemeClasses(sel);\n            return /\\$/.test(sel) ? sel.replace(/\\$/, main) : main + \" \" + sel;\n        },\n        extend(template, sel) {\n            template = expandThemeClasses(template);\n            return sel.slice(0, main.length + 1) == main + \" \"\n                ? main + \" \" + template.replace(/&/, sel.slice(main.length + 1))\n                : template.replace(/&/, sel);\n        }\n    });\n}\n/// Create a set of CSS class names for the given theme class, which\n/// can be added to a DOM element within an editor to make themes able\n/// to style it. Theme classes can be single words or words separated\n/// by dot characters. In the latter case, the returned classes\n/// combine those that match the full name and those that match some\n/// prefix—for example `\"panel.search\"` will match both the theme\n/// styles specified as `\"panel.search\"` and those with just\n/// `\"panel\"`. More specific theme classes (with more dots) take\n/// precedence over less specific ones.\nfunction themeClass(selector) {\n    if (selector.indexOf(\".\") < 0)\n        return \"cm-\" + selector;\n    let parts = selector.split(\".\"), result = \"\";\n    for (let i = 1; i <= parts.length; i++)\n        result += (result ? \" \" : \"\") + \"cm-\" + parts.slice(0, i).join(\"-\");\n    return result;\n}\nconst baseTheme = buildTheme(\".\" + baseThemeID, {\n    $: {\n        position: \"relative !important\",\n        boxSizing: \"border-box\",\n        \"&$focused\": {\n            // FIXME it would be great if we could directly use the browser's\n            // default focus outline, but it appears we can't, so this tries to\n            // approximate that\n            outline_fallback: \"1px dotted #212121\",\n            outline: \"5px auto -webkit-focus-ring-color\"\n        },\n        display: \"flex !important\",\n        flexDirection: \"column\"\n    },\n    $scroller: {\n        display: \"flex !important\",\n        alignItems: \"flex-start !important\",\n        fontFamily: \"monospace\",\n        lineHeight: 1.4,\n        height: \"100%\",\n        overflowX: \"auto\",\n        position: \"relative\",\n        zIndex: 0\n    },\n    $content: {\n        margin: 0,\n        flexGrow: 2,\n        minHeight: \"100%\",\n        display: \"block\",\n        whiteSpace: \"pre\",\n        boxSizing: \"border-box\",\n        padding: \"4px 0\",\n        outline: \"none\"\n    },\n    \"$$light $content\": { caretColor: \"black\" },\n    \"$$dark $content\": { caretColor: \"white\" },\n    $line: {\n        display: \"block\",\n        padding: \"0 2px 0 4px\"\n    },\n    $selectionLayer: {\n        zIndex: -1,\n        contain: \"size style\"\n    },\n    $selectionBackground: {\n        position: \"absolute\",\n    },\n    \"$$light $selectionBackground\": {\n        background: \"#d9d9d9\"\n    },\n    \"$$dark $selectionBackground\": {\n        background: \"#222\"\n    },\n    \"$$focused$light $selectionBackground\": {\n        background: \"#d7d4f0\"\n    },\n    \"$$focused$dark $selectionBackground\": {\n        background: \"#233\"\n    },\n    $cursorLayer: {\n        zIndex: 100,\n        contain: \"size style\",\n        pointerEvents: \"none\"\n    },\n    \"$$focused $cursorLayer\": {\n        animation: \"steps(1) cm-blink 1.2s infinite\"\n    },\n    // Two animations defined so that we can switch between them to\n    // restart the animation without forcing another style\n    // recomputation.\n    \"@keyframes cm-blink\": { \"0%\": {}, \"50%\": { visibility: \"hidden\" }, \"100%\": {} },\n    \"@keyframes cm-blink2\": { \"0%\": {}, \"50%\": { visibility: \"hidden\" }, \"100%\": {} },\n    $cursor: {\n        position: \"absolute\",\n        borderLeft: \"1.2px solid black\",\n        marginLeft: \"-0.6px\",\n        pointerEvents: \"none\",\n        display: \"none\"\n    },\n    \"$$dark $cursor\": {\n        borderLeftColor: \"#444\"\n    },\n    \"$$focused $cursor\": {\n        display: \"block\"\n    },\n    \"$$light $activeLine\": { backgroundColor: \"#f3f9ff\" },\n    \"$$dark $activeLine\": { backgroundColor: \"#223039\" },\n    $placeholder: {\n        color: \"#888\",\n        display: \"inline-block\"\n    },\n    $button: {\n        verticalAlign: \"middle\",\n        color: \"inherit\",\n        fontSize: \"70%\",\n        padding: \".2em 1em\",\n        borderRadius: \"3px\"\n    },\n    \"$$light $button\": {\n        backgroundImage: \"linear-gradient(#eff1f5, #d9d9df)\",\n        border: \"1px solid #888\",\n        \"&:active\": {\n            backgroundImage: \"linear-gradient(#b4b4b4, #d0d3d6)\"\n        }\n    },\n    \"$$dark $button\": {\n        backgroundImage: \"linear-gradient(#555, #111)\",\n        border: \"1px solid #888\",\n        \"&:active\": {\n            backgroundImage: \"linear-gradient(#111, #333)\"\n        }\n    },\n    $textfield: {\n        verticalAlign: \"middle\",\n        color: \"inherit\",\n        fontSize: \"70%\",\n        border: \"1px solid silver\",\n        padding: \".2em .5em\"\n    },\n    \"$$light $textfield\": {\n        backgroundColor: \"white\"\n    },\n    \"$$dark $textfield\": {\n        border: \"1px solid #555\",\n        backgroundColor: \"inherit\"\n    }\n});\n\nconst LineClass = themeClass(\"line\");\nclass LineView extends ContentView {\n    constructor() {\n        super(...arguments);\n        this.children = [];\n        this.length = 0;\n        this.prevAttrs = undefined;\n        this.attrs = null;\n        this.breakAfter = 0;\n    }\n    // Consumes source\n    merge(from, to, source, takeDeco, openStart, openEnd) {\n        if (source) {\n            if (!(source instanceof LineView))\n                return false;\n            if (!this.dom)\n                source.transferDOM(this); // Reuse source.dom when appropriate\n        }\n        if (takeDeco)\n            this.setDeco(source ? source.attrs : null);\n        mergeInlineChildren(this, from, to, source ? source.children : none$2, openStart, openEnd);\n        return true;\n    }\n    split(at) {\n        let end = new LineView;\n        end.breakAfter = this.breakAfter;\n        if (this.length == 0)\n            return end;\n        let { i, off } = this.childPos(at);\n        if (off) {\n            end.append(this.children[i].slice(off), 0);\n            this.children[i].merge(off, this.children[i].length, null, 0, 0);\n            i++;\n        }\n        for (let j = i; j < this.children.length; j++)\n            end.append(this.children[j], 0);\n        while (i > 0 && this.children[i - 1].length == 0) {\n            this.children[i - 1].parent = null;\n            i--;\n        }\n        this.children.length = i;\n        this.markDirty();\n        this.length = at;\n        return end;\n    }\n    transferDOM(other) {\n        if (!this.dom)\n            return;\n        other.setDOM(this.dom);\n        other.prevAttrs = this.prevAttrs === undefined ? this.attrs : this.prevAttrs;\n        this.prevAttrs = undefined;\n        this.dom = null;\n    }\n    setDeco(attrs) {\n        if (!attrsEq(this.attrs, attrs)) {\n            if (this.dom) {\n                this.prevAttrs = this.attrs;\n                this.markDirty();\n            }\n            this.attrs = attrs;\n        }\n    }\n    // Only called when building a line view in ContentBuilder\n    append(child, openStart) {\n        joinInlineInto(this, child, openStart);\n    }\n    // Only called when building a line view in ContentBuilder\n    addLineDeco(deco) {\n        let attrs = deco.spec.attributes;\n        if (attrs)\n            this.attrs = combineAttrs(attrs, this.attrs || {});\n    }\n    domAtPos(pos) {\n        return inlineDOMAtPos(this.dom, this.children, pos);\n    }\n    sync(track) {\n        if (!this.dom) {\n            this.setDOM(document.createElement(\"div\"));\n            this.dom.className = LineClass;\n            this.prevAttrs = this.attrs ? null : undefined;\n        }\n        if (this.prevAttrs !== undefined) {\n            updateAttrs(this.dom, this.prevAttrs, this.attrs);\n            this.dom.classList.add(LineClass);\n            this.prevAttrs = undefined;\n        }\n        super.sync(track);\n        let last = this.dom.lastChild;\n        if (!last || (last.nodeName != \"BR\" && (ContentView.get(last) instanceof WidgetView))) {\n            let hack = document.createElement(\"BR\");\n            hack.cmIgnore = true;\n            this.dom.appendChild(hack);\n        }\n    }\n    measureTextSize() {\n        if (this.children.length == 0 || this.length > 20)\n            return null;\n        let totalWidth = 0;\n        for (let child of this.children) {\n            if (!(child instanceof TextView))\n                return null;\n            let rects = clientRectsFor(child.dom);\n            if (rects.length != 1)\n                return null;\n            totalWidth += rects[0].width;\n        }\n        return { lineHeight: this.dom.getBoundingClientRect().height, charWidth: totalWidth / this.length };\n    }\n    coordsAt(pos, side) {\n        return coordsInChildren(this, pos, side);\n    }\n    match(_other) { return false; }\n    get type() { return BlockType.Text; }\n    static find(docView, pos) {\n        for (let i = 0, off = 0;; i++) {\n            let block = docView.children[i], end = off + block.length;\n            if (end >= pos) {\n                if (block instanceof LineView)\n                    return block;\n                if (block.length)\n                    return null;\n            }\n            off = end + block.breakAfter;\n        }\n    }\n}\nconst none$2 = [];\nclass BlockWidgetView extends ContentView {\n    constructor(widget, length, type) {\n        super();\n        this.widget = widget;\n        this.length = length;\n        this.type = type;\n        this.breakAfter = 0;\n    }\n    merge(from, to, source, _takeDeco, openStart, openEnd) {\n        if (source && (!(source instanceof BlockWidgetView) || !this.widget.compare(source.widget) ||\n            from > 0 && openStart <= 0 || to < this.length && openEnd <= 0))\n            return false;\n        this.length = from + (source ? source.length : 0) + (this.length - to);\n        return true;\n    }\n    domAtPos(pos) {\n        return pos == 0 ? DOMPos.before(this.dom) : DOMPos.after(this.dom, pos == this.length);\n    }\n    split(at) {\n        let len = this.length - at;\n        this.length = at;\n        return new BlockWidgetView(this.widget, len, this.type);\n    }\n    get children() { return none$2; }\n    sync() {\n        if (!this.dom || !this.widget.updateDOM(this.dom)) {\n            this.setDOM(this.widget.toDOM(this.editorView));\n            this.dom.contentEditable = \"false\";\n        }\n    }\n    get overrideDOMText() {\n        return this.parent ? this.parent.view.state.doc.slice(this.posAtStart, this.posAtEnd) : Text$1.empty;\n    }\n    domBoundsAround() { return null; }\n    match(other) {\n        if (other instanceof BlockWidgetView && other.type == this.type &&\n            other.widget.constructor == this.widget.constructor) {\n            if (!other.widget.eq(this.widget))\n                this.markDirty(true);\n            this.widget = other.widget;\n            this.length = other.length;\n            this.breakAfter = other.breakAfter;\n            return true;\n        }\n        return false;\n    }\n    ignoreMutation() { return true; }\n    ignoreEvent(event) { return this.widget.ignoreEvent(event); }\n}\n\nclass ContentBuilder {\n    constructor(doc, pos, end) {\n        this.doc = doc;\n        this.pos = pos;\n        this.end = end;\n        this.content = [];\n        this.curLine = null;\n        this.breakAtStart = 0;\n        this.openStart = -1;\n        this.openEnd = -1;\n        this.text = \"\";\n        this.textOff = 0;\n        this.cursor = doc.iter();\n        this.skip = pos;\n    }\n    posCovered() {\n        if (this.content.length == 0)\n            return !this.breakAtStart && this.doc.lineAt(this.pos).from != this.pos;\n        let last = this.content[this.content.length - 1];\n        return !last.breakAfter && !(last instanceof BlockWidgetView && last.type == BlockType.WidgetBefore);\n    }\n    getLine() {\n        if (!this.curLine)\n            this.content.push(this.curLine = new LineView);\n        return this.curLine;\n    }\n    addWidget(view) {\n        this.curLine = null;\n        this.content.push(view);\n    }\n    finish() {\n        if (!this.posCovered())\n            this.getLine();\n    }\n    wrapMarks(view, active) {\n        for (let i = active.length - 1; i >= 0; i--)\n            view = new MarkView(active[i], [view], view.length);\n        return view;\n    }\n    buildText(length, active, openStart) {\n        while (length > 0) {\n            if (this.textOff == this.text.length) {\n                let { value, lineBreak, done } = this.cursor.next(this.skip);\n                this.skip = 0;\n                if (done)\n                    throw new Error(\"Ran out of text content when drawing inline views\");\n                if (lineBreak) {\n                    if (!this.posCovered())\n                        this.getLine();\n                    if (this.content.length)\n                        this.content[this.content.length - 1].breakAfter = 1;\n                    else\n                        this.breakAtStart = 1;\n                    this.curLine = null;\n                    length--;\n                    continue;\n                }\n                else {\n                    this.text = value;\n                    this.textOff = 0;\n                }\n            }\n            let take = Math.min(this.text.length - this.textOff, length, 512 /* Chunk */);\n            this.getLine().append(this.wrapMarks(new TextView(this.text.slice(this.textOff, this.textOff + take)), active), openStart);\n            this.textOff += take;\n            length -= take;\n            openStart = 0;\n        }\n    }\n    span(from, to, active, openStart) {\n        this.buildText(to - from, active, openStart);\n        this.pos = to;\n        if (this.openStart < 0)\n            this.openStart = openStart;\n    }\n    point(from, to, deco, active, openStart) {\n        let len = to - from;\n        if (deco instanceof PointDecoration) {\n            if (deco.block) {\n                let { type } = deco;\n                if (type == BlockType.WidgetAfter && !this.posCovered())\n                    this.getLine();\n                this.addWidget(new BlockWidgetView(deco.widget || new NullWidget(\"div\"), len, type));\n            }\n            else {\n                let widget = this.wrapMarks(WidgetView.create(deco.widget || new NullWidget(\"span\"), len, deco.startSide), active);\n                this.getLine().append(widget, openStart);\n            }\n        }\n        else if (this.doc.lineAt(this.pos).from == this.pos) { // Line decoration\n            this.getLine().addLineDeco(deco);\n        }\n        if (len) {\n            // Advance the iterator past the replaced content\n            if (this.textOff + len <= this.text.length) {\n                this.textOff += len;\n            }\n            else {\n                this.skip += len - (this.text.length - this.textOff);\n                this.text = \"\";\n                this.textOff = 0;\n            }\n            this.pos = to;\n        }\n        if (this.openStart < 0)\n            this.openStart = openStart;\n    }\n    static build(text, from, to, decorations) {\n        let builder = new ContentBuilder(text, from, to);\n        builder.openEnd = RangeSet.spans(decorations, from, to, builder);\n        if (builder.openStart < 0)\n            builder.openStart = builder.openEnd;\n        builder.finish();\n        return builder;\n    }\n}\nclass NullWidget extends WidgetType {\n    constructor(tag) {\n        super();\n        this.tag = tag;\n    }\n    eq(other) { return other.tag == this.tag; }\n    toDOM() { return document.createElement(this.tag); }\n    updateDOM(elt) { return elt.nodeName.toLowerCase() == this.tag; }\n}\n\n/// Used to indicate [text direction](#view.EditorView.textDirection).\nvar Direction;\n(function (Direction) {\n    // (These are chosen to match the base levels, in bidi algorithm\n    // terms, of spans in that direction.)\n    /// Left-to-right.\n    Direction[Direction[\"LTR\"] = 0] = \"LTR\";\n    /// Right-to-left.\n    Direction[Direction[\"RTL\"] = 1] = \"RTL\";\n})(Direction || (Direction = {}));\nconst LTR = Direction.LTR, RTL = Direction.RTL;\n// Decode a string with each type encoded as log2(type)\nfunction dec(str) {\n    let result = [];\n    for (let i = 0; i < str.length; i++)\n        result.push(1 << +str[i]);\n    return result;\n}\n// Character types for codepoints 0 to 0xf8\nconst LowTypes = dec(\"88888888888888888888888888888888888666888888787833333333337888888000000000000000000000000008888880000000000000000000000000088888888888888888888888888888888888887866668888088888663380888308888800000000000000000000000800000000000000000000000000000008\");\n// Character types for codepoints 0x600 to 0x6f9\nconst ArabicTypes = dec(\"4444448826627288999999999992222222222222222222222222222222222222222222222229999999999999999999994444444444644222822222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222999999949999999229989999223333333333\");\nfunction charType(ch) {\n    return ch <= 0xf7 ? LowTypes[ch] :\n        0x590 <= ch && ch <= 0x5f4 ? 2 /* R */ :\n            0x600 <= ch && ch <= 0x6f9 ? ArabicTypes[ch - 0x600] :\n                0x6ee <= ch && ch <= 0x8ac ? 4 /* AL */ :\n                    0x2000 <= ch && ch <= 0x200b ? 256 /* NI */ :\n                        ch == 0x200c ? 256 /* NI */ : 1 /* L */;\n}\nconst BidiRE = /[\\u0590-\\u05f4\\u0600-\\u06ff\\u0700-\\u08ac]/;\n/// Represents a contiguous range of text that has a single direction\n/// (as in left-to-right or right-to-left).\nclass BidiSpan {\n    /// @internal\n    constructor(\n    /// The start of the span (relative to the start of the line).\n    from, \n    /// The end of the span.\n    to, \n    /// The [\"bidi\n    /// level\"](https://unicode.org/reports/tr9/#Basic_Display_Algorithm)\n    /// of the span (in this context, 0 means\n    /// left-to-right, 1 means right-to-left, 2 means left-to-right\n    /// number inside right-to-left text).\n    level) {\n        this.from = from;\n        this.to = to;\n        this.level = level;\n    }\n    /// The direction of this span.\n    get dir() { return this.level % 2 ? RTL : LTR; }\n    /// @internal\n    side(end, dir) { return (this.dir == dir) == end ? this.to : this.from; }\n    /// @internal\n    static find(order, index, level, assoc) {\n        let maybe = -1;\n        for (let i = 0; i < order.length; i++) {\n            let span = order[i];\n            if (span.from <= index && span.to >= index) {\n                if (span.level == level)\n                    return i;\n                // When multiple spans match, if assoc != 0, take the one that\n                // covers that side, otherwise take the one with the minimum\n                // level.\n                if (maybe < 0 || (assoc != 0 ? (assoc < 0 ? span.from < index : span.to > index) : order[maybe].level > span.level))\n                    maybe = i;\n            }\n        }\n        if (maybe < 0)\n            throw new RangeError(\"Index out of range\");\n        return maybe;\n    }\n}\n// Reused array of character types\nconst types = [];\nfunction computeOrder(line, direction) {\n    let len = line.length, outerType = direction == LTR ? 1 /* L */ : 2 /* R */;\n    if (!line || outerType == 1 /* L */ && !BidiRE.test(line))\n        return trivialOrder(len);\n    // W1. Examine each non-spacing mark (NSM) in the level run, and\n    // change the type of the NSM to the type of the previous\n    // character. If the NSM is at the start of the level run, it will\n    // get the type of sor.\n    // W2. Search backwards from each instance of a European number\n    // until the first strong type (R, L, AL, or sor) is found. If an\n    // AL is found, change the type of the European number to Arabic\n    // number.\n    // W3. Change all ALs to R.\n    // (Left after this: L, R, EN, AN, ET, CS, NI)\n    for (let i = 0, prev = outerType, prevStrong = outerType; i < len; i++) {\n        let type = charType(line.charCodeAt(i));\n        if (type == 512 /* NSM */)\n            type = prev;\n        else if (type == 8 /* EN */ && prevStrong == 4 /* AL */)\n            type = 16 /* AN */;\n        types[i] = type == 4 /* AL */ ? 2 /* R */ : type;\n        if (type & 7 /* Strong */)\n            prevStrong = type;\n        prev = type;\n    }\n    // W5. A sequence of European terminators adjacent to European\n    // numbers changes to all European numbers.\n    // W6. Otherwise, separators and terminators change to Other\n    // Neutral.\n    // W7. Search backwards from each instance of a European number\n    // until the first strong type (R, L, or sor) is found. If an L is\n    // found, then change the type of the European number to L.\n    // (Left after this: L, R, EN+AN, NI)\n    for (let i = 0, prev = outerType, prevStrong = outerType; i < len; i++) {\n        let type = types[i];\n        if (type == 128 /* CS */) {\n            if (i < len - 1 && prev == types[i + 1] && (prev & 24 /* Num */))\n                type = types[i] = prev;\n            else\n                types[i] = 256 /* NI */;\n        }\n        else if (type == 64 /* ET */) {\n            let end = i + 1;\n            while (end < len && types[end] == 64 /* ET */)\n                end++;\n            let replace = (i && prev == 8 /* EN */) || (end < len && types[end] == 8 /* EN */) ? (prevStrong == 1 /* L */ ? 1 /* L */ : 8 /* EN */) : 256 /* NI */;\n            for (let j = i; j < end; j++)\n                types[j] = replace;\n            i = end - 1;\n        }\n        else if (type == 8 /* EN */ && prevStrong == 1 /* L */) {\n            types[i] = 1 /* L */;\n        }\n        prev = type;\n        if (type & 7 /* Strong */)\n            prevStrong = type;\n    }\n    // N1. A sequence of neutrals takes the direction of the\n    // surrounding strong text if the text on both sides has the same\n    // direction. European and Arabic numbers act as if they were R in\n    // terms of their influence on neutrals. Start-of-level-run (sor)\n    // and end-of-level-run (eor) are used at level run boundaries.\n    // N2. Any remaining neutrals take the embedding direction.\n    // (Left after this: L, R, EN+AN)\n    for (let i = 0; i < len; i++) {\n        if (types[i] == 256 /* NI */) {\n            let end = i + 1;\n            while (end < len && types[end] == 256 /* NI */)\n                end++;\n            let beforeL = (i ? types[i - 1] : outerType) == 1 /* L */;\n            let afterL = (end < len ? types[end] : outerType) == 1 /* L */;\n            let replace = beforeL == afterL ? (beforeL ? 1 /* L */ : 2 /* R */) : outerType;\n            for (let j = i; j < end; j++)\n                types[j] = replace;\n            i = end - 1;\n        }\n    }\n    // Here we depart from the documented algorithm, in order to avoid\n    // building up an actual levels array. Since there are only three\n    // levels (0, 1, 2) in an implementation that doesn't take\n    // explicit embedding into account, we can build up the order on\n    // the fly, without following the level-based algorithm.\n    let order = [];\n    if (outerType == 1 /* L */) {\n        for (let i = 0; i < len;) {\n            let start = i, rtl = types[i++] != 1 /* L */;\n            while (i < len && rtl == (types[i] != 1 /* L */))\n                i++;\n            if (rtl) {\n                for (let j = i; j > start;) {\n                    let end = j, l = types[--j] != 2 /* R */;\n                    while (j > start && l == (types[j - 1] != 2 /* R */))\n                        j--;\n                    order.push(new BidiSpan(j, end, l ? 2 : 1));\n                }\n            }\n            else {\n                order.push(new BidiSpan(start, i, 0));\n            }\n        }\n    }\n    else {\n        for (let i = 0; i < len;) {\n            let start = i, rtl = types[i++] == 2 /* R */;\n            while (i < len && rtl == (types[i] == 2 /* R */))\n                i++;\n            order.push(new BidiSpan(start, i, rtl ? 1 : 2));\n        }\n    }\n    return order;\n}\nfunction trivialOrder(length) {\n    return [new BidiSpan(0, length, 0)];\n}\nlet movedOver = \"\";\nfunction moveVisually(line, order, dir, start, forward) {\n    var _a;\n    let startIndex = start.head - line.from, spanI = -1;\n    if (startIndex == 0) {\n        if (!forward || !line.length)\n            return null;\n        if (order[0].level != dir) {\n            startIndex = order[0].side(false, dir);\n            spanI = 0;\n        }\n    }\n    else if (startIndex == line.length) {\n        if (forward)\n            return null;\n        let last = order[order.length - 1];\n        if (last.level != dir) {\n            startIndex = last.side(true, dir);\n            spanI = order.length - 1;\n        }\n    }\n    if (spanI < 0)\n        spanI = BidiSpan.find(order, startIndex, (_a = start.bidiLevel) !== null && _a !== void 0 ? _a : -1, start.assoc);\n    let span = order[spanI];\n    // End of span. (But not end of line--that was checked for above.)\n    if (startIndex == span.side(forward, dir)) {\n        span = order[spanI += forward ? 1 : -1];\n        startIndex = span.side(!forward, dir);\n    }\n    let indexForward = forward == (span.dir == dir);\n    let nextIndex = findClusterBreak(line.text, startIndex, indexForward);\n    movedOver = line.text.slice(Math.min(startIndex, nextIndex), Math.max(startIndex, nextIndex));\n    if (nextIndex != span.side(forward, dir))\n        return EditorSelection.cursor(nextIndex + line.from, indexForward ? -1 : 1, span.level);\n    let nextSpan = spanI == (forward ? order.length - 1 : 0) ? null : order[spanI + (forward ? 1 : -1)];\n    if (!nextSpan && span.level != dir)\n        return EditorSelection.cursor(forward ? line.to : line.from, forward ? -1 : 1, dir);\n    if (nextSpan && nextSpan.level < span.level)\n        return EditorSelection.cursor(nextSpan.side(!forward, dir) + line.from, 0, nextSpan.level);\n    return EditorSelection.cursor(nextIndex + line.from, 0, span.level);\n}\n\nconst wrappingWhiteSpace = [\"pre-wrap\", \"normal\", \"pre-line\"];\nclass HeightOracle {\n    constructor() {\n        this.doc = Text.empty;\n        this.lineWrapping = false;\n        this.direction = Direction.LTR;\n        this.heightSamples = {};\n        this.lineHeight = 14;\n        this.charWidth = 7;\n        this.lineLength = 30;\n        // Used to track, during updateHeight, if any actual heights changed\n        this.heightChanged = false;\n    }\n    heightForGap(from, to) {\n        let lines = this.doc.lineAt(to).number - this.doc.lineAt(from).number + 1;\n        if (this.lineWrapping)\n            lines += Math.ceil(((to - from) - (lines * this.lineLength * 0.5)) / this.lineLength);\n        return this.lineHeight * lines;\n    }\n    heightForLine(length) {\n        if (!this.lineWrapping)\n            return this.lineHeight;\n        let lines = 1 + Math.max(0, Math.ceil((length - this.lineLength) / (this.lineLength - 5)));\n        return lines * this.lineHeight;\n    }\n    setDoc(doc) { this.doc = doc; return this; }\n    mustRefresh(lineHeights, whiteSpace, direction) {\n        let newHeight = false;\n        for (let i = 0; i < lineHeights.length; i++) {\n            let h = lineHeights[i];\n            if (h < 0) {\n                i++;\n            }\n            else if (!this.heightSamples[Math.floor(h * 10)]) { // Round to .1 pixels\n                newHeight = true;\n                this.heightSamples[Math.floor(h * 10)] = true;\n            }\n        }\n        return newHeight || (wrappingWhiteSpace.indexOf(whiteSpace) > -1) != this.lineWrapping || this.direction != direction;\n    }\n    refresh(whiteSpace, direction, lineHeight, charWidth, lineLength, knownHeights) {\n        let lineWrapping = wrappingWhiteSpace.indexOf(whiteSpace) > -1;\n        let changed = Math.round(lineHeight) != Math.round(this.lineHeight) ||\n            this.lineWrapping != lineWrapping ||\n            this.direction != direction;\n        this.lineWrapping = lineWrapping;\n        this.direction = direction;\n        this.lineHeight = lineHeight;\n        this.charWidth = charWidth;\n        this.lineLength = lineLength;\n        if (changed) {\n            this.heightSamples = {};\n            for (let i = 0; i < knownHeights.length; i++) {\n                let h = knownHeights[i];\n                if (h < 0)\n                    i++;\n                else\n                    this.heightSamples[Math.floor(h * 10)] = true;\n            }\n        }\n        return changed;\n    }\n}\n// This object is used by `updateHeight` to make DOM measurements\n// arrive at the right nides. The `heights` array is a sequence of\n// block heights, starting from position `from`.\nclass MeasuredHeights {\n    constructor(from, heights) {\n        this.from = from;\n        this.heights = heights;\n        this.index = 0;\n    }\n    get more() { return this.index < this.heights.length; }\n}\n/// Record used to represent information about a block-level element\n/// in the editor view.\nclass BlockInfo {\n    /// @internal\n    constructor(\n    /// The start of the element in the document.\n    from, \n    /// The length of the element.\n    length, \n    /// The top position of the element.\n    top, \n    /// Its height.\n    height, \n    /// The type of element this is. When querying lines, this may be\n    /// an array of all the blocks that make up the line.\n    type) {\n        this.from = from;\n        this.length = length;\n        this.top = top;\n        this.height = height;\n        this.type = type;\n    }\n    /// The end of the element as a document position.\n    get to() { return this.from + this.length; }\n    /// The bottom position of the element.\n    get bottom() { return this.top + this.height; }\n    /// @internal\n    join(other) {\n        let detail = (Array.isArray(this.type) ? this.type : [this])\n            .concat(Array.isArray(other.type) ? other.type : [other]);\n        return new BlockInfo(this.from, this.length + other.length, this.top, this.height + other.height, detail);\n    }\n}\nvar QueryType;\n(function (QueryType) {\n    QueryType[QueryType[\"ByPos\"] = 0] = \"ByPos\";\n    QueryType[QueryType[\"ByHeight\"] = 1] = \"ByHeight\";\n    QueryType[QueryType[\"ByPosNoHeight\"] = 2] = \"ByPosNoHeight\";\n})(QueryType || (QueryType = {}));\nconst Epsilon = 1e-4;\nclass HeightMap {\n    constructor(length, // The number of characters covered\n    height, // Height of this part of the document\n    flags = 2 /* Outdated */) {\n        this.length = length;\n        this.height = height;\n        this.flags = flags;\n    }\n    get outdated() { return (this.flags & 2 /* Outdated */) > 0; }\n    set outdated(value) { this.flags = (value ? 2 /* Outdated */ : 0) | (this.flags & ~2 /* Outdated */); }\n    setHeight(oracle, height) {\n        if (this.height != height) {\n            if (Math.abs(this.height - height) > Epsilon)\n                oracle.heightChanged = true;\n            this.height = height;\n        }\n    }\n    // Base case is to replace a leaf node, which simply builds a tree\n    // from the new nodes and returns that (HeightMapBranch and\n    // HeightMapGap override this to actually use from/to)\n    replace(_from, _to, nodes) {\n        return HeightMap.of(nodes);\n    }\n    // Again, these are base cases, and are overridden for branch and gap nodes.\n    decomposeLeft(_to, result) { result.push(this); }\n    decomposeRight(_from, result) { result.push(this); }\n    applyChanges(decorations, oldDoc, oracle, changes) {\n        let me = this;\n        for (let i = changes.length - 1; i >= 0; i--) {\n            let { fromA, toA, fromB, toB } = changes[i];\n            let start = me.lineAt(fromA, QueryType.ByPosNoHeight, oldDoc, 0, 0);\n            let end = start.to >= toA ? start : me.lineAt(toA, QueryType.ByPosNoHeight, oldDoc, 0, 0);\n            toB += end.to - toA;\n            toA = end.to;\n            while (i > 0 && start.from <= changes[i - 1].toA) {\n                fromA = changes[i - 1].fromA;\n                fromB = changes[i - 1].fromB;\n                i--;\n                if (fromA < start.from)\n                    start = me.lineAt(fromA, QueryType.ByPosNoHeight, oldDoc, 0, 0);\n            }\n            fromB += start.from - fromA;\n            fromA = start.from;\n            let nodes = NodeBuilder.build(oracle, decorations, fromB, toB);\n            me = me.replace(fromA, toA, nodes);\n        }\n        return me.updateHeight(oracle, 0);\n    }\n    static empty() { return new HeightMapText(0, 0); }\n    // nodes uses null values to indicate the position of line breaks.\n    // There are never line breaks at the start or end of the array, or\n    // two line breaks next to each other, and the array isn't allowed\n    // to be empty (same restrictions as return value from the builder).\n    static of(nodes) {\n        if (nodes.length == 1)\n            return nodes[0];\n        let i = 0, j = nodes.length, before = 0, after = 0;\n        for (;;) {\n            if (i == j) {\n                if (before > after * 2) {\n                    let split = nodes[i - 1];\n                    if (split.break)\n                        nodes.splice(--i, 1, split.left, null, split.right);\n                    else\n                        nodes.splice(--i, 1, split.left, split.right);\n                    j += 1 + split.break;\n                    before -= split.size;\n                }\n                else if (after > before * 2) {\n                    let split = nodes[j];\n                    if (split.break)\n                        nodes.splice(j, 1, split.left, null, split.right);\n                    else\n                        nodes.splice(j, 1, split.left, split.right);\n                    j += 2 + split.break;\n                    after -= split.size;\n                }\n                else {\n                    break;\n                }\n            }\n            else if (before < after) {\n                let next = nodes[i++];\n                if (next)\n                    before += next.size;\n            }\n            else {\n                let next = nodes[--j];\n                if (next)\n                    after += next.size;\n            }\n        }\n        let brk = 0;\n        if (nodes[i - 1] == null) {\n            brk = 1;\n            i--;\n        }\n        else if (nodes[i] == null) {\n            brk = 1;\n            j++;\n        }\n        return new HeightMapBranch(HeightMap.of(nodes.slice(0, i)), brk, HeightMap.of(nodes.slice(j)));\n    }\n}\nHeightMap.prototype.size = 1;\nclass HeightMapBlock extends HeightMap {\n    constructor(length, height, type) {\n        super(length, height);\n        this.type = type;\n    }\n    blockAt(_height, _doc, top, offset) {\n        return new BlockInfo(offset, this.length, top, this.height, this.type);\n    }\n    lineAt(_value, _type, doc, top, offset) {\n        return this.blockAt(0, doc, top, offset);\n    }\n    forEachLine(_from, _to, doc, top, offset, f) {\n        f(this.blockAt(0, doc, top, offset));\n    }\n    updateHeight(oracle, offset = 0, _force = false, measured) {\n        if (measured && measured.from <= offset && measured.more)\n            this.setHeight(oracle, measured.heights[measured.index++]);\n        this.outdated = false;\n        return this;\n    }\n    toString() { return `block(${this.length})`; }\n}\nclass HeightMapText extends HeightMapBlock {\n    constructor(length, height) {\n        super(length, height, BlockType.Text);\n        this.collapsed = 0; // Amount of collapsed content in the line\n        this.widgetHeight = 0; // Maximum inline widget height\n    }\n    replace(_from, _to, nodes) {\n        let node = nodes[0];\n        if (nodes.length == 1 && (node instanceof HeightMapText || node instanceof HeightMapGap && (node.flags & 4 /* SingleLine */)) &&\n            Math.abs(this.length - node.length) < 10) {\n            if (node instanceof HeightMapGap)\n                node = new HeightMapText(node.length, this.height);\n            else\n                node.height = this.height;\n            if (!this.outdated)\n                node.outdated = false;\n            return node;\n        }\n        else {\n            return HeightMap.of(nodes);\n        }\n    }\n    updateHeight(oracle, offset = 0, force = false, measured) {\n        if (measured && measured.from <= offset && measured.more)\n            this.setHeight(oracle, measured.heights[measured.index++]);\n        else if (force || this.outdated)\n            this.setHeight(oracle, Math.max(this.widgetHeight, oracle.heightForLine(this.length - this.collapsed)));\n        this.outdated = false;\n        return this;\n    }\n    toString() {\n        return `line(${this.length}${this.collapsed ? -this.collapsed : \"\"}${this.widgetHeight ? \":\" + this.widgetHeight : \"\"})`;\n    }\n}\nclass HeightMapGap extends HeightMap {\n    constructor(length) { super(length, 0); }\n    lines(doc, offset) {\n        let firstLine = doc.lineAt(offset).number, lastLine = doc.lineAt(offset + this.length).number;\n        return { firstLine, lastLine, lineHeight: this.height / (lastLine - firstLine + 1) };\n    }\n    blockAt(height, doc, top, offset) {\n        let { firstLine, lastLine, lineHeight } = this.lines(doc, offset);\n        let line = Math.max(0, Math.min(lastLine - firstLine, Math.floor((height - top) / lineHeight)));\n        let { from, length } = doc.line(firstLine + line);\n        return new BlockInfo(from, length, top + lineHeight * line, lineHeight, BlockType.Text);\n    }\n    lineAt(value, type, doc, top, offset) {\n        if (type == QueryType.ByHeight)\n            return this.blockAt(value, doc, top, offset);\n        if (type == QueryType.ByPosNoHeight) {\n            let { from, to } = doc.lineAt(value);\n            return new BlockInfo(from, to - from, 0, 0, BlockType.Text);\n        }\n        let { firstLine, lineHeight } = this.lines(doc, offset);\n        let { from, length, number } = doc.lineAt(value);\n        return new BlockInfo(from, length, top + lineHeight * (number - firstLine), lineHeight, BlockType.Text);\n    }\n    forEachLine(from, to, doc, top, offset, f) {\n        let { firstLine, lineHeight } = this.lines(doc, offset);\n        for (let pos = Math.max(from, offset), end = Math.min(offset + this.length, to); pos <= end;) {\n            let line = doc.lineAt(pos);\n            if (pos == from)\n                top += lineHeight * (line.number - firstLine);\n            f(new BlockInfo(line.from, line.length, top, top += lineHeight, BlockType.Text));\n            pos = line.to + 1;\n        }\n    }\n    replace(from, to, nodes) {\n        let after = this.length - to;\n        if (after > 0) {\n            let last = nodes[nodes.length - 1];\n            if (last instanceof HeightMapGap)\n                nodes[nodes.length - 1] = new HeightMapGap(last.length + after);\n            else\n                nodes.push(null, new HeightMapGap(after - 1));\n        }\n        if (from > 0) {\n            let first = nodes[0];\n            if (first instanceof HeightMapGap)\n                nodes[0] = new HeightMapGap(from + first.length);\n            else\n                nodes.unshift(new HeightMapGap(from - 1), null);\n        }\n        return HeightMap.of(nodes);\n    }\n    decomposeLeft(to, result) {\n        result.push(new HeightMapGap(to - 1), null);\n    }\n    decomposeRight(from, result) {\n        result.push(null, new HeightMapGap(this.length - from - 1));\n    }\n    updateHeight(oracle, offset = 0, force = false, measured) {\n        let end = offset + this.length;\n        if (measured && measured.from <= offset + this.length && measured.more) {\n            // Fill in part of this gap with measured lines. We know there\n            // can't be widgets or collapsed ranges in those lines, because\n            // they would already have been added to the heightmap (gaps\n            // only contain plain text).\n            let nodes = [], pos = Math.max(offset, measured.from);\n            if (measured.from > offset)\n                nodes.push(new HeightMapGap(measured.from - offset - 1).updateHeight(oracle, offset));\n            while (pos <= end && measured.more) {\n                let len = oracle.doc.lineAt(pos).length;\n                if (nodes.length)\n                    nodes.push(null);\n                let line = new HeightMapText(len, measured.heights[measured.index++]);\n                line.outdated = false;\n                nodes.push(line);\n                pos += len + 1;\n            }\n            if (pos <= end)\n                nodes.push(null, new HeightMapGap(end - pos).updateHeight(oracle, pos));\n            oracle.heightChanged = true;\n            return HeightMap.of(nodes);\n        }\n        else if (force || this.outdated) {\n            this.setHeight(oracle, oracle.heightForGap(offset, offset + this.length));\n            this.outdated = false;\n        }\n        return this;\n    }\n    toString() { return `gap(${this.length})`; }\n}\nclass HeightMapBranch extends HeightMap {\n    constructor(left, brk, right) {\n        super(left.length + brk + right.length, left.height + right.height, brk | (left.outdated || right.outdated ? 2 /* Outdated */ : 0));\n        this.left = left;\n        this.right = right;\n        this.size = left.size + right.size;\n    }\n    get break() { return this.flags & 1 /* Break */; }\n    blockAt(height, doc, top, offset) {\n        let mid = top + this.left.height;\n        return height < mid || this.right.height == 0 ? this.left.blockAt(height, doc, top, offset)\n            : this.right.blockAt(height, doc, mid, offset + this.left.length + this.break);\n    }\n    lineAt(value, type, doc, top, offset) {\n        let rightTop = top + this.left.height, rightOffset = offset + this.left.length + this.break;\n        let left = type == QueryType.ByHeight ? value < rightTop || this.right.height == 0 : value < rightOffset;\n        let base = left ? this.left.lineAt(value, type, doc, top, offset)\n            : this.right.lineAt(value, type, doc, rightTop, rightOffset);\n        if (this.break || (left ? base.to < rightOffset : base.from > rightOffset))\n            return base;\n        let subQuery = type == QueryType.ByPosNoHeight ? QueryType.ByPosNoHeight : QueryType.ByPos;\n        if (left)\n            return base.join(this.right.lineAt(rightOffset, subQuery, doc, rightTop, rightOffset));\n        else\n            return this.left.lineAt(rightOffset, subQuery, doc, top, offset).join(base);\n    }\n    forEachLine(from, to, doc, top, offset, f) {\n        let rightTop = top + this.left.height, rightOffset = offset + this.left.length + this.break;\n        if (this.break) {\n            if (from < rightOffset)\n                this.left.forEachLine(from, to, doc, top, offset, f);\n            if (to >= rightOffset)\n                this.right.forEachLine(from, to, doc, rightTop, rightOffset, f);\n        }\n        else {\n            let mid = this.lineAt(rightOffset, QueryType.ByPos, doc, top, offset);\n            if (from < mid.from)\n                this.left.forEachLine(from, mid.from - 1, doc, top, offset, f);\n            if (mid.to >= from && mid.from <= to)\n                f(mid);\n            if (to > mid.to)\n                this.right.forEachLine(mid.to + 1, to, doc, rightTop, rightOffset, f);\n        }\n    }\n    replace(from, to, nodes) {\n        let rightStart = this.left.length + this.break;\n        if (to < rightStart)\n            return this.balanced(this.left.replace(from, to, nodes), this.right);\n        if (from > this.left.length)\n            return this.balanced(this.left, this.right.replace(from - rightStart, to - rightStart, nodes));\n        let result = [];\n        if (from > 0)\n            this.decomposeLeft(from, result);\n        let left = result.length;\n        for (let node of nodes)\n            result.push(node);\n        if (from > 0)\n            mergeGaps(result, left - 1);\n        if (to < this.length) {\n            let right = result.length;\n            this.decomposeRight(to, result);\n            mergeGaps(result, right);\n        }\n        return HeightMap.of(result);\n    }\n    decomposeLeft(to, result) {\n        let left = this.left.length;\n        if (to <= left)\n            return this.left.decomposeLeft(to, result);\n        result.push(this.left);\n        if (this.break) {\n            left++;\n            if (to >= left)\n                result.push(null);\n        }\n        if (to > left)\n            this.right.decomposeLeft(to - left, result);\n    }\n    decomposeRight(from, result) {\n        let left = this.left.length, right = left + this.break;\n        if (from >= right)\n            return this.right.decomposeRight(from - right, result);\n        if (from < left)\n            this.left.decomposeRight(from, result);\n        if (this.break && from < right)\n            result.push(null);\n        result.push(this.right);\n    }\n    balanced(left, right) {\n        if (left.size > 2 * right.size || right.size > 2 * left.size)\n            return HeightMap.of(this.break ? [left, null, right] : [left, right]);\n        this.left = left;\n        this.right = right;\n        this.height = left.height + right.height;\n        this.outdated = left.outdated || right.outdated;\n        this.size = left.size + right.size;\n        this.length = left.length + this.break + right.length;\n        return this;\n    }\n    updateHeight(oracle, offset = 0, force = false, measured) {\n        let { left, right } = this, rightStart = offset + left.length + this.break, rebalance = null;\n        if (measured && measured.from <= offset + left.length && measured.more)\n            rebalance = left = left.updateHeight(oracle, offset, force, measured);\n        else\n            left.updateHeight(oracle, offset, force);\n        if (measured && measured.from <= rightStart + right.length && measured.more)\n            rebalance = right = right.updateHeight(oracle, rightStart, force, measured);\n        else\n            right.updateHeight(oracle, rightStart, force);\n        if (rebalance)\n            return this.balanced(left, right);\n        this.height = this.left.height + this.right.height;\n        this.outdated = false;\n        return this;\n    }\n    toString() { return this.left + (this.break ? \" \" : \"-\") + this.right; }\n}\nfunction mergeGaps(nodes, around) {\n    let before, after;\n    if (nodes[around] == null &&\n        (before = nodes[around - 1]) instanceof HeightMapGap &&\n        (after = nodes[around + 1]) instanceof HeightMapGap)\n        nodes.splice(around - 1, 3, new HeightMapGap(before.length + 1 + after.length));\n}\nconst relevantWidgetHeight = 5;\nclass NodeBuilder {\n    constructor(pos, oracle) {\n        this.pos = pos;\n        this.oracle = oracle;\n        this.nodes = [];\n        this.lineStart = -1;\n        this.lineEnd = -1;\n        this.covering = null;\n        this.writtenTo = pos;\n    }\n    get isCovered() {\n        return this.covering && this.nodes[this.nodes.length - 1] == this.covering;\n    }\n    span(_from, to) {\n        if (this.lineStart > -1) {\n            let end = Math.min(to, this.lineEnd), last = this.nodes[this.nodes.length - 1];\n            if (last instanceof HeightMapText)\n                last.length += end - this.pos;\n            else if (end > this.pos || !this.isCovered)\n                this.nodes.push(new HeightMapText(end - this.pos, -1));\n            this.writtenTo = end;\n            if (to > end) {\n                this.nodes.push(null);\n                this.writtenTo++;\n                this.lineStart = -1;\n            }\n        }\n        this.pos = to;\n    }\n    point(from, to, deco) {\n        if (from < to || deco.heightRelevant) {\n            let height = deco.widget ? Math.max(0, deco.widget.estimatedHeight) : 0;\n            let len = to - from;\n            if (deco.block) {\n                this.addBlock(new HeightMapBlock(len, height, deco.type));\n            }\n            else if (len || height >= relevantWidgetHeight) {\n                this.addLineDeco(height, len);\n            }\n        }\n        else if (to > from) {\n            this.span(from, to);\n        }\n        if (this.lineEnd > -1 && this.lineEnd < this.pos)\n            this.lineEnd = this.oracle.doc.lineAt(this.pos).to;\n    }\n    enterLine() {\n        if (this.lineStart > -1)\n            return;\n        let { from, to } = this.oracle.doc.lineAt(this.pos);\n        this.lineStart = from;\n        this.lineEnd = to;\n        if (this.writtenTo < from) {\n            if (this.writtenTo < from - 1 || this.nodes[this.nodes.length - 1] == null)\n                this.nodes.push(this.blankContent(this.writtenTo, from - 1));\n            this.nodes.push(null);\n        }\n        if (this.pos > from)\n            this.nodes.push(new HeightMapText(this.pos - from, -1));\n        this.writtenTo = this.pos;\n    }\n    blankContent(from, to) {\n        let gap = new HeightMapGap(to - from);\n        if (this.oracle.doc.lineAt(from).to == to)\n            gap.flags |= 4 /* SingleLine */;\n        return gap;\n    }\n    ensureLine() {\n        this.enterLine();\n        let last = this.nodes.length ? this.nodes[this.nodes.length - 1] : null;\n        if (last instanceof HeightMapText)\n            return last;\n        let line = new HeightMapText(0, -1);\n        this.nodes.push(line);\n        return line;\n    }\n    addBlock(block) {\n        this.enterLine();\n        if (block.type == BlockType.WidgetAfter && !this.isCovered)\n            this.ensureLine();\n        this.nodes.push(block);\n        this.writtenTo = this.pos = this.pos + block.length;\n        if (block.type != BlockType.WidgetBefore)\n            this.covering = block;\n    }\n    addLineDeco(height, length) {\n        let line = this.ensureLine();\n        line.length += length;\n        line.collapsed += length;\n        line.widgetHeight = Math.max(line.widgetHeight, height);\n        this.writtenTo = this.pos = this.pos + length;\n    }\n    finish(from) {\n        let last = this.nodes.length == 0 ? null : this.nodes[this.nodes.length - 1];\n        if (this.lineStart > -1 && !(last instanceof HeightMapText) && !this.isCovered)\n            this.nodes.push(new HeightMapText(0, -1));\n        else if (this.writtenTo < this.pos || last == null)\n            this.nodes.push(this.blankContent(this.writtenTo, this.pos));\n        let pos = from;\n        for (let node of this.nodes) {\n            if (node instanceof HeightMapText)\n                node.updateHeight(this.oracle, pos);\n            pos += node ? node.length : 1;\n        }\n        return this.nodes;\n    }\n    // Always called with a region that on both sides either stretches\n    // to a line break or the end of the document.\n    // The returned array uses null to indicate line breaks, but never\n    // starts or ends in a line break, or has multiple line breaks next\n    // to each other.\n    static build(oracle, decorations, from, to) {\n        let builder = new NodeBuilder(from, oracle);\n        RangeSet.spans(decorations, from, to, builder, 0);\n        return builder.finish(from);\n    }\n}\nfunction heightRelevantDecoChanges(a, b, diff) {\n    let comp = new DecorationComparator;\n    RangeSet.compare(a, b, diff, comp, 0);\n    return comp.changes;\n}\nclass DecorationComparator {\n    constructor() {\n        this.changes = [];\n    }\n    compareRange() { }\n    comparePoint(from, to, a, b) {\n        if (from < to || a && a.heightRelevant || b && b.heightRelevant)\n            addRange(from, to, this.changes, 5);\n    }\n}\n\nconst none$3 = [];\nconst clickAddsSelectionRange = Facet.define();\nconst dragMovesSelection = Facet.define();\nconst mouseSelectionStyle = Facet.define();\nconst exceptionSink = Facet.define();\nconst updateListener = Facet.define();\nconst inputHandler = Facet.define();\n/// Log or report an unhandled exception in client code. Should\n/// probably only be used by extension code that allows client code to\n/// provide functions, and calls those functions in a context where an\n/// exception can't be propagated to calling code in a reasonable way\n/// (for example when in an event handler).\n///\n/// Either calls a handler registered with\n/// [`EditorView.exceptionSink`](#view.EditorView^exceptionSink),\n/// `window.onerror`, if defined, or `console.error` (in which case\n/// it'll pass `context`, when given, as first argument).\nfunction logException(state, exception, context) {\n    let handler = state.facet(exceptionSink);\n    if (handler.length)\n        handler[0](exception);\n    else if (window.onerror)\n        window.onerror(String(exception), context, undefined, undefined, exception);\n    else if (context)\n        console.error(context + \":\", exception);\n    else\n        console.error(exception);\n}\nconst editable = Facet.define({ combine: values => values.length ? values[0] : true });\n/// Used to [declare](#view.PluginSpec.provide) which\n/// [fields](#view.PluginValue) a [view plugin](#view.ViewPlugin)\n/// provides.\nclass PluginFieldProvider {\n    /// @internal\n    constructor(\n    /// @internal\n    field, \n    /// @internal\n    get) {\n        this.field = field;\n        this.get = get;\n    }\n}\n/// Plugin fields are a mechanism for allowing plugins to provide\n/// values that can be retrieved through the\n/// [`pluginField`](#view.EditorView.pluginField) view method.\nclass PluginField {\n    /// Create a [provider](#view.PluginFieldProvider) for this field,\n    /// to use with a plugin's [provide](#view.PluginSpec.provide)\n    /// option.\n    from(get) {\n        return new PluginFieldProvider(this, get);\n    }\n    /// Define a new plugin field.\n    static define() { return new PluginField(); }\n}\n/// This field can be used by plugins to provide\n/// [decorations](#view.Decoration).\n// FIXME somehow ensure that no replacing decorations end up in here\nPluginField.decorations = PluginField.define();\n/// Plugins can provide additional scroll margins (space around the\n/// sides of the scrolling element that should be considered\n/// invisible) through this field. This can be useful when the\n/// plugin introduces elements that cover part of that element (for\n/// example a horizontally fixed gutter).\nPluginField.scrollMargins = PluginField.define();\nlet nextPluginID = 0;\nconst viewPlugin = Facet.define();\n/// View plugins associate stateful values with a view. They can\n/// influence the way the content is drawn, and are notified of things\n/// that happen in the view.\nclass ViewPlugin {\n    constructor(\n    /// @internal\n    id, \n    /// @internal\n    create, \n    /// @internal\n    fields) {\n        this.id = id;\n        this.create = create;\n        this.fields = fields;\n        this.extension = viewPlugin.of(this);\n    }\n    /// Define a plugin from a constructor function that creates the\n    /// plugin's value, given an editor view.\n    static define(create, spec) {\n        let { eventHandlers, provide, decorations } = spec || {};\n        let fields = [];\n        if (provide)\n            for (let provider of Array.isArray(provide) ? provide : [provide])\n                fields.push(provider);\n        if (eventHandlers)\n            fields.push(domEventHandlers.from((value) => ({ plugin: value, handlers: eventHandlers })));\n        if (decorations)\n            fields.push(PluginField.decorations.from(decorations));\n        return new ViewPlugin(nextPluginID++, create, fields);\n    }\n    /// Create a plugin for a class whose constructor takes a single\n    /// editor view as argument.\n    static fromClass(cls, spec) {\n        return ViewPlugin.define(view => new cls(view), spec);\n    }\n}\nconst domEventHandlers = PluginField.define();\nclass PluginInstance {\n    constructor(spec) {\n        this.spec = spec;\n        // When starting an update, all plugins have this field set to the\n        // update object, indicating they need to be updated. When finished\n        // updating, it is set to `false`. Retrieving a plugin that needs to\n        // be updated with `view.plugin` forces an eager update.\n        this.mustUpdate = null;\n        // This is null when the plugin is initially created, but\n        // initialized on the first update.\n        this.value = null;\n    }\n    takeField(type, target) {\n        for (let { field, get } of this.spec.fields)\n            if (field == type)\n                target.push(get(this.value));\n    }\n    update(view) {\n        if (!this.value) {\n            try {\n                this.value = this.spec.create(view);\n            }\n            catch (e) {\n                logException(view.state, e, \"CodeMirror plugin crashed\");\n                return PluginInstance.dummy;\n            }\n        }\n        else if (this.mustUpdate) {\n            let update = this.mustUpdate;\n            this.mustUpdate = null;\n            if (!this.value.update)\n                return this;\n            try {\n                this.value.update(update);\n            }\n            catch (e) {\n                logException(update.state, e, \"CodeMirror plugin crashed\");\n                if (this.value.destroy)\n                    try {\n                        this.value.destroy();\n                    }\n                    catch (_) { }\n                return PluginInstance.dummy;\n            }\n        }\n        return this;\n    }\n    destroy(view) {\n        var _a;\n        if ((_a = this.value) === null || _a === void 0 ? void 0 : _a.destroy) {\n            try {\n                this.value.destroy();\n            }\n            catch (e) {\n                logException(view.state, e, \"CodeMirror plugin crashed\");\n            }\n        }\n    }\n}\nPluginInstance.dummy = new PluginInstance(ViewPlugin.define(() => ({})));\nconst editorAttributes = Facet.define({\n    combine: values => values.reduce((a, b) => combineAttrs(b, a), {})\n});\nconst contentAttributes = Facet.define({\n    combine: values => values.reduce((a, b) => combineAttrs(b, a), {})\n});\n// Provide decorations\nconst decorations = Facet.define();\nconst styleModule = Facet.define();\nclass ChangedRange {\n    constructor(fromA, toA, fromB, toB) {\n        this.fromA = fromA;\n        this.toA = toA;\n        this.fromB = fromB;\n        this.toB = toB;\n    }\n    join(other) {\n        return new ChangedRange(Math.min(this.fromA, other.fromA), Math.max(this.toA, other.toA), Math.min(this.fromB, other.fromB), Math.max(this.toB, other.toB));\n    }\n    addToSet(set) {\n        let i = set.length, me = this;\n        for (; i > 0; i--) {\n            let range = set[i - 1];\n            if (range.fromA > me.toA)\n                continue;\n            if (range.toA < me.fromA)\n                break;\n            me = me.join(range);\n            set.splice(i - 1, 1);\n        }\n        set.splice(i, 0, me);\n        return set;\n    }\n    static extendWithRanges(diff, ranges) {\n        if (ranges.length == 0)\n            return diff;\n        let result = [];\n        for (let dI = 0, rI = 0, posA = 0, posB = 0;; dI++) {\n            let next = dI == diff.length ? null : diff[dI], off = posA - posB;\n            let end = next ? next.fromB : 1e9;\n            while (rI < ranges.length && ranges[rI] < end) {\n                let from = ranges[rI], to = ranges[rI + 1];\n                let fromB = Math.max(posB, from), toB = Math.min(end, to);\n                if (fromB <= toB)\n                    new ChangedRange(fromB + off, toB + off, fromB, toB).addToSet(result);\n                if (to > end)\n                    break;\n                else\n                    rI += 2;\n            }\n            if (!next)\n                return result;\n            new ChangedRange(next.fromA, next.toA, next.fromB, next.toB).addToSet(result);\n            posA = next.toA;\n            posB = next.toB;\n        }\n    }\n}\n/// View [plugins](#view.ViewPlugin) are given instances of this\n/// class, which describe what happened, whenever the view is updated.\nclass ViewUpdate {\n    /// @internal\n    constructor(\n    /// The editor view that the update is associated with.\n    view, \n    /// The new editor state.\n    state, \n    /// The transactions involved in the update. May be empty.\n    transactions = none$3) {\n        this.view = view;\n        this.state = state;\n        this.transactions = transactions;\n        /// @internal\n        this.flags = 0;\n        this.startState = view.state;\n        this.changes = ChangeSet.empty(this.startState.doc.length);\n        for (let tr of transactions)\n            this.changes = this.changes.compose(tr.changes);\n        let changedRanges = [];\n        this.changes.iterChangedRanges((fromA, toA, fromB, toB) => changedRanges.push(new ChangedRange(fromA, toA, fromB, toB)));\n        this.changedRanges = changedRanges;\n        let focus = view.hasFocus;\n        if (focus != view.inputState.notifiedFocused) {\n            view.inputState.notifiedFocused = focus;\n            this.flags != 1 /* Focus */;\n        }\n        if (this.docChanged)\n            this.flags |= 2 /* Height */;\n    }\n    /// Tells you whether the viewport changed in this update.\n    get viewportChanged() {\n        return (this.flags & 4 /* Viewport */) > 0;\n    }\n    /// Indicates whether the line height in the editor changed in this update.\n    get heightChanged() {\n        return (this.flags & 2 /* Height */) > 0;\n    }\n    /// Returns true when the document changed or the size of the editor\n    /// or the lines or characters within it has changed.\n    get geometryChanged() {\n        return this.docChanged || (this.flags & (16 /* Geometry */ | 2 /* Height */)) > 0;\n    }\n    /// True when this update indicates a focus change.\n    get focusChanged() {\n        return (this.flags & 1 /* Focus */) > 0;\n    }\n    /// Whether the document changed in this update.\n    get docChanged() {\n        return this.transactions.some(tr => tr.docChanged);\n    }\n    /// Whether the selection was explicitly set in this update.\n    get selectionSet() {\n        return this.transactions.some(tr => tr.selection);\n    }\n    /// @internal\n    get empty() { return this.flags == 0 && this.transactions.length == 0; }\n}\n\nfunction visiblePixelRange(dom, paddingTop) {\n    let rect = dom.getBoundingClientRect();\n    let left = Math.max(0, rect.left), right = Math.min(innerWidth, rect.right);\n    let top = Math.max(0, rect.top), bottom = Math.min(innerHeight, rect.bottom);\n    for (let parent = dom.parentNode; parent;) { // (Cast to any because TypeScript is useless with Node types)\n        if (parent.nodeType == 1) {\n            if ((parent.scrollHeight > parent.clientHeight || parent.scrollWidth > parent.clientWidth) &&\n                window.getComputedStyle(parent).overflow != \"visible\") {\n                let parentRect = parent.getBoundingClientRect();\n                left = Math.max(left, parentRect.left);\n                right = Math.min(right, parentRect.right);\n                top = Math.max(top, parentRect.top);\n                bottom = Math.min(bottom, parentRect.bottom);\n            }\n            parent = parent.parentNode;\n        }\n        else if (parent.nodeType == 11) { // Shadow root\n            parent = parent.host;\n        }\n        else {\n            break;\n        }\n    }\n    return { left: left - rect.left, right: right - rect.left,\n        top: top - (rect.top + paddingTop), bottom: bottom - (rect.top + paddingTop) };\n}\n// Line gaps are placeholder widgets used to hide pieces of overlong\n// lines within the viewport, as a kludge to keep the editor\n// responsive when a ridiculously long line is loaded into it.\nclass LineGap {\n    constructor(from, to, size) {\n        this.from = from;\n        this.to = to;\n        this.size = size;\n    }\n    static same(a, b) {\n        if (a.length != b.length)\n            return false;\n        for (let i = 0; i < a.length; i++) {\n            let gA = a[i], gB = b[i];\n            if (gA.from != gB.from || gA.to != gB.to || gA.size != gB.size)\n                return false;\n        }\n        return true;\n    }\n    draw(wrapping) {\n        return Decoration.replace({ widget: new LineGapWidget(this.size, wrapping) }).range(this.from, this.to);\n    }\n}\nclass LineGapWidget extends WidgetType {\n    constructor(size, vertical) {\n        super();\n        this.size = size;\n        this.vertical = vertical;\n    }\n    eq(other) { return other.size == this.size && other.vertical == this.vertical; }\n    toDOM() {\n        let elt = document.createElement(\"div\");\n        if (this.vertical) {\n            elt.style.height = this.size + \"px\";\n        }\n        else {\n            elt.style.width = this.size + \"px\";\n            elt.style.height = \"2px\";\n            elt.style.display = \"inline-block\";\n        }\n        return elt;\n    }\n    get estimatedHeight() { return this.vertical ? this.size : -1; }\n}\nclass ViewState {\n    constructor(state) {\n        this.state = state;\n        // These are contentDOM-local coordinates\n        this.pixelViewport = { left: 0, right: window.innerWidth, top: 0, bottom: 0 };\n        this.inView = true;\n        this.paddingTop = 0;\n        this.paddingBottom = 0;\n        this.contentWidth = 0;\n        this.heightOracle = new HeightOracle;\n        this.heightMap = HeightMap.empty();\n        this.scrollTo = null;\n        // Briefly set to true when printing, to disable viewport limiting\n        this.printing = false;\n        this.visibleRanges = [];\n        // Cursor 'assoc' is only significant when the cursor is on a line\n        // wrap point, where it must stick to the character that it is\n        // associated with. Since browsers don't provide a reasonable\n        // interface to set or query this, when a selection is set that\n        // might cause this to be signficant, this flag is set. The next\n        // measure phase will check whether the cursor is on a line-wrapping\n        // boundary and, if so, reset it to make sure it is positioned in\n        // the right place.\n        this.mustEnforceCursorAssoc = false;\n        this.heightMap = this.heightMap.applyChanges(state.facet(decorations), Text.empty, this.heightOracle.setDoc(state.doc), [new ChangedRange(0, 0, 0, state.doc.length)]);\n        this.viewport = this.getViewport(0, null);\n        this.lineGaps = this.ensureLineGaps([]);\n        this.lineGapDeco = Decoration.set(this.lineGaps.map(gap => gap.draw(false)));\n        this.computeVisibleRanges();\n    }\n    update(update, scrollTo = null) {\n        let prev = this.state;\n        this.state = update.state;\n        let newDeco = this.state.facet(decorations);\n        let contentChanges = update.changedRanges;\n        let heightChanges = ChangedRange.extendWithRanges(contentChanges, heightRelevantDecoChanges(update.startState.facet(decorations), newDeco, update ? update.changes : ChangeSet.empty(this.state.doc.length)));\n        let prevHeight = this.heightMap.height;\n        this.heightMap = this.heightMap.applyChanges(newDeco, prev.doc, this.heightOracle.setDoc(this.state.doc), heightChanges);\n        if (this.heightMap.height != prevHeight)\n            update.flags |= 2 /* Height */;\n        let viewport = heightChanges.length ? this.mapViewport(this.viewport, update.changes) : this.viewport;\n        if (scrollTo && (scrollTo.head < viewport.from || scrollTo.head > viewport.to) || !this.viewportIsAppropriate(viewport))\n            viewport = this.getViewport(0, scrollTo);\n        if (!viewport.eq(this.viewport)) {\n            this.viewport = viewport;\n            update.flags |= 4 /* Viewport */;\n        }\n        if (this.lineGaps.length || this.viewport.to - this.viewport.from > 15000 /* MinViewPort */)\n            update.flags |= this.updateLineGaps(this.ensureLineGaps(this.mapLineGaps(this.lineGaps, update.changes)));\n        this.computeVisibleRanges();\n        if (scrollTo)\n            this.scrollTo = scrollTo;\n        if (!this.mustEnforceCursorAssoc && update.selectionSet && update.view.lineWrapping &&\n            update.state.selection.main.empty && update.state.selection.main.assoc)\n            this.mustEnforceCursorAssoc = true;\n    }\n    measure(docView, repeated) {\n        let dom = docView.dom, whiteSpace = \"\", direction = Direction.LTR;\n        if (!repeated) {\n            // Vertical padding\n            let style = window.getComputedStyle(dom);\n            whiteSpace = style.whiteSpace, direction = (style.direction == \"rtl\" ? Direction.RTL : Direction.LTR);\n            this.paddingTop = parseInt(style.paddingTop) || 0;\n            this.paddingBottom = parseInt(style.paddingBottom) || 0;\n        }\n        // Pixel viewport\n        let pixelViewport = this.printing ? { top: -1e8, bottom: 1e8, left: -1e8, right: 1e8 } : visiblePixelRange(dom, this.paddingTop);\n        let dTop = pixelViewport.top - this.pixelViewport.top, dBottom = pixelViewport.bottom - this.pixelViewport.bottom;\n        this.pixelViewport = pixelViewport;\n        this.inView = this.pixelViewport.bottom > this.pixelViewport.top && this.pixelViewport.right > this.pixelViewport.left;\n        if (!this.inView)\n            return 0;\n        let lineHeights = docView.measureVisibleLineHeights();\n        let refresh = false, bias = 0, result = 0, oracle = this.heightOracle;\n        if (!repeated) {\n            let contentWidth = docView.dom.clientWidth;\n            if (oracle.mustRefresh(lineHeights, whiteSpace, direction) ||\n                oracle.lineWrapping && Math.abs(contentWidth - this.contentWidth) > oracle.charWidth) {\n                let { lineHeight, charWidth } = docView.measureTextSize();\n                refresh = oracle.refresh(whiteSpace, direction, lineHeight, charWidth, contentWidth / charWidth, lineHeights);\n                if (refresh) {\n                    docView.minWidth = 0;\n                    result |= 16 /* Geometry */;\n                }\n            }\n            if (this.contentWidth != contentWidth) {\n                this.contentWidth = contentWidth;\n                result |= 16 /* Geometry */;\n            }\n            if (dTop > 0 && dBottom > 0)\n                bias = Math.max(dTop, dBottom);\n            else if (dTop < 0 && dBottom < 0)\n                bias = Math.min(dTop, dBottom);\n        }\n        oracle.heightChanged = false;\n        this.heightMap = this.heightMap.updateHeight(oracle, 0, refresh, new MeasuredHeights(this.viewport.from, lineHeights));\n        if (oracle.heightChanged)\n            result |= 2 /* Height */;\n        if (!this.viewportIsAppropriate(this.viewport, bias) ||\n            this.scrollTo && (this.scrollTo.head < this.viewport.from || this.scrollTo.head > this.viewport.to)) {\n            let newVP = this.getViewport(bias, this.scrollTo);\n            if (newVP.from != this.viewport.from || newVP.to != this.viewport.to) {\n                this.viewport = newVP;\n                result |= 4 /* Viewport */;\n            }\n        }\n        if (this.lineGaps.length || this.viewport.to - this.viewport.from > 15000 /* MinViewPort */)\n            result |= this.updateLineGaps(this.ensureLineGaps(refresh ? [] : this.lineGaps));\n        this.computeVisibleRanges();\n        if (this.mustEnforceCursorAssoc) {\n            this.mustEnforceCursorAssoc = false;\n            // This is done in the read stage, because moving the selection\n            // to a line end is going to trigger a layout anyway, so it\n            // can't be a pure write. It should be rare that it does any\n            // writing.\n            docView.enforceCursorAssoc();\n        }\n        return result;\n    }\n    getViewport(bias, scrollTo) {\n        // This will divide VP.Margin between the top and the\n        // bottom, depending on the bias (the change in viewport position\n        // since the last update). It'll hold a number between 0 and 1\n        let marginTop = 0.5 - Math.max(-0.5, Math.min(0.5, bias / 1000 /* Margin */ / 2));\n        let map = this.heightMap, doc = this.state.doc, { top, bottom } = this.pixelViewport;\n        let viewport = new Viewport(map.lineAt(top - marginTop * 1000 /* Margin */, QueryType.ByHeight, doc, 0, 0).from, map.lineAt(bottom + (1 - marginTop) * 1000 /* Margin */, QueryType.ByHeight, doc, 0, 0).to);\n        // If scrollTo is given, make sure the viewport includes that position\n        if (scrollTo) {\n            if (scrollTo.head < viewport.from) {\n                let { top: newTop } = map.lineAt(scrollTo.head, QueryType.ByPos, doc, 0, 0);\n                viewport = new Viewport(map.lineAt(newTop - 1000 /* Margin */ / 2, QueryType.ByHeight, doc, 0, 0).from, map.lineAt(newTop + (bottom - top) + 1000 /* Margin */ / 2, QueryType.ByHeight, doc, 0, 0).to);\n            }\n            else if (scrollTo.head > viewport.to) {\n                let { bottom: newBottom } = map.lineAt(scrollTo.head, QueryType.ByPos, doc, 0, 0);\n                viewport = new Viewport(map.lineAt(newBottom - (bottom - top) - 1000 /* Margin */ / 2, QueryType.ByHeight, doc, 0, 0).from, map.lineAt(newBottom + 1000 /* Margin */ / 2, QueryType.ByHeight, doc, 0, 0).to);\n            }\n        }\n        return viewport;\n    }\n    mapViewport(viewport, changes) {\n        let from = changes.mapPos(viewport.from, -1), to = changes.mapPos(viewport.to, 1);\n        return new Viewport(this.heightMap.lineAt(from, QueryType.ByPos, this.state.doc, 0, 0).from, this.heightMap.lineAt(to, QueryType.ByPos, this.state.doc, 0, 0).to);\n    }\n    // Checks if a given viewport covers the visible part of the\n    // document and not too much beyond that.\n    viewportIsAppropriate({ from, to }, bias = 0) {\n        let { top } = this.heightMap.lineAt(from, QueryType.ByPos, this.state.doc, 0, 0);\n        let { bottom } = this.heightMap.lineAt(to, QueryType.ByPos, this.state.doc, 0, 0);\n        return (from == 0 || top <= this.pixelViewport.top - Math.max(10 /* MinCoverMargin */, Math.min(-bias, 250 /* MaxCoverMargin */))) &&\n            (to == this.state.doc.length ||\n                bottom >= this.pixelViewport.bottom + Math.max(10 /* MinCoverMargin */, Math.min(bias, 250 /* MaxCoverMargin */))) &&\n            (top > this.pixelViewport.top - 2 * 1000 /* Margin */ && bottom < this.pixelViewport.bottom + 2 * 1000 /* Margin */);\n    }\n    mapLineGaps(gaps, changes) {\n        if (!gaps.length || changes.empty)\n            return gaps;\n        let mapped = [];\n        for (let gap of gaps)\n            if (!changes.touchesRange(gap.from, gap.to))\n                mapped.push(new LineGap(changes.mapPos(gap.from), changes.mapPos(gap.to), gap.size));\n        return mapped;\n    }\n    // Computes positions in the viewport where the start or end of a\n    // line should be hidden, trying to reuse existing line gaps when\n    // appropriate to avoid unneccesary redraws.\n    // Uses crude character-counting for the positioning and sizing,\n    // since actual DOM coordinates aren't always available and\n    // predictable. Relies on generous margins (see LG.Margin) to hide\n    // the artifacts this might produce from the user.\n    ensureLineGaps(current) {\n        let gaps = [];\n        // This won't work at all in predominantly right-to-left text.\n        if (this.heightOracle.direction != Direction.LTR)\n            return gaps;\n        this.heightMap.forEachLine(this.viewport.from, this.viewport.to, this.state.doc, 0, 0, line => {\n            if (line.length < 10000 /* Margin */)\n                return;\n            let structure = lineStructure(line.from, line.to, this.state);\n            if (structure.total < 10000 /* Margin */)\n                return;\n            let viewFrom, viewTo;\n            if (this.heightOracle.lineWrapping) {\n                if (line.from != this.viewport.from)\n                    viewFrom = line.from;\n                else\n                    viewFrom = findPosition(structure, (this.pixelViewport.top - line.top) / line.height);\n                if (line.to != this.viewport.to)\n                    viewTo = line.to;\n                else\n                    viewTo = findPosition(structure, (this.pixelViewport.bottom - line.top) / line.height);\n            }\n            else {\n                let totalWidth = structure.total * this.heightOracle.charWidth;\n                viewFrom = findPosition(structure, this.pixelViewport.left / totalWidth);\n                viewTo = findPosition(structure, this.pixelViewport.right / totalWidth);\n            }\n            let sel = this.state.selection.main;\n            // Make sure the gap doesn't cover a selection end\n            if (sel.from <= viewFrom && sel.to >= line.from)\n                viewFrom = sel.from;\n            if (sel.from <= line.to && sel.to >= viewTo)\n                viewTo = sel.to;\n            let gapTo = viewFrom - 10000 /* Margin */, gapFrom = viewTo + 10000 /* Margin */;\n            if (gapTo > line.from + 5000 /* HalfMargin */)\n                gaps.push(find(current, gap => gap.from == line.from && gap.to > gapTo - 5000 /* HalfMargin */ && gap.to < gapTo + 5000 /* HalfMargin */) ||\n                    new LineGap(line.from, gapTo, this.gapSize(line, gapTo, true, structure)));\n            if (gapFrom < line.to - 5000 /* HalfMargin */)\n                gaps.push(find(current, gap => gap.to == line.to && gap.from > gapFrom - 5000 /* HalfMargin */ &&\n                    gap.from < gapFrom + 5000 /* HalfMargin */) ||\n                    new LineGap(gapFrom, line.to, this.gapSize(line, gapFrom, false, structure)));\n        });\n        return gaps;\n    }\n    gapSize(line, pos, start, structure) {\n        if (this.heightOracle.lineWrapping) {\n            let height = line.height * findFraction(structure, pos);\n            return start ? height : line.height - height;\n        }\n        else {\n            let ratio = findFraction(structure, pos);\n            return structure.total * this.heightOracle.charWidth * (start ? ratio : 1 - ratio);\n        }\n    }\n    updateLineGaps(gaps) {\n        if (!LineGap.same(gaps, this.lineGaps)) {\n            this.lineGaps = gaps;\n            this.lineGapDeco = Decoration.set(gaps.map(gap => gap.draw(this.heightOracle.lineWrapping)));\n            return 8 /* LineGaps */;\n        }\n        return 0;\n    }\n    computeVisibleRanges() {\n        let deco = this.state.facet(decorations);\n        if (this.lineGaps.length)\n            deco = deco.concat(this.lineGapDeco);\n        let ranges = [];\n        RangeSet.spans(deco, this.viewport.from, this.viewport.to, {\n            span(from, to) { ranges.push({ from, to }); },\n            point() { }\n        }, 20);\n        this.visibleRanges = ranges;\n    }\n    lineAt(pos, editorTop) {\n        return this.heightMap.lineAt(pos, QueryType.ByPos, this.state.doc, editorTop + this.paddingTop, 0);\n    }\n    lineAtHeight(height, editorTop) {\n        return this.heightMap.lineAt(height, QueryType.ByHeight, this.state.doc, editorTop + this.paddingTop, 0);\n    }\n    blockAtHeight(height, editorTop) {\n        return this.heightMap.blockAt(height, this.state.doc, editorTop + this.paddingTop, 0);\n    }\n    forEachLine(from, to, f, editorTop) {\n        return this.heightMap.forEachLine(from, to, this.state.doc, editorTop + this.paddingTop, 0, f);\n    }\n}\n/// Indicates the range of the document that is in the visible\n/// viewport.\nclass Viewport {\n    constructor(from, to) {\n        this.from = from;\n        this.to = to;\n    }\n    eq(b) { return this.from == b.from && this.to == b.to; }\n}\nfunction lineStructure(from, to, state) {\n    let ranges = [], pos = from, total = 0;\n    RangeSet.spans(state.facet(decorations), from, to, {\n        span() { },\n        point(from, to) {\n            if (from > pos) {\n                ranges.push({ from: pos, to: from });\n                total += from - pos;\n            }\n            pos = to;\n        }\n    }, 20); // We're only interested in collapsed ranges of a significant size\n    if (pos < to) {\n        ranges.push({ from: pos, to });\n        total += to - pos;\n    }\n    return { total, ranges };\n}\nfunction findPosition({ total, ranges }, ratio) {\n    if (ratio <= 0)\n        return ranges[0].from;\n    if (ratio >= 1)\n        return ranges[ranges.length - 1].to;\n    let dist = Math.floor(total * ratio);\n    for (let i = 0;; i++) {\n        let { from, to } = ranges[i], size = to - from;\n        if (dist <= size)\n            return from + dist;\n        dist -= size;\n    }\n}\nfunction findFraction(structure, pos) {\n    let counted = 0;\n    for (let { from, to } of structure.ranges) {\n        if (pos <= to) {\n            counted += pos - from;\n            break;\n        }\n        counted += to - from;\n    }\n    return counted / structure.total;\n}\nfunction find(array, f) {\n    for (let val of array)\n        if (f(val))\n            return val;\n    return undefined;\n}\n\nconst none$4 = [];\nclass DocView extends ContentView {\n    constructor(view) {\n        super();\n        this.view = view;\n        this.viewports = none$4;\n        this.compositionDeco = Decoration.none;\n        this.decorations = [];\n        // Track a minimum width for the editor. When measuring sizes in\n        // checkLayout, this is updated to point at the width of a given\n        // element and its extent in the document. When a change happens in\n        // that range, these are reset. That way, once we've seen a\n        // line/element of a given length, we keep the editor wide enough to\n        // fit at least that element, until it is changed, at which point we\n        // forget it again.\n        this.minWidth = 0;\n        this.minWidthFrom = 0;\n        this.minWidthTo = 0;\n        // Track whether the DOM selection was set in a lossy way, so that\n        // we don't mess it up when reading it back it\n        this.impreciseAnchor = null;\n        this.impreciseHead = null;\n        this.setDOM(view.contentDOM);\n        this.children = [new LineView];\n        this.children[0].setParent(this);\n        this.updateInner([new ChangedRange(0, 0, 0, view.state.doc.length)], this.updateDeco(), 0);\n    }\n    get root() { return this.view.root; }\n    get editorView() { return this.view; }\n    get length() { return this.view.state.doc.length; }\n    // Update the document view to a given state. scrollIntoView can be\n    // used as a hint to compute a new viewport that includes that\n    // position, if we know the editor is going to scroll that position\n    // into view.\n    update(update) {\n        var _a;\n        let changedRanges = update.changedRanges;\n        if (this.minWidth > 0 && changedRanges.length) {\n            if (!changedRanges.every(({ fromA, toA }) => toA < this.minWidthFrom || fromA > this.minWidthTo)) {\n                this.minWidth = 0;\n            }\n            else {\n                this.minWidthFrom = update.changes.mapPos(this.minWidthFrom, 1);\n                this.minWidthTo = update.changes.mapPos(this.minWidthTo, 1);\n            }\n        }\n        if (!((_a = this.view.inputState) === null || _a === void 0 ? void 0 : _a.composing))\n            this.compositionDeco = Decoration.none;\n        else if (update.transactions.length)\n            this.compositionDeco = computeCompositionDeco(this.view, update.changes);\n        // When the DOM nodes around the selection are moved to another\n        // parent, Chrome sometimes reports a different selection through\n        // getSelection than the one that it actually shows to the user.\n        // This forces a selection update when lines are joined to work\n        // around that. Issue #54\n        let forceSelection = (browser.ie || browser.chrome) && !this.compositionDeco.size && update &&\n            update.state.doc.lines != update.startState.doc.lines;\n        let prevDeco = this.decorations, deco = this.updateDeco();\n        let decoDiff = findChangedDeco(prevDeco, deco, update.changes);\n        changedRanges = ChangedRange.extendWithRanges(changedRanges, decoDiff);\n        let pointerSel = update.transactions.some(tr => tr.annotation(Transaction.userEvent) == \"pointerselection\");\n        if (this.dirty == 0 /* Not */ && changedRanges.length == 0 &&\n            !(update.flags & (4 /* Viewport */ | 8 /* LineGaps */)) &&\n            update.state.selection.main.from >= this.view.viewport.from &&\n            update.state.selection.main.to <= this.view.viewport.to) {\n            this.updateSelection(forceSelection, pointerSel);\n            return false;\n        }\n        else {\n            this.updateInner(changedRanges, deco, update.startState.doc.length, forceSelection, pointerSel);\n            return true;\n        }\n    }\n    // Used both by update and checkLayout do perform the actual DOM\n    // update\n    updateInner(changes, deco, oldLength, forceSelection = false, pointerSel = false) {\n        this.updateChildren(changes, deco, oldLength);\n        this.view.observer.ignore(() => {\n            // Lock the height during redrawing, since Chrome sometimes\n            // messes with the scroll position during DOM mutation (though\n            // no relayout is triggered and I cannot imagine how it can\n            // recompute the scroll position without a layout)\n            this.dom.style.height = this.view.viewState.heightMap.height + \"px\";\n            this.dom.style.minWidth = this.minWidth ? this.minWidth + \"px\" : \"\";\n            // Chrome will sometimes, when DOM mutations occur directly\n            // around the selection, get confused and report a different\n            // selection from the one it displays (issue #218). This tries\n            // to detect that situation.\n            let track = browser.chrome ? { node: getSelection(this.view.root).focusNode, written: false } : undefined;\n            this.sync(track);\n            this.dirty = 0 /* Not */;\n            if (track === null || track === void 0 ? void 0 : track.written)\n                forceSelection = true;\n            this.updateSelection(forceSelection, pointerSel);\n            this.dom.style.height = \"\";\n        });\n    }\n    updateChildren(changes, deco, oldLength) {\n        let cursor = this.childCursor(oldLength);\n        for (let i = changes.length - 1;; i--) {\n            let next = i >= 0 ? changes[i] : null;\n            if (!next)\n                break;\n            let { fromA, toA, fromB, toB } = next;\n            let { content, breakAtStart, openStart, openEnd } = ContentBuilder.build(this.view.state.doc, fromB, toB, deco);\n            let { i: toI, off: toOff } = cursor.findPos(toA, 1);\n            let { i: fromI, off: fromOff } = cursor.findPos(fromA, -1);\n            this.replaceRange(fromI, fromOff, toI, toOff, content, breakAtStart, openStart, openEnd);\n        }\n    }\n    replaceRange(fromI, fromOff, toI, toOff, content, breakAtStart, openStart, openEnd) {\n        let before = this.children[fromI], last = content.length ? content[content.length - 1] : null;\n        let breakAtEnd = last ? last.breakAfter : breakAtStart;\n        // Change within a single line\n        if (fromI == toI && !breakAtStart && !breakAtEnd && content.length < 2 &&\n            before.merge(fromOff, toOff, content.length ? last : null, fromOff == 0, openStart, openEnd))\n            return;\n        let after = this.children[toI];\n        // Make sure the end of the line after the update is preserved in `after`\n        if (toOff < after.length || after.children.length && after.children[after.children.length - 1].length == 0) {\n            // If we're splitting a line, separate part of the start line to\n            // avoid that being mangled when updating the start line.\n            if (fromI == toI) {\n                after = after.split(toOff);\n                toOff = 0;\n            }\n            // If the element after the replacement should be merged with\n            // the last replacing element, update `content`\n            if (!breakAtEnd && last && after.merge(0, toOff, last, true, 0, openEnd)) {\n                content[content.length - 1] = after;\n            }\n            else {\n                // Remove the start of the after element, if necessary, and\n                // add it to `content`.\n                if (toOff || after.children.length && after.children[0].length == 0)\n                    after.merge(0, toOff, null, false, 0, openEnd);\n                content.push(after);\n            }\n        }\n        else if (after.breakAfter) {\n            // The element at `toI` is entirely covered by this range.\n            // Preserve its line break, if any.\n            if (last)\n                last.breakAfter = 1;\n            else\n                breakAtStart = 1;\n        }\n        // Since we've handled the next element from the current elements\n        // now, make sure `toI` points after that.\n        toI++;\n        before.breakAfter = breakAtStart;\n        if (fromOff > 0) {\n            if (!breakAtStart && content.length && before.merge(fromOff, before.length, content[0], false, openStart, 0)) {\n                before.breakAfter = content.shift().breakAfter;\n            }\n            else if (fromOff < before.length || before.children.length && before.children[before.children.length - 1].length == 0) {\n                before.merge(fromOff, before.length, null, false, openStart, 0);\n            }\n            fromI++;\n        }\n        // Try to merge widgets on the boundaries of the replacement\n        while (fromI < toI && content.length) {\n            if (this.children[toI - 1].match(content[content.length - 1]))\n                toI--, content.pop();\n            else if (this.children[fromI].match(content[0]))\n                fromI++, content.shift();\n            else\n                break;\n        }\n        if (fromI < toI || content.length)\n            this.replaceChildren(fromI, toI, content);\n    }\n    // Sync the DOM selection to this.state.selection\n    updateSelection(force = false, fromPointer = false) {\n        if (!(fromPointer || this.mayControlSelection()))\n            return;\n        let main = this.view.state.selection.main;\n        // FIXME need to handle the case where the selection falls inside a block range\n        let anchor = this.domAtPos(main.anchor);\n        let head = this.domAtPos(main.head);\n        let domSel = getSelection(this.root);\n        // If the selection is already here, or in an equivalent position, don't touch it\n        if (force || !domSel.focusNode ||\n            (browser.gecko && main.empty && nextToUneditable(domSel.focusNode, domSel.focusOffset)) ||\n            !isEquivalentPosition(anchor.node, anchor.offset, domSel.anchorNode, domSel.anchorOffset) ||\n            !isEquivalentPosition(head.node, head.offset, domSel.focusNode, domSel.focusOffset)) {\n            this.view.observer.ignore(() => {\n                if (main.empty) {\n                    // Work around https://bugzilla.mozilla.org/show_bug.cgi?id=1612076\n                    if (browser.gecko) {\n                        let nextTo = nextToUneditable(anchor.node, anchor.offset);\n                        if (nextTo && nextTo != (1 /* Before */ | 2 /* After */)) {\n                            let text = nearbyTextNode(anchor.node, anchor.offset, nextTo == 1 /* Before */ ? 1 : -1);\n                            if (text)\n                                anchor = new DOMPos(text, nextTo == 1 /* Before */ ? 0 : text.nodeValue.length);\n                        }\n                    }\n                    domSel.collapse(anchor.node, anchor.offset);\n                    if (main.bidiLevel != null && domSel.cursorBidiLevel != null)\n                        domSel.cursorBidiLevel = main.bidiLevel;\n                }\n                else if (domSel.extend) {\n                    // Selection.extend can be used to create an 'inverted' selection\n                    // (one where the focus is before the anchor), but not all\n                    // browsers support it yet.\n                    domSel.collapse(anchor.node, anchor.offset);\n                    domSel.extend(head.node, head.offset);\n                }\n                else {\n                    // Primitive (IE) way\n                    let range = document.createRange();\n                    if (main.anchor > main.head)\n                        [anchor, head] = [head, anchor];\n                    range.setEnd(head.node, head.offset);\n                    range.setStart(anchor.node, anchor.offset);\n                    domSel.removeAllRanges();\n                    domSel.addRange(range);\n                }\n            });\n        }\n        this.impreciseAnchor = anchor.precise ? null : new DOMPos(domSel.anchorNode, domSel.anchorOffset);\n        this.impreciseHead = head.precise ? null : new DOMPos(domSel.focusNode, domSel.focusOffset);\n    }\n    enforceCursorAssoc() {\n        let cursor = this.view.state.selection.main;\n        let sel = getSelection(this.root);\n        if (!cursor.empty || !cursor.assoc || !sel.modify)\n            return;\n        let line = LineView.find(this, cursor.head); // FIXME provide view-line-range finding helper\n        if (!line)\n            return;\n        let lineStart = line.posAtStart;\n        if (cursor.head == lineStart || cursor.head == lineStart + line.length)\n            return;\n        let before = this.coordsAt(cursor.head, -1), after = this.coordsAt(cursor.head, 1);\n        if (!before || !after || before.bottom > after.top)\n            return;\n        let dom = this.domAtPos(cursor.head + cursor.assoc);\n        sel.collapse(dom.node, dom.offset);\n        sel.modify(\"move\", cursor.assoc < 0 ? \"forward\" : \"backward\", \"lineboundary\");\n    }\n    mayControlSelection() {\n        return this.view.state.facet(editable) ? this.root.activeElement == this.dom : hasSelection(this.dom, getSelection(this.root));\n    }\n    nearest(dom) {\n        for (let cur = dom; cur;) {\n            let domView = ContentView.get(cur);\n            if (domView && domView.rootView == this)\n                return domView;\n            cur = cur.parentNode;\n        }\n        return null;\n    }\n    posFromDOM(node, offset) {\n        let view = this.nearest(node);\n        if (!view)\n            throw new RangeError(\"Trying to find position for a DOM position outside of the document\");\n        return view.localPosFromDOM(node, offset) + view.posAtStart;\n    }\n    domAtPos(pos) {\n        let { i, off } = this.childCursor().findPos(pos, -1);\n        for (; i < this.children.length - 1;) {\n            let child = this.children[i];\n            if (off < child.length || child instanceof LineView)\n                break;\n            i++;\n            off = 0;\n        }\n        return this.children[i].domAtPos(off);\n    }\n    coordsAt(pos, side) {\n        for (let off = this.length, i = this.children.length - 1;; i--) {\n            let child = this.children[i], start = off - child.breakAfter - child.length;\n            if (pos > start || pos == start && (child.type == BlockType.Text || !i || this.children[i - 1].breakAfter))\n                return child.coordsAt(pos - start, side);\n            off = start;\n        }\n    }\n    measureVisibleLineHeights() {\n        let result = [], { from, to } = this.view.viewState.viewport;\n        let minWidth = Math.max(this.view.scrollDOM.clientWidth, this.minWidth) + 1;\n        for (let pos = 0, i = 0; i < this.children.length; i++) {\n            let child = this.children[i], end = pos + child.length;\n            if (end > to)\n                break;\n            if (pos >= from) {\n                result.push(child.dom.getBoundingClientRect().height);\n                let width = child.dom.scrollWidth;\n                if (width > minWidth) {\n                    this.minWidth = minWidth = width;\n                    this.minWidthFrom = pos;\n                    this.minWidthTo = end;\n                }\n            }\n            pos = end + child.breakAfter;\n        }\n        return result;\n    }\n    measureTextSize() {\n        for (let child of this.children) {\n            if (child instanceof LineView) {\n                let measure = child.measureTextSize();\n                if (measure)\n                    return measure;\n            }\n        }\n        // If no workable line exists, force a layout of a measurable element\n        let dummy = document.createElement(\"div\"), lineHeight, charWidth;\n        dummy.className = \"cm-line\";\n        dummy.textContent = \"abc def ghi jkl mno pqr stu\";\n        this.view.observer.ignore(() => {\n            this.dom.appendChild(dummy);\n            let rect = clientRectsFor(dummy.firstChild)[0];\n            lineHeight = dummy.getBoundingClientRect().height;\n            charWidth = rect ? rect.width / 27 : 7;\n            dummy.remove();\n        });\n        return { lineHeight, charWidth };\n    }\n    childCursor(pos = this.length) {\n        // Move back to start of last element when possible, so that\n        // `ChildCursor.findPos` doesn't have to deal with the edge case\n        // of being after the last element.\n        let i = this.children.length;\n        if (i)\n            pos -= this.children[--i].length;\n        return new ChildCursor(this.children, pos, i);\n    }\n    computeBlockGapDeco() {\n        let visible = this.view.viewState.viewport, viewports = [visible];\n        let { head, anchor } = this.view.state.selection.main;\n        if (head < visible.from || head > visible.to) {\n            let { from, to } = this.view.viewState.lineAt(head, 0);\n            viewports.push(new Viewport(from, to));\n        }\n        if (!viewports.some(({ from, to }) => anchor >= from && anchor <= to)) {\n            let { from, to } = this.view.viewState.lineAt(anchor, 0);\n            viewports.push(new Viewport(from, to));\n        }\n        this.viewports = viewports.sort((a, b) => a.from - b.from);\n        let deco = [];\n        for (let pos = 0, i = 0;; i++) {\n            let next = i == viewports.length ? null : viewports[i];\n            let end = next ? next.from - 1 : this.length;\n            if (end > pos) {\n                let height = this.view.viewState.lineAt(end, 0).bottom - this.view.viewState.lineAt(pos, 0).top;\n                deco.push(Decoration.replace({ widget: new BlockGapWidget(height), block: true, inclusive: true }).range(pos, end));\n            }\n            if (!next)\n                break;\n            pos = next.to + 1;\n        }\n        return Decoration.set(deco);\n    }\n    updateDeco() {\n        return this.decorations = [\n            this.computeBlockGapDeco(),\n            this.view.viewState.lineGapDeco,\n            this.compositionDeco,\n            ...this.view.state.facet(decorations),\n            ...this.view.pluginField(PluginField.decorations)\n        ];\n    }\n    scrollPosIntoView(pos, side) {\n        let rect = this.coordsAt(pos, side);\n        if (!rect)\n            return;\n        let mLeft = 0, mRight = 0, mTop = 0, mBottom = 0;\n        for (let margins of this.view.pluginField(PluginField.scrollMargins))\n            if (margins) {\n                let { left, right, top, bottom } = margins;\n                if (left != null)\n                    mLeft = Math.max(mLeft, left);\n                if (right != null)\n                    mRight = Math.max(mRight, right);\n                if (top != null)\n                    mTop = Math.max(mTop, top);\n                if (bottom != null)\n                    mBottom = Math.max(mBottom, bottom);\n            }\n        scrollRectIntoView(this.dom, {\n            left: rect.left - mLeft, top: rect.top - mTop,\n            right: rect.right + mRight, bottom: rect.bottom + mBottom\n        });\n    }\n}\n// Browsers appear to reserve a fixed amount of bits for height\n// styles, and ignore or clip heights above that. For Chrome and\n// Firefox, this is in the 20 million range, so we try to stay below\n// that.\nconst MaxNodeHeight = 1e7;\nclass BlockGapWidget extends WidgetType {\n    constructor(height) {\n        super();\n        this.height = height;\n    }\n    toDOM() {\n        let elt = document.createElement(\"div\");\n        this.updateDOM(elt);\n        return elt;\n    }\n    eq(other) { return other.height == this.height; }\n    updateDOM(elt) {\n        if (this.height < MaxNodeHeight) {\n            while (elt.lastChild)\n                elt.lastChild.remove();\n            elt.style.height = this.height + \"px\";\n        }\n        else {\n            elt.style.height = \"\";\n            for (let remaining = this.height; remaining > 0; remaining -= MaxNodeHeight) {\n                let fill = elt.appendChild(document.createElement(\"div\"));\n                fill.style.height = Math.min(remaining, MaxNodeHeight) + \"px\";\n            }\n        }\n        return true;\n    }\n    get estimatedHeight() { return this.height; }\n}\nfunction computeCompositionDeco(view, changes) {\n    let sel = getSelection(view.root);\n    let textNode = sel.focusNode && nearbyTextNode(sel.focusNode, sel.focusOffset, 0);\n    if (!textNode)\n        return Decoration.none;\n    let cView = view.docView.nearest(textNode);\n    let from, to, topNode = textNode;\n    if (cView instanceof InlineView) {\n        while (cView.parent instanceof InlineView)\n            cView = cView.parent;\n        from = cView.posAtStart;\n        to = from + cView.length;\n        topNode = cView.dom;\n    }\n    else if (cView instanceof LineView) {\n        while (topNode.parentNode != cView.dom)\n            topNode = topNode.parentNode;\n        let prev = topNode.previousSibling;\n        while (prev && !ContentView.get(prev))\n            prev = prev.previousSibling;\n        from = to = prev ? ContentView.get(prev).posAtEnd : cView.posAtStart;\n    }\n    else {\n        return Decoration.none;\n    }\n    let newFrom = changes.mapPos(from, 1), newTo = Math.max(newFrom, changes.mapPos(to, -1));\n    let text = textNode.nodeValue, { state } = view;\n    if (newTo - newFrom < text.length) {\n        if (state.sliceDoc(newFrom, Math.min(state.doc.length, newFrom + text.length)) == text)\n            newTo = newFrom + text.length;\n        else if (state.sliceDoc(Math.max(0, newTo - text.length), newTo) == text)\n            newFrom = newTo - text.length;\n        else\n            return Decoration.none;\n    }\n    else if (state.sliceDoc(newFrom, newTo) != text) {\n        return Decoration.none;\n    }\n    return Decoration.set(Decoration.replace({ widget: new CompositionWidget(topNode, textNode) }).range(newFrom, newTo));\n}\nclass CompositionWidget extends WidgetType {\n    constructor(top, text) {\n        super();\n        this.top = top;\n        this.text = text;\n    }\n    eq(other) { return this.top == other.top && this.text == other.text; }\n    toDOM() { return this.top; }\n    ignoreEvent() { return false; }\n    get customView() { return CompositionView; }\n}\nfunction nearbyTextNode(node, offset, side) {\n    for (;;) {\n        if (node.nodeType == 3)\n            return node;\n        if (node.nodeType == 1 && offset > 0 && side <= 0) {\n            node = node.childNodes[offset - 1];\n            offset = maxOffset(node);\n        }\n        else if (node.nodeType == 1 && offset < node.childNodes.length && side >= 0) {\n            node = node.childNodes[offset];\n            offset = 0;\n        }\n        else {\n            return null;\n        }\n    }\n}\nfunction nextToUneditable(node, offset) {\n    if (node.nodeType != 1)\n        return 0;\n    return (offset && node.childNodes[offset - 1].contentEditable == \"false\" ? 1 /* Before */ : 0) |\n        (offset < node.childNodes.length && node.childNodes[offset].contentEditable == \"false\" ? 2 /* After */ : 0);\n}\nclass DecorationComparator$1 {\n    constructor() {\n        this.changes = [];\n    }\n    compareRange(from, to) { addRange(from, to, this.changes); }\n    comparePoint(from, to) { addRange(from, to, this.changes); }\n}\nfunction findChangedDeco(a, b, diff) {\n    let comp = new DecorationComparator$1;\n    RangeSet.compare(a, b, diff, comp);\n    return comp.changes;\n}\n\nfunction groupAt(state, pos, bias = 1) {\n    let categorize = state.charCategorizer(pos);\n    let line = state.doc.lineAt(pos), linePos = pos - line.from;\n    if (line.length == 0)\n        return EditorSelection.cursor(pos);\n    if (linePos == 0)\n        bias = 1;\n    else if (linePos == line.length)\n        bias = -1;\n    let from = linePos, to = linePos;\n    if (bias < 0)\n        from = findClusterBreak(line.text, linePos, false);\n    else\n        to = findClusterBreak(line.text, linePos);\n    let cat = categorize(line.text.slice(from, to));\n    while (from > 0) {\n        let prev = findClusterBreak(line.text, from, false);\n        if (categorize(line.text.slice(prev, from)) != cat)\n            break;\n        from = prev;\n    }\n    while (to < line.length) {\n        let next = findClusterBreak(line.text, to);\n        if (categorize(line.text.slice(to, next)) != cat)\n            break;\n        to = next;\n    }\n    return EditorSelection.range(from + line.from, to + line.from);\n}\n// Search the DOM for the {node, offset} position closest to the given\n// coordinates. Very inefficient and crude, but can usually be avoided\n// by calling caret(Position|Range)FromPoint instead.\n// FIXME holding arrow-up/down at the end of the viewport is a rather\n// common use case that will repeatedly trigger this code. Maybe\n// introduce some element of binary search after all?\nfunction getdx(x, rect) {\n    return rect.left > x ? rect.left - x : Math.max(0, x - rect.right);\n}\nfunction getdy(y, rect) {\n    return rect.top > y ? rect.top - y : Math.max(0, y - rect.bottom);\n}\nfunction yOverlap(a, b) {\n    return a.top < b.bottom - 1 && a.bottom > b.top + 1;\n}\nfunction upTop(rect, top) {\n    return top < rect.top ? { top, left: rect.left, right: rect.right, bottom: rect.bottom } : rect;\n}\nfunction upBot(rect, bottom) {\n    return bottom > rect.bottom ? { top: rect.top, left: rect.left, right: rect.right, bottom } : rect;\n}\nfunction domPosAtCoords(parent, x, y) {\n    let closest, closestRect, closestX, closestY;\n    let above, below, aboveRect, belowRect;\n    for (let child = parent.firstChild; child; child = child.nextSibling) {\n        let rects = clientRectsFor(child);\n        for (let i = 0; i < rects.length; i++) {\n            let rect = rects[i];\n            if (closestRect && yOverlap(closestRect, rect))\n                rect = upTop(upBot(rect, closestRect.bottom), closestRect.top);\n            let dx = getdx(x, rect), dy = getdy(y, rect);\n            if (dx == 0 && dy == 0)\n                return child.nodeType == 3 ? domPosInText(child, x, y) : domPosAtCoords(child, x, y);\n            if (!closest || closestY > dy || closestY == dy && closestX > dx) {\n                closest = child;\n                closestRect = rect;\n                closestX = dx;\n                closestY = dy;\n            }\n            if (dx == 0) {\n                if (y > rect.bottom && (!aboveRect || aboveRect.bottom < rect.bottom)) {\n                    above = child;\n                    aboveRect = rect;\n                }\n                else if (y < rect.top && (!belowRect || belowRect.top > rect.top)) {\n                    below = child;\n                    belowRect = rect;\n                }\n            }\n            else if (aboveRect && yOverlap(aboveRect, rect)) {\n                aboveRect = upBot(aboveRect, rect.bottom);\n            }\n            else if (belowRect && yOverlap(belowRect, rect)) {\n                belowRect = upTop(belowRect, rect.top);\n            }\n        }\n    }\n    if (aboveRect && aboveRect.bottom >= y) {\n        closest = above;\n        closestRect = aboveRect;\n    }\n    else if (belowRect && belowRect.top <= y) {\n        closest = below;\n        closestRect = belowRect;\n    }\n    if (!closest)\n        return { node: parent, offset: 0 };\n    let clipX = Math.max(closestRect.left, Math.min(closestRect.right, x));\n    if (closest.nodeType == 3)\n        return domPosInText(closest, clipX, y);\n    if (!closestX && closest.contentEditable == \"true\")\n        return domPosAtCoords(closest, clipX, y);\n    let offset = Array.prototype.indexOf.call(parent.childNodes, closest) +\n        (x >= (closestRect.left + closestRect.right) / 2 ? 1 : 0);\n    return { node: parent, offset };\n}\nfunction domPosInText(node, x, y) {\n    let len = node.nodeValue.length, range = tempRange();\n    for (let i = 0; i < len; i++) {\n        range.setEnd(node, i + 1);\n        range.setStart(node, i);\n        let rects = range.getClientRects();\n        for (let j = 0; j < rects.length; j++) {\n            let rect = rects[j];\n            if (rect.top == rect.bottom)\n                continue;\n            if (rect.left - 1 <= x && rect.right + 1 >= x &&\n                rect.top - 1 <= y && rect.bottom + 1 >= y) {\n                let right = x >= (rect.left + rect.right) / 2, after = right;\n                if (browser.chrome || browser.gecko) {\n                    // Check for RTL on browsers that support getting client\n                    // rects for empty ranges.\n                    range.setEnd(node, i);\n                    let rectBefore = range.getBoundingClientRect();\n                    if (rectBefore.left == rect.right)\n                        after = !right;\n                }\n                return { node, offset: i + (after ? 1 : 0) };\n            }\n        }\n    }\n    return { node, offset: 0 };\n}\nfunction posAtCoords(view, { x, y }, bias = -1) {\n    let content = view.contentDOM.getBoundingClientRect(), block;\n    let halfLine = view.defaultLineHeight / 2;\n    for (let bounced = false;;) {\n        block = view.blockAtHeight(y, content.top);\n        if (block.top > y || block.bottom < y) {\n            bias = block.top > y ? -1 : 1;\n            y = Math.min(block.bottom - halfLine, Math.max(block.top + halfLine, y));\n            if (bounced)\n                return -1;\n            else\n                bounced = true;\n        }\n        if (block.type == BlockType.Text)\n            break;\n        y = bias > 0 ? block.bottom + halfLine : block.top - halfLine;\n    }\n    let lineStart = block.from;\n    // If this is outside of the rendered viewport, we can't determine a position\n    if (lineStart < view.viewport.from)\n        return view.viewport.from == 0 ? 0 : null;\n    if (lineStart > view.viewport.to)\n        return view.viewport.to == view.state.doc.length ? view.state.doc.length : null;\n    // Clip x to the viewport sides\n    x = Math.max(content.left + 1, Math.min(content.right - 1, x));\n    let root = view.root, element = root.elementFromPoint(x, y);\n    // There's visible editor content under the point, so we can try\n    // using caret(Position|Range)FromPoint as a shortcut\n    let node, offset = -1;\n    if (element && view.contentDOM.contains(element) && !(view.docView.nearest(element) instanceof WidgetView)) {\n        if (root.caretPositionFromPoint) {\n            let pos = root.caretPositionFromPoint(x, y);\n            if (pos)\n                ({ offsetNode: node, offset } = pos);\n        }\n        else if (root.caretRangeFromPoint) {\n            let range = root.caretRangeFromPoint(x, y);\n            if (range)\n                ({ startContainer: node, startOffset: offset } = range);\n        }\n    }\n    // No luck, do our own (potentially expensive) search\n    if (!node || !view.docView.dom.contains(node)) {\n        let line = LineView.find(view.docView, lineStart);\n        ({ node, offset } = domPosAtCoords(line.dom, x, y));\n    }\n    return view.docView.posFromDOM(node, offset);\n}\nfunction moveToLineBoundary(view, start, forward, includeWrap) {\n    let line = view.state.doc.lineAt(start.head);\n    let coords = !includeWrap || !view.lineWrapping ? null\n        : view.coordsAtPos(start.assoc < 0 && start.head > line.from ? start.head - 1 : start.head);\n    if (coords) {\n        let editorRect = view.dom.getBoundingClientRect();\n        let pos = view.posAtCoords({ x: forward == (view.textDirection == Direction.LTR) ? editorRect.right - 1 : editorRect.left + 1,\n            y: (coords.top + coords.bottom) / 2 });\n        if (pos != null)\n            return EditorSelection.cursor(pos, forward ? -1 : 1);\n    }\n    let lineView = LineView.find(view.docView, start.head);\n    let end = lineView ? (forward ? lineView.posAtEnd : lineView.posAtStart) : (forward ? line.to : line.from);\n    return EditorSelection.cursor(end, forward ? -1 : 1);\n}\nfunction moveByChar(view, start, forward, by) {\n    let line = view.state.doc.lineAt(start.head), spans = view.bidiSpans(line);\n    for (let cur = start, check = null;;) {\n        let next = moveVisually(line, spans, view.textDirection, cur, forward), char = movedOver;\n        if (!next) {\n            if (line.number == (forward ? view.state.doc.lines : 1))\n                return cur;\n            char = \"\\n\";\n            line = view.state.doc.line(line.number + (forward ? 1 : -1));\n            spans = view.bidiSpans(line);\n            next = EditorSelection.cursor(forward ? line.from : line.to);\n        }\n        if (!check) {\n            if (!by)\n                return next;\n            check = by(char);\n        }\n        else if (!check(char)) {\n            return cur;\n        }\n        cur = next;\n    }\n}\nfunction byGroup(view, pos, start) {\n    let categorize = view.state.charCategorizer(pos);\n    let cat = categorize(start);\n    return (next) => {\n        let nextCat = categorize(next);\n        if (cat == CharCategory.Space)\n            cat = nextCat;\n        return cat == nextCat;\n    };\n}\nfunction moveVertically(view, start, forward, distance) {\n    var _a;\n    let startPos = start.head, dir = forward ? 1 : -1;\n    if (startPos == (forward ? view.state.doc.length : 0))\n        return EditorSelection.cursor(startPos);\n    let startCoords = view.coordsAtPos(startPos);\n    if (startCoords) {\n        let rect = view.dom.getBoundingClientRect();\n        let goal = (_a = start.goalColumn) !== null && _a !== void 0 ? _a : startCoords.left - rect.left;\n        let resolvedGoal = rect.left + goal;\n        let dist = distance !== null && distance !== void 0 ? distance : 5;\n        for (let startY = dir < 0 ? startCoords.top : startCoords.bottom, extra = 0; extra < 50; extra += 10) {\n            let pos = posAtCoords(view, { x: resolvedGoal, y: startY + (dist + extra) * dir }, dir);\n            if (pos == null)\n                break;\n            if (pos != startPos)\n                return EditorSelection.cursor(pos, undefined, undefined, goal);\n        }\n    }\n    // Outside of the drawn viewport, use a crude column-based approach\n    let { doc } = view.state, line = doc.lineAt(startPos), tabSize = view.state.tabSize;\n    let goal = start.goalColumn, goalCol = 0;\n    if (goal == null) {\n        for (const iter = doc.iterRange(line.from, startPos); !iter.next().done;)\n            goalCol = countColumn(iter.value, goalCol, tabSize);\n        goal = goalCol * view.defaultCharacterWidth;\n    }\n    else {\n        goalCol = Math.round(goal / view.defaultCharacterWidth);\n    }\n    if (dir < 0 && line.from == 0)\n        return EditorSelection.cursor(0);\n    else if (dir > 0 && line.to == doc.length)\n        return EditorSelection.cursor(line.to);\n    let otherLine = doc.line(line.number + dir);\n    let result = otherLine.from;\n    let seen = 0;\n    for (const iter = doc.iterRange(otherLine.from, otherLine.to); seen >= goalCol && !iter.next().done;) {\n        const { offset, leftOver } = findColumn(iter.value, seen, goalCol, tabSize);\n        seen = goalCol - leftOver;\n        result += offset;\n    }\n    return EditorSelection.cursor(result, undefined, undefined, goal);\n}\n\n// This will also be where dragging info and such goes\nclass InputState {\n    constructor(view) {\n        this.lastKeyCode = 0;\n        this.lastKeyTime = 0;\n        this.lastSelectionOrigin = null;\n        this.lastSelectionTime = 0;\n        this.lastEscPress = 0;\n        this.scrollHandlers = [];\n        this.registeredEvents = [];\n        this.customHandlers = [];\n        this.composing = false;\n        this.compositionEndedAt = 0;\n        this.mouseSelection = null;\n        for (let type in handlers) {\n            let handler = handlers[type];\n            view.contentDOM.addEventListener(type, (event) => {\n                if (!eventBelongsToEditor(view, event) || this.ignoreDuringComposition(event) ||\n                    type == \"keydown\" && this.screenKeyEvent(view, event))\n                    return;\n                if (this.mustFlushObserver(event))\n                    view.observer.forceFlush();\n                if (this.runCustomHandlers(type, view, event))\n                    event.preventDefault();\n                else\n                    handler(view, event);\n            });\n            this.registeredEvents.push(type);\n        }\n        // Must always run, even if a custom handler handled the event\n        view.contentDOM.addEventListener(\"keydown\", (event) => {\n            view.inputState.lastKeyCode = event.keyCode;\n            view.inputState.lastKeyTime = Date.now();\n        });\n        this.notifiedFocused = view.hasFocus;\n        this.ensureHandlers(view);\n    }\n    setSelectionOrigin(origin) {\n        this.lastSelectionOrigin = origin;\n        this.lastSelectionTime = Date.now();\n    }\n    ensureHandlers(view) {\n        let handlers = this.customHandlers = view.pluginField(domEventHandlers);\n        for (let set of handlers) {\n            for (let type in set.handlers)\n                if (this.registeredEvents.indexOf(type) < 0 && type != \"scroll\") {\n                    this.registeredEvents.push(type);\n                    view.contentDOM.addEventListener(type, (event) => {\n                        if (!eventBelongsToEditor(view, event))\n                            return;\n                        if (this.runCustomHandlers(type, view, event))\n                            event.preventDefault();\n                    });\n                }\n        }\n    }\n    runCustomHandlers(type, view, event) {\n        for (let set of this.customHandlers) {\n            let handler = set.handlers[type];\n            if (handler) {\n                try {\n                    if (handler.call(set.plugin, event, view) || event.defaultPrevented)\n                        return true;\n                }\n                catch (e) {\n                    logException(view.state, e);\n                }\n            }\n        }\n        return false;\n    }\n    runScrollHandlers(view, event) {\n        for (let set of this.customHandlers) {\n            let handler = set.handlers.scroll;\n            if (handler) {\n                try {\n                    handler.call(set.plugin, event, view);\n                }\n                catch (e) {\n                    logException(view.state, e);\n                }\n            }\n        }\n    }\n    ignoreDuringComposition(event) {\n        if (!/^key/.test(event.type))\n            return false;\n        if (this.composing)\n            return true;\n        // See https://www.stum.de/2016/06/24/handling-ime-events-in-javascript/.\n        // On some input method editors (IMEs), the Enter key is used to\n        // confirm character selection. On Safari, when Enter is pressed,\n        // compositionend and keydown events are sometimes emitted in the\n        // wrong order. The key event should still be ignored, even when\n        // it happens after the compositionend event.\n        if (browser.safari && event.timeStamp - this.compositionEndedAt < 500) {\n            this.compositionEndedAt = 0;\n            return true;\n        }\n        return false;\n    }\n    screenKeyEvent(view, event) {\n        let protectedTab = event.keyCode == 9 && Date.now() < this.lastEscPress + 2000;\n        if (event.keyCode == 27)\n            this.lastEscPress = Date.now();\n        else if (modifierCodes.indexOf(event.keyCode) < 0)\n            this.lastEscPress = 0;\n        return protectedTab;\n    }\n    mustFlushObserver(event) {\n        return event.type == \"keydown\" || event.type == \"compositionend\";\n    }\n    startMouseSelection(view, event, style) {\n        if (this.mouseSelection)\n            this.mouseSelection.destroy();\n        this.mouseSelection = new MouseSelection(this, view, event, style);\n    }\n    update(update) {\n        if (this.mouseSelection)\n            this.mouseSelection.update(update);\n        this.lastKeyCode = this.lastSelectionTime = 0;\n    }\n    destroy() {\n        if (this.mouseSelection)\n            this.mouseSelection.destroy();\n    }\n}\n// Key codes for modifier keys\nconst modifierCodes = [16, 17, 18, 20, 91, 92, 224, 225];\nclass MouseSelection {\n    constructor(inputState, view, startEvent, style) {\n        this.inputState = inputState;\n        this.view = view;\n        this.startEvent = startEvent;\n        this.style = style;\n        let doc = view.contentDOM.ownerDocument;\n        doc.addEventListener(\"mousemove\", this.move = this.move.bind(this));\n        doc.addEventListener(\"mouseup\", this.up = this.up.bind(this));\n        this.extend = startEvent.shiftKey;\n        this.multiple = view.state.facet(EditorState.allowMultipleSelections) && addsSelectionRange(view, startEvent);\n        this.dragMove = dragMovesSelection$1(view, startEvent);\n        this.dragging = isInPrimarySelection(view, startEvent) ? null : false;\n        // When clicking outside of the selection, immediately apply the\n        // effect of starting the selection\n        if (this.dragging === false) {\n            startEvent.preventDefault();\n            this.select(startEvent);\n        }\n    }\n    move(event) {\n        if (event.buttons == 0)\n            return this.destroy();\n        if (this.dragging !== false)\n            return;\n        this.select(event);\n    }\n    up(event) {\n        if (this.dragging == null)\n            this.select(this.startEvent);\n        if (!this.dragging)\n            event.preventDefault();\n        this.destroy();\n    }\n    destroy() {\n        let doc = this.view.contentDOM.ownerDocument;\n        doc.removeEventListener(\"mousemove\", this.move);\n        doc.removeEventListener(\"mouseup\", this.up);\n        this.inputState.mouseSelection = null;\n    }\n    select(event) {\n        let selection = this.style.get(event, this.extend, this.multiple);\n        if (!selection.eq(this.view.state.selection) || selection.main.assoc != this.view.state.selection.main.assoc)\n            this.view.dispatch({\n                selection,\n                annotations: Transaction.userEvent.of(\"pointerselection\"),\n                scrollIntoView: true\n            });\n    }\n    update(update) {\n        if (update.docChanged && this.dragging)\n            this.dragging = this.dragging.map(update.changes);\n        this.style.update(update);\n    }\n}\nfunction addsSelectionRange(view, event) {\n    let facet = view.state.facet(clickAddsSelectionRange);\n    return facet.length ? facet[0](event) : browser.mac ? event.metaKey : event.ctrlKey;\n}\nfunction dragMovesSelection$1(view, event) {\n    let facet = view.state.facet(dragMovesSelection);\n    return facet.length ? facet[0](event) : browser.mac ? !event.altKey : !event.ctrlKey;\n}\nfunction isInPrimarySelection(view, event) {\n    let { main } = view.state.selection;\n    if (main.empty)\n        return false;\n    // On boundary clicks, check whether the coordinates are inside the\n    // selection's client rectangles\n    let sel = getSelection(view.root);\n    if (sel.rangeCount == 0)\n        return true;\n    let rects = sel.getRangeAt(0).getClientRects();\n    for (let i = 0; i < rects.length; i++) {\n        let rect = rects[i];\n        if (rect.left <= event.clientX && rect.right >= event.clientX &&\n            rect.top <= event.clientY && rect.bottom >= event.clientY)\n            return true;\n    }\n    return false;\n}\nfunction eventBelongsToEditor(view, event) {\n    if (!event.bubbles)\n        return true;\n    if (event.defaultPrevented)\n        return false;\n    for (let node = event.target, cView; node != view.contentDOM; node = node.parentNode)\n        if (!node || node.nodeType == 11 || ((cView = ContentView.get(node)) && cView.ignoreEvent(event)))\n            return false;\n    return true;\n}\nconst handlers = Object.create(null);\n// This is very crude, but unfortunately both these browsers _pretend_\n// that they have a clipboard API—all the objects and methods are\n// there, they just don't work, and they are hard to test.\nconst brokenClipboardAPI = (browser.ie && browser.ie_version < 15) ||\n    (browser.ios && browser.webkit_version < 604);\nfunction capturePaste(view) {\n    let parent = view.dom.parentNode;\n    if (!parent)\n        return;\n    let target = parent.appendChild(document.createElement(\"textarea\"));\n    target.style.cssText = \"position: fixed; left: -10000px; top: 10px\";\n    target.focus();\n    setTimeout(() => {\n        view.focus();\n        target.remove();\n        doPaste(view, target.value);\n    }, 50);\n}\nfunction doPaste(view, input) {\n    let { state } = view, changes, i = 1, text = state.toText(input);\n    let byLine = text.lines == state.selection.ranges.length;\n    let linewise = lastLinewiseCopy && state.selection.ranges.every(r => r.empty) && lastLinewiseCopy == text.toString();\n    if (linewise) {\n        changes = {\n            changes: state.selection.ranges.map(r => state.doc.lineAt(r.from))\n                .filter((l, i, a) => i == 0 || a[i - 1] != l)\n                .map(line => ({ from: line.from, insert: (byLine ? text.line(i++).text : input) + state.lineBreak }))\n        };\n    }\n    else if (byLine) {\n        changes = state.changeByRange(range => {\n            let line = text.line(i++);\n            return { changes: { from: range.from, to: range.to, insert: line.text },\n                range: EditorSelection.cursor(range.from + line.length) };\n        });\n    }\n    else {\n        changes = state.replaceSelection(text);\n    }\n    view.dispatch(changes, {\n        annotations: Transaction.userEvent.of(\"paste\"),\n        scrollIntoView: true\n    });\n}\nfunction mustCapture(event) {\n    let mods = (event.ctrlKey ? 1 /* Ctrl */ : 0) | (event.metaKey ? 8 /* Meta */ : 0) |\n        (event.altKey ? 2 /* Alt */ : 0) | (event.shiftKey ? 4 /* Shift */ : 0);\n    let code = event.keyCode, macCtrl = browser.mac && mods == 1 /* Ctrl */;\n    return code == 8 || (macCtrl && code == 72) || // Backspace, Ctrl-h on Mac\n        code == 46 || (macCtrl && code == 68) || // Delete, Ctrl-d on Mac\n        code == 27 || // Esc\n        (mods == (browser.mac ? 8 /* Meta */ : 1 /* Ctrl */) && // Ctrl/Cmd-[biyz]\n            (code == 66 || code == 73 || code == 89 || code == 90));\n}\nhandlers.keydown = (view, event) => {\n    if (mustCapture(event))\n        event.preventDefault();\n    view.inputState.setSelectionOrigin(\"keyboardselection\");\n};\nhandlers.touchdown = handlers.touchmove = view => {\n    view.inputState.setSelectionOrigin(\"pointerselection\");\n};\nhandlers.mousedown = (view, event) => {\n    let style = null;\n    for (let makeStyle of view.state.facet(mouseSelectionStyle)) {\n        style = makeStyle(view, event);\n        if (style)\n            break;\n    }\n    if (!style && event.button == 0)\n        style = basicMouseSelection(view, event);\n    if (style) {\n        if (view.root.activeElement != view.contentDOM)\n            view.observer.ignore(() => focusPreventScroll(view.contentDOM));\n        view.inputState.startMouseSelection(view, event, style);\n    }\n};\nfunction rangeForClick(view, pos, bias, type) {\n    if (type == 1) { // Single click\n        return EditorSelection.cursor(pos, bias);\n    }\n    else if (type == 2) { // Double click\n        return groupAt(view.state, pos, bias);\n    }\n    else { // Triple click\n        let line = LineView.find(view.docView, pos);\n        if (line)\n            return EditorSelection.range(line.posAtStart, line.posAtEnd);\n        let { from, to } = view.state.doc.lineAt(pos);\n        return EditorSelection.range(from, to);\n    }\n}\nlet insideY = (y, rect) => y >= rect.top && y <= rect.bottom;\nlet inside = (x, y, rect) => insideY(y, rect) && x >= rect.left && x <= rect.right;\n// Try to determine, for the given coordinates, associated with the\n// given position, whether they are related to the element before or\n// the element after the position.\nfunction findPositionSide(view, pos, x, y) {\n    let line = LineView.find(view.docView, pos);\n    if (!line)\n        return 1;\n    let off = pos - line.posAtStart;\n    // Line boundaries point into the line\n    if (off == 0)\n        return 1;\n    if (off == line.length)\n        return -1;\n    // Positions on top of an element point at that element\n    let before = line.coordsAt(off, -1);\n    if (before && inside(x, y, before))\n        return -1;\n    let after = line.coordsAt(off, 1);\n    if (after && inside(x, y, after))\n        return 1;\n    // This is probably a line wrap point. Pick before if the point is\n    // beside it.\n    return before && insideY(y, before) ? -1 : 1;\n}\nfunction queryPos(view, event) {\n    let pos = view.posAtCoords({ x: event.clientX, y: event.clientY });\n    if (pos == null)\n        return null;\n    return { pos, bias: findPositionSide(view, pos, event.clientX, event.clientY) };\n}\nconst BadMouseDetail = browser.ie && browser.ie_version <= 11;\nlet lastMouseDown = null, lastMouseDownCount = 0;\nfunction getClickType(event) {\n    if (!BadMouseDetail)\n        return event.detail;\n    let last = lastMouseDown;\n    lastMouseDown = event;\n    return lastMouseDownCount = !last || (last.timeStamp > Date.now() - 400 && Math.abs(last.clientX - event.clientX) < 2 &&\n        Math.abs(last.clientY - event.clientY) < 2) ? (lastMouseDownCount + 1) % 3 : 1;\n}\nfunction basicMouseSelection(view, event) {\n    let start = queryPos(view, event), type = getClickType(event);\n    let startSel = view.state.selection;\n    let last = start, lastEvent = event;\n    return {\n        update(update) {\n            if (update.changes) {\n                if (start)\n                    start.pos = update.changes.mapPos(start.pos);\n                startSel = startSel.map(update.changes);\n            }\n        },\n        get(event, extend, multiple) {\n            let cur;\n            if (event.clientX == lastEvent.clientX && event.clientY == lastEvent.clientY)\n                cur = last;\n            else {\n                cur = last = queryPos(view, event);\n                lastEvent = event;\n            }\n            if (!cur || !start)\n                return startSel;\n            let range = rangeForClick(view, cur.pos, cur.bias, type);\n            if (start.pos != cur.pos && !extend) {\n                let startRange = rangeForClick(view, start.pos, start.bias, type);\n                let from = Math.min(startRange.from, range.from), to = Math.max(startRange.to, range.to);\n                range = from < range.from ? EditorSelection.range(from, to) : EditorSelection.range(to, from);\n            }\n            if (extend)\n                return startSel.replaceRange(startSel.main.extend(range.from, range.to));\n            else if (multiple)\n                return startSel.addRange(range);\n            else\n                return EditorSelection.create([range]);\n        }\n    };\n}\nhandlers.dragstart = (view, event) => {\n    let { selection: { main } } = view.state;\n    let { mouseSelection } = view.inputState;\n    if (mouseSelection)\n        mouseSelection.dragging = main;\n    if (event.dataTransfer) {\n        event.dataTransfer.setData(\"Text\", view.state.sliceDoc(main.from, main.to));\n        event.dataTransfer.effectAllowed = \"copyMove\";\n    }\n};\nhandlers.drop = (view, event) => {\n    if (!event.dataTransfer)\n        return;\n    let dropPos = view.posAtCoords({ x: event.clientX, y: event.clientY });\n    let text = event.dataTransfer.getData(\"Text\");\n    if (dropPos == null || !text)\n        return;\n    event.preventDefault();\n    let { mouseSelection } = view.inputState;\n    let del = mouseSelection && mouseSelection.dragging && mouseSelection.dragMove ?\n        { from: mouseSelection.dragging.from, to: mouseSelection.dragging.to } : null;\n    let ins = { from: dropPos, insert: text };\n    let changes = view.state.changes(del ? [del, ins] : ins);\n    view.focus();\n    view.dispatch({\n        changes,\n        selection: { anchor: changes.mapPos(dropPos, -1), head: changes.mapPos(dropPos, 1) },\n        annotations: Transaction.userEvent.of(\"drop\")\n    });\n};\nhandlers.paste = (view, event) => {\n    view.observer.flush();\n    let data = brokenClipboardAPI ? null : event.clipboardData;\n    let text = data && data.getData(\"text/plain\");\n    if (text) {\n        doPaste(view, text);\n        event.preventDefault();\n    }\n    else {\n        capturePaste(view);\n    }\n};\nfunction captureCopy(view, text) {\n    // The extra wrapper is somehow necessary on IE/Edge to prevent the\n    // content from being mangled when it is put onto the clipboard\n    let parent = view.dom.parentNode;\n    if (!parent)\n        return;\n    let target = parent.appendChild(document.createElement(\"textarea\"));\n    target.style.cssText = \"position: fixed; left: -10000px; top: 10px\";\n    target.value = text;\n    target.focus();\n    target.selectionEnd = text.length;\n    target.selectionStart = 0;\n    setTimeout(() => {\n        target.remove();\n        view.focus();\n    }, 50);\n}\nfunction copiedRange(state) {\n    let content = [], ranges = [], linewise = false;\n    for (let range of state.selection.ranges)\n        if (!range.empty) {\n            content.push(state.sliceDoc(range.from, range.to));\n            ranges.push(range);\n        }\n    if (!content.length) {\n        // Nothing selected, do a line-wise copy\n        let upto = -1;\n        for (let { from } of state.selection.ranges) {\n            let line = state.doc.lineAt(from);\n            if (line.number > upto) {\n                content.push(line.text);\n                ranges.push({ from: line.from, to: Math.min(state.doc.length, line.to + 1) });\n            }\n            upto = line.number;\n        }\n        linewise = true;\n    }\n    return { text: content.join(state.lineBreak), ranges, linewise };\n}\nlet lastLinewiseCopy = null;\nhandlers.copy = handlers.cut = (view, event) => {\n    let { text, ranges, linewise } = copiedRange(view.state);\n    if (!text)\n        return;\n    lastLinewiseCopy = linewise ? text : null;\n    let data = brokenClipboardAPI ? null : event.clipboardData;\n    if (data) {\n        event.preventDefault();\n        data.clearData();\n        data.setData(\"text/plain\", text);\n    }\n    else {\n        captureCopy(view, text);\n    }\n    if (event.type == \"cut\")\n        view.dispatch({\n            changes: ranges,\n            scrollIntoView: true,\n            annotations: Transaction.userEvent.of(\"cut\")\n        });\n};\nhandlers.focus = handlers.blur = view => {\n    setTimeout(() => {\n        if (view.hasFocus != view.inputState.notifiedFocused)\n            view.update([]);\n    }, 10);\n};\nhandlers.beforeprint = view => {\n    view.viewState.printing = true;\n    view.requestMeasure();\n    setTimeout(() => {\n        view.viewState.printing = false;\n        view.requestMeasure();\n    }, 2000);\n};\nfunction forceClearComposition(view) {\n    if (view.docView.compositionDeco.size)\n        view.update([]);\n}\nhandlers.compositionstart = handlers.compositionupdate = view => {\n    if (!view.inputState.composing) {\n        if (view.docView.compositionDeco.size) {\n            view.observer.flush();\n            forceClearComposition(view);\n        }\n        // FIXME possibly set a timeout to clear it again on Android\n        view.inputState.composing = true;\n    }\n};\nhandlers.compositionend = view => {\n    view.inputState.composing = false;\n    view.inputState.compositionEndedAt = Date.now();\n    setTimeout(() => {\n        if (!view.inputState.composing)\n            forceClearComposition(view);\n    }, 50);\n};\n\nconst observeOptions = {\n    childList: true,\n    characterData: true,\n    subtree: true,\n    characterDataOldValue: true\n};\n// IE11 has very broken mutation observers, so we also listen to\n// DOMCharacterDataModified there\nconst useCharData = browser.ie && browser.ie_version <= 11;\nclass DOMObserver {\n    constructor(view, onChange, onScrollChanged) {\n        this.view = view;\n        this.onChange = onChange;\n        this.onScrollChanged = onScrollChanged;\n        this.active = false;\n        this.ignoreSelection = new DOMSelection;\n        this.delayedFlush = -1;\n        this.queue = [];\n        this.scrollTargets = [];\n        this.intersection = null;\n        this.intersecting = false;\n        // Timeout for scheduling check of the parents that need scroll handlers\n        this.parentCheck = -1;\n        this.dom = view.contentDOM;\n        this.observer = new MutationObserver(mutations => {\n            for (let mut of mutations)\n                this.queue.push(mut);\n            // IE11 will sometimes (on typing over a selection or\n            // backspacing out a single character text node) call the\n            // observer callback before actually updating the DOM\n            if (browser.ie && browser.ie_version <= 11 &&\n                mutations.some(m => m.type == \"childList\" && m.removedNodes.length ||\n                    m.type == \"characterData\" && m.oldValue.length > m.target.nodeValue.length))\n                this.flushSoon();\n            else\n                this.flush();\n        });\n        if (useCharData)\n            this.onCharData = (event) => {\n                this.queue.push({ target: event.target,\n                    type: \"characterData\",\n                    oldValue: event.prevValue });\n                this.flushSoon();\n            };\n        this.onSelectionChange = (event) => {\n            if (this.view.root.activeElement != this.dom)\n                return;\n            let sel = getSelection(this.view.root);\n            let context = sel.anchorNode && this.view.docView.nearest(sel.anchorNode);\n            if (context && context.ignoreEvent(event))\n                return;\n            // Deletions on IE11 fire their events in the wrong order, giving\n            // us a selection change event before the DOM changes are\n            // reported.\n            // (Selection.isCollapsed isn't reliable on IE)\n            if (browser.ie && browser.ie_version <= 11 && !this.view.state.selection.main.empty &&\n                sel.focusNode && isEquivalentPosition(sel.focusNode, sel.focusOffset, sel.anchorNode, sel.anchorOffset))\n                this.flushSoon();\n            else\n                this.flush();\n        };\n        this.start();\n        this.onScroll = this.onScroll.bind(this);\n        window.addEventListener(\"scroll\", this.onScroll);\n        if (typeof IntersectionObserver == \"function\") {\n            this.intersection = new IntersectionObserver(entries => {\n                if (this.parentCheck < 0)\n                    this.parentCheck = setTimeout(this.listenForScroll.bind(this), 1000);\n                if (entries[entries.length - 1].intersectionRatio > 0 != this.intersecting) {\n                    this.intersecting = !this.intersecting;\n                    this.onScrollChanged(document.createEvent(\"Event\"));\n                }\n            }, {});\n            this.intersection.observe(this.dom);\n        }\n        this.listenForScroll();\n    }\n    onScroll(e) {\n        if (this.intersecting) {\n            this.flush();\n            this.onScrollChanged(e);\n        }\n    }\n    listenForScroll() {\n        this.parentCheck = -1;\n        let i = 0, changed = null;\n        for (let dom = this.dom; dom;) {\n            if (dom.nodeType == 1) {\n                if (!changed && i < this.scrollTargets.length && this.scrollTargets[i] == dom)\n                    i++;\n                else if (!changed)\n                    changed = this.scrollTargets.slice(0, i);\n                if (changed)\n                    changed.push(dom);\n                dom = dom.parentNode;\n            }\n            else if (dom.nodeType == 11) { // Shadow root\n                dom = dom.host;\n            }\n            else {\n                break;\n            }\n        }\n        if (i < this.scrollTargets.length && !changed)\n            changed = this.scrollTargets.slice(0, i);\n        if (changed) {\n            for (let dom of this.scrollTargets)\n                dom.removeEventListener(\"scroll\", this.onScroll);\n            for (let dom of this.scrollTargets = changed)\n                dom.addEventListener(\"scroll\", this.onScroll);\n        }\n    }\n    ignore(f) {\n        if (!this.active)\n            return f();\n        try {\n            this.stop();\n            return f();\n        }\n        finally {\n            this.start();\n            this.clear();\n        }\n    }\n    start() {\n        if (this.active)\n            return;\n        this.observer.observe(this.dom, observeOptions);\n        this.dom.ownerDocument.addEventListener(\"selectionchange\", this.onSelectionChange);\n        if (useCharData)\n            this.dom.addEventListener(\"DOMCharacterDataModified\", this.onCharData);\n        this.active = true;\n    }\n    stop() {\n        if (!this.active)\n            return;\n        this.active = false;\n        this.observer.disconnect();\n        this.dom.ownerDocument.removeEventListener(\"selectionchange\", this.onSelectionChange);\n        if (useCharData)\n            this.dom.removeEventListener(\"DOMCharacterDataModified\", this.onCharData);\n    }\n    clearSelection() {\n        this.ignoreSelection.set(getSelection(this.view.root));\n    }\n    // Throw away any pending changes\n    clear() {\n        this.observer.takeRecords();\n        this.queue.length = 0;\n        this.clearSelection();\n    }\n    flushSoon() {\n        if (this.delayedFlush < 0)\n            this.delayedFlush = window.setTimeout(() => { this.delayedFlush = -1; this.flush(); }, 20);\n    }\n    forceFlush() {\n        if (this.delayedFlush >= 0) {\n            window.clearTimeout(this.delayedFlush);\n            this.delayedFlush = -1;\n            this.flush();\n        }\n    }\n    // Apply pending changes, if any\n    flush() {\n        if (this.delayedFlush >= 0)\n            return;\n        let records = this.queue;\n        for (let mut of this.observer.takeRecords())\n            records.push(mut);\n        if (records.length)\n            this.queue = [];\n        let selection = getSelection(this.view.root);\n        let newSel = !this.ignoreSelection.eq(selection) && hasSelection(this.dom, selection);\n        if (records.length == 0 && !newSel)\n            return;\n        let from = -1, to = -1, typeOver = false;\n        for (let record of records) {\n            let range = this.readMutation(record);\n            if (!range)\n                continue;\n            if (range.typeOver)\n                typeOver = true;\n            if (from == -1) {\n                ({ from, to } = range);\n            }\n            else {\n                from = Math.min(range.from, from);\n                to = Math.max(range.to, to);\n            }\n        }\n        let startState = this.view.state;\n        if (from > -1 || newSel)\n            this.onChange(from, to, typeOver);\n        if (this.view.state == startState) { // The view wasn't updated\n            if (this.view.docView.dirty) {\n                this.ignore(() => this.view.docView.sync());\n                this.view.docView.dirty = 0 /* Not */;\n            }\n            this.view.docView.updateSelection();\n        }\n        this.clearSelection();\n    }\n    readMutation(rec) {\n        let cView = this.view.docView.nearest(rec.target);\n        if (!cView || cView.ignoreMutation(rec))\n            return null;\n        cView.markDirty();\n        if (rec.type == \"childList\") {\n            let childBefore = findChild(cView, rec.previousSibling || rec.target.previousSibling, -1);\n            let childAfter = findChild(cView, rec.nextSibling || rec.target.nextSibling, 1);\n            return { from: childBefore ? cView.posAfter(childBefore) : cView.posAtStart,\n                to: childAfter ? cView.posBefore(childAfter) : cView.posAtEnd, typeOver: false };\n        }\n        else { // \"characterData\"\n            return { from: cView.posAtStart, to: cView.posAtEnd, typeOver: rec.target.nodeValue == rec.oldValue };\n        }\n    }\n    destroy() {\n        this.stop();\n        if (this.intersection)\n            this.intersection.disconnect();\n        for (let dom of this.scrollTargets)\n            dom.removeEventListener(\"scroll\", this.onScroll);\n        window.removeEventListener(\"scroll\", this.onScroll);\n        clearTimeout(this.parentCheck);\n    }\n}\nfunction findChild(cView, dom, dir) {\n    while (dom) {\n        let curView = ContentView.get(dom);\n        if (curView && curView.parent == cView)\n            return curView;\n        let parent = dom.parentNode;\n        dom = parent != cView.dom ? parent : dir > 0 ? dom.nextSibling : dom.previousSibling;\n    }\n    return null;\n}\n\nfunction applyDOMChange(view, start, end, typeOver) {\n    let change, newSel;\n    let sel = view.state.selection.main, bounds;\n    if (start > -1 && (bounds = view.docView.domBoundsAround(start, end, 0))) {\n        let { from, to } = bounds;\n        let selPoints = view.docView.impreciseHead || view.docView.impreciseAnchor ? [] : selectionPoints(view.contentDOM, view.root);\n        let reader = new DOMReader(selPoints, view.state.lineBreak);\n        reader.readRange(bounds.startDOM, bounds.endDOM);\n        newSel = selectionFromPoints(selPoints, from);\n        let preferredPos = sel.from, preferredSide = null;\n        // Prefer anchoring to end when Backspace is pressed\n        if (view.inputState.lastKeyCode === 8 && view.inputState.lastKeyTime > Date.now() - 100) {\n            preferredPos = sel.to;\n            preferredSide = \"end\";\n        }\n        let diff = findDiff(view.state.sliceDoc(from, to), reader.text, preferredPos - from, preferredSide);\n        if (diff)\n            change = { from: from + diff.from, to: from + diff.toA,\n                insert: view.state.toText(reader.text.slice(diff.from, diff.toB)) };\n    }\n    else if (view.hasFocus) {\n        let domSel = getSelection(view.root);\n        let { impreciseHead: iHead, impreciseAnchor: iAnchor } = view.docView;\n        let head = iHead && iHead.node == domSel.focusNode && iHead.offset == domSel.focusOffset ? view.state.selection.main.head\n            : view.docView.posFromDOM(domSel.focusNode, domSel.focusOffset);\n        let anchor = iAnchor && iAnchor.node == domSel.anchorNode && iAnchor.offset == domSel.anchorOffset\n            ? view.state.selection.main.anchor\n            : selectionCollapsed(domSel) ? head : view.docView.posFromDOM(domSel.anchorNode, domSel.anchorOffset);\n        if (head != sel.head || anchor != sel.anchor)\n            newSel = EditorSelection.single(anchor, head);\n    }\n    if (!change && !newSel)\n        return;\n    // Heuristic to notice typing over a selected character\n    if (!change && typeOver && !sel.empty && newSel && newSel.main.empty)\n        change = { from: sel.from, to: sel.to, insert: view.state.doc.slice(sel.from, sel.to) };\n    if (change) {\n        let startState = view.state;\n        // Android browsers don't fire reasonable key events for enter,\n        // backspace, or delete. So this detects changes that look like\n        // they're caused by those keys, and reinterprets them as key\n        // events.\n        if (browser.android &&\n            ((change.from == sel.from && change.to == sel.to &&\n                change.insert.length == 1 && change.insert.lines == 2 &&\n                dispatchKey(view, \"Enter\", 10)) ||\n                (change.from == sel.from - 1 && change.to == sel.to && change.insert.length == 0 &&\n                    dispatchKey(view, \"Backspace\", 8)) ||\n                (change.from == sel.from && change.to == sel.to + 1 && change.insert.length == 0 &&\n                    dispatchKey(view, \"Delete\", 46))))\n            return;\n        let text = change.insert.toString();\n        if (view.state.facet(inputHandler).some(h => h(view, change.from, change.to, text)))\n            return;\n        let tr;\n        if (change.from >= sel.from && change.to <= sel.to && change.to - change.from >= (sel.to - sel.from) / 3) {\n            let before = sel.from < change.from ? startState.sliceDoc(sel.from, change.from) : \"\";\n            let after = sel.to > change.to ? startState.sliceDoc(change.to, sel.to) : \"\";\n            tr = startState.replaceSelection(view.state.toText(before + change.insert.sliceString(0, undefined, view.state.lineBreak) +\n                after));\n        }\n        else {\n            let changes = startState.changes(change);\n            tr = {\n                changes,\n                selection: newSel && !startState.selection.main.eq(newSel.main) && newSel.main.to <= changes.newLength\n                    ? startState.selection.replaceRange(newSel.main) : undefined\n            };\n        }\n        view.dispatch(tr, { scrollIntoView: true, annotations: Transaction.userEvent.of(\"input\") });\n    }\n    else if (newSel && !newSel.main.eq(sel)) {\n        let scrollIntoView = false, annotations;\n        if (view.inputState.lastSelectionTime > Date.now() - 50) {\n            if (view.inputState.lastSelectionOrigin == \"keyboardselection\")\n                scrollIntoView = true;\n            else\n                annotations = Transaction.userEvent.of(view.inputState.lastSelectionOrigin);\n        }\n        view.dispatch({ selection: newSel, scrollIntoView, annotations });\n    }\n}\nfunction findDiff(a, b, preferredPos, preferredSide) {\n    let minLen = Math.min(a.length, b.length);\n    let from = 0;\n    while (from < minLen && a.charCodeAt(from) == b.charCodeAt(from))\n        from++;\n    if (from == minLen && a.length == b.length)\n        return null;\n    let toA = a.length, toB = b.length;\n    while (toA > 0 && toB > 0 && a.charCodeAt(toA - 1) == b.charCodeAt(toB - 1)) {\n        toA--;\n        toB--;\n    }\n    if (preferredSide == \"end\") {\n        let adjust = Math.max(0, from - Math.min(toA, toB));\n        preferredPos -= toA + adjust - from;\n    }\n    if (toA < from && a.length < b.length) {\n        let move = preferredPos <= from && preferredPos >= toA ? from - preferredPos : 0;\n        from -= move;\n        toB = from + (toB - toA);\n        toA = from;\n    }\n    else if (toB < from) {\n        let move = preferredPos <= from && preferredPos >= toB ? from - preferredPos : 0;\n        from -= move;\n        toA = from + (toA - toB);\n        toB = from;\n    }\n    return { from, toA, toB };\n}\nclass DOMReader {\n    constructor(points, lineSep) {\n        this.points = points;\n        this.lineSep = lineSep;\n        this.text = \"\";\n    }\n    readRange(start, end) {\n        if (!start)\n            return;\n        let parent = start.parentNode;\n        for (let cur = start;;) {\n            this.findPointBefore(parent, cur);\n            this.readNode(cur);\n            let next = cur.nextSibling;\n            if (next == end)\n                break;\n            let view = ContentView.get(cur), nextView = ContentView.get(next);\n            if ((view ? view.breakAfter : isBlockElement(cur)) ||\n                ((nextView ? nextView.breakAfter : isBlockElement(next)) && !(cur.nodeName == \"BR\" && !cur.cmIgnore)))\n                this.text += this.lineSep;\n            cur = next;\n        }\n        this.findPointBefore(parent, end);\n    }\n    readNode(node) {\n        if (node.cmIgnore)\n            return;\n        let view = ContentView.get(node);\n        let fromView = view && view.overrideDOMText;\n        let text;\n        if (fromView != null)\n            text = fromView.sliceString(0, undefined, this.lineSep);\n        else if (node.nodeType == 3)\n            text = node.nodeValue;\n        else if (node.nodeName == \"BR\")\n            text = node.nextSibling ? this.lineSep : \"\";\n        else if (node.nodeType == 1)\n            this.readRange(node.firstChild, null);\n        if (text != null) {\n            this.findPointIn(node, text.length);\n            this.text += text;\n        }\n    }\n    findPointBefore(node, next) {\n        for (let point of this.points)\n            if (point.node == node && node.childNodes[point.offset] == next)\n                point.pos = this.text.length;\n    }\n    findPointIn(node, maxLen) {\n        for (let point of this.points)\n            if (point.node == node)\n                point.pos = this.text.length + Math.min(point.offset, maxLen);\n    }\n}\nfunction isBlockElement(node) {\n    return node.nodeType == 1 && /^(DIV|P|LI|UL|OL|BLOCKQUOTE|DD|DT|H\\d|SECTION|PRE)$/.test(node.nodeName);\n}\nclass DOMPoint {\n    constructor(node, offset) {\n        this.node = node;\n        this.offset = offset;\n        this.pos = -1;\n    }\n}\nfunction selectionPoints(dom, root) {\n    let result = [];\n    if (root.activeElement != dom)\n        return result;\n    let { anchorNode, anchorOffset, focusNode, focusOffset } = getSelection(root);\n    if (anchorNode) {\n        result.push(new DOMPoint(anchorNode, anchorOffset));\n        if (focusNode != anchorNode || focusOffset != anchorOffset)\n            result.push(new DOMPoint(focusNode, focusOffset));\n    }\n    return result;\n}\nfunction selectionFromPoints(points, base) {\n    if (points.length == 0)\n        return null;\n    let anchor = points[0].pos, head = points.length == 2 ? points[1].pos : anchor;\n    return anchor > -1 && head > -1 ? EditorSelection.single(anchor + base, head + base) : null;\n}\nfunction dispatchKey(view, name, code) {\n    let options = { key: name, code: name, keyCode: code, which: code, cancelable: true };\n    let down = new KeyboardEvent(\"keydown\", options);\n    view.contentDOM.dispatchEvent(down);\n    let up = new KeyboardEvent(\"keyup\", options);\n    view.contentDOM.dispatchEvent(up);\n    return down.defaultPrevented || up.defaultPrevented;\n}\n\n// The editor's update state machine looks something like this:\n//\n//     Idle → Updating ⇆ Idle (unchecked) → Measuring → Idle\n//                                         ↑      ↓\n//                                         Updating (measure)\n//\n// The difference between 'Idle' and 'Idle (unchecked)' lies in\n// whether a layout check has been scheduled. A regular update through\n// the `update` method updates the DOM in a write-only fashion, and\n// relies on a check (scheduled with `requestAnimationFrame`) to make\n// sure everything is where it should be and the viewport covers the\n// visible code. That check continues to measure and then optionally\n// update until it reaches a coherent state.\n/// An editor view represents the editor's user interface. It holds\n/// the editable DOM surface, and possibly other elements such as the\n/// line number gutter. It handles events and dispatches state\n/// transactions for editing actions.\nclass EditorView {\n    /// Construct a new view. You'll usually want to put `view.dom` into\n    /// your document after creating a view, so that the user can see\n    /// it.\n    constructor(\n    /// Initialization options.\n    config = {}) {\n        this.plugins = [];\n        this.editorAttrs = {};\n        this.contentAttrs = {};\n        this.bidiCache = [];\n        /// @internal\n        this.updateState = 2 /* Updating */;\n        /// @internal\n        this.measureScheduled = -1;\n        /// @internal\n        this.measureRequests = [];\n        this.contentDOM = document.createElement(\"div\");\n        this.scrollDOM = document.createElement(\"div\");\n        this.scrollDOM.className = themeClass(\"scroller\");\n        this.scrollDOM.appendChild(this.contentDOM);\n        this.dom = document.createElement(\"div\");\n        this.dom.appendChild(this.scrollDOM);\n        this._dispatch = config.dispatch || ((tr) => this.update([tr]));\n        this.dispatch = this.dispatch.bind(this);\n        this.root = (config.root || document);\n        this.viewState = new ViewState(config.state || EditorState.create());\n        this.plugins = this.state.facet(viewPlugin).map(spec => new PluginInstance(spec).update(this));\n        this.observer = new DOMObserver(this, (from, to, typeOver) => {\n            applyDOMChange(this, from, to, typeOver);\n        }, event => {\n            this.inputState.runScrollHandlers(this, event);\n            this.measure();\n        });\n        this.docView = new DocView(this);\n        this.inputState = new InputState(this);\n        this.mountStyles();\n        this.updateAttrs();\n        this.updateState = 0 /* Idle */;\n        ensureGlobalHandler();\n        this.requestMeasure();\n        if (config.parent)\n            config.parent.appendChild(this.dom);\n    }\n    /// The current editor state.\n    get state() { return this.viewState.state; }\n    /// To be able to display large documents without consuming too much\n    /// memory or overloading the browser, CodeMirror only draws the\n    /// code that is visible (plus a margin around it) to the DOM. This\n    /// property tells you the extent of the current drawn viewport, in\n    /// document positions.\n    get viewport() { return this.viewState.viewport; }\n    /// When there are, for example, large collapsed ranges in the\n    /// viewport, its size can be a lot bigger than the actual visible\n    /// content. Thus, if you are doing something like styling the\n    /// content in the viewport, it is preferable to only do so for\n    /// these ranges, which are the subset of the viewport that is\n    /// actually drawn.\n    get visibleRanges() { return this.viewState.visibleRanges; }\n    /// Returns false when the editor is entirely scrolled out of view\n    /// or otherwise hidden.\n    get inView() { return this.viewState.inView; }\n    /// Indicates whether the user is currently composing text via\n    /// [IME](https://developer.mozilla.org/en-US/docs/Mozilla/IME_handling_guide).\n    get composing() { return this.inputState.composing; }\n    dispatch(...input) {\n        this._dispatch(input.length == 1 && input[0] instanceof Transaction ? input[0]\n            : this.state.update(...input));\n    }\n    /// Update the view for the given array of transactions. This will\n    /// update the visible document and selection to match the state\n    /// produced by the transactions, and notify view plugins of the\n    /// change. You should usually call\n    /// [`dispatch`](#view.EditorView.dispatch) instead, which uses this\n    /// as a primitive.\n    update(transactions) {\n        if (this.updateState != 0 /* Idle */)\n            throw new Error(\"Calls to EditorView.update are not allowed while an update is in progress\");\n        let redrawn = false, update;\n        this.updateState = 2 /* Updating */;\n        try {\n            let state = this.state;\n            for (let tr of transactions) {\n                if (tr.startState != state)\n                    throw new RangeError(\"Trying to update state with a transaction that doesn't start from the previous state.\");\n                state = tr.state;\n            }\n            update = new ViewUpdate(this, state, transactions);\n            let scrollTo = transactions.some(tr => tr.scrollIntoView) ? state.selection.main : null;\n            this.viewState.update(update, scrollTo);\n            this.bidiCache = CachedOrder.update(this.bidiCache, update.changes);\n            if (!update.empty)\n                this.updatePlugins(update);\n            redrawn = this.docView.update(update);\n            if (this.state.facet(styleModule) != this.styleModules)\n                this.mountStyles();\n            this.updateAttrs();\n        }\n        finally {\n            this.updateState = 0 /* Idle */;\n        }\n        if (redrawn || scrollTo || this.viewState.mustEnforceCursorAssoc)\n            this.requestMeasure();\n        for (let listener of this.state.facet(updateListener))\n            listener(update);\n    }\n    /// Reset the view to the given state. (This will cause the entire\n    /// document to be redrawn and all view plugins to be reinitialized,\n    /// so you should probably only use it when the new state isn't\n    /// derived from the old state. Otherwise, use\n    /// [`dispatch`](#view.EditorView.dispatch) instead.)\n    setState(newState) {\n        if (this.updateState != 0 /* Idle */)\n            throw new Error(\"Calls to EditorView.setState are not allowed while an update is in progress\");\n        this.updateState = 2 /* Updating */;\n        try {\n            for (let plugin of this.plugins)\n                plugin.destroy(this);\n            this.viewState = new ViewState(newState);\n            this.plugins = newState.facet(viewPlugin).map(spec => new PluginInstance(spec).update(this));\n            this.docView = new DocView(this);\n            this.inputState.ensureHandlers(this);\n            this.mountStyles();\n            this.updateAttrs();\n            this.bidiCache = [];\n        }\n        finally {\n            this.updateState = 0 /* Idle */;\n        }\n        this.requestMeasure();\n    }\n    updatePlugins(update) {\n        let prevSpecs = update.startState.facet(viewPlugin), specs = update.state.facet(viewPlugin);\n        if (prevSpecs != specs) {\n            let newPlugins = [];\n            for (let spec of specs) {\n                let found = prevSpecs.indexOf(spec);\n                if (found < 0) {\n                    newPlugins.push(new PluginInstance(spec));\n                }\n                else {\n                    let plugin = this.plugins[found];\n                    plugin.mustUpdate = update;\n                    newPlugins.push(plugin);\n                }\n            }\n            for (let plugin of this.plugins)\n                if (plugin.mustUpdate != update)\n                    plugin.destroy(this);\n            this.plugins = newPlugins;\n            this.inputState.ensureHandlers(this);\n        }\n        else {\n            for (let p of this.plugins)\n                p.mustUpdate = update;\n        }\n        for (let i = 0; i < this.plugins.length; i++)\n            this.plugins[i] = this.plugins[i].update(this);\n    }\n    /// @internal\n    measure() {\n        if (this.measureScheduled > -1)\n            cancelAnimationFrame(this.measureScheduled);\n        this.measureScheduled = -1; // Prevent requestMeasure calls from scheduling another animation frame\n        let updated = null;\n        try {\n            for (let i = 0;; i++) {\n                this.updateState = 1 /* Measuring */;\n                let changed = this.viewState.measure(this.docView, i > 0);\n                let measuring = this.measureRequests;\n                if (!changed && !measuring.length && this.viewState.scrollTo == null)\n                    break;\n                this.measureRequests = [];\n                if (i > 5) {\n                    console.warn(\"Viewport failed to stabilize\");\n                    break;\n                }\n                let measured = measuring.map(m => {\n                    try {\n                        return m.read(this);\n                    }\n                    catch (e) {\n                        logException(this.state, e);\n                        return BadMeasure;\n                    }\n                });\n                let update = new ViewUpdate(this, this.state);\n                update.flags |= changed;\n                if (!updated)\n                    updated = update;\n                else\n                    updated.flags |= changed;\n                this.updateState = 2 /* Updating */;\n                this.updatePlugins(update);\n                this.updateAttrs();\n                if (changed)\n                    this.docView.update(update);\n                for (let i = 0; i < measuring.length; i++)\n                    if (measured[i] != BadMeasure) {\n                        try {\n                            measuring[i].write(measured[i], this);\n                        }\n                        catch (e) {\n                            logException(this.state, e);\n                        }\n                    }\n                if (this.viewState.scrollTo) {\n                    this.docView.scrollPosIntoView(this.viewState.scrollTo.head, this.viewState.scrollTo.assoc);\n                    this.viewState.scrollTo = null;\n                }\n                if (!(changed & 4 /* Viewport */) && this.measureRequests.length == 0)\n                    break;\n            }\n        }\n        finally {\n            this.updateState = 0 /* Idle */;\n        }\n        this.measureScheduled = -1;\n        if (updated)\n            for (let listener of this.state.facet(updateListener))\n                listener(updated);\n    }\n    /// Get the CSS classes for the currently active editor themes.\n    get themeClasses() {\n        return baseThemeID + \" \" +\n            (this.state.facet(darkTheme) ? \"cm-dark\" : \"cm-light\") + \" \" +\n            this.state.facet(theme);\n    }\n    updateAttrs() {\n        let editorAttrs = combineAttrs(this.state.facet(editorAttributes), {\n            class: themeClass(\"wrap\") + (this.hasFocus ? \" cm-focused \" : \" \") + this.themeClasses\n        });\n        updateAttrs(this.dom, this.editorAttrs, editorAttrs);\n        this.editorAttrs = editorAttrs;\n        let contentAttrs = combineAttrs(this.state.facet(contentAttributes), {\n            spellcheck: \"false\",\n            contenteditable: String(this.state.facet(editable)),\n            class: themeClass(\"content\"),\n            style: `${browser.tabSize}: ${this.state.tabSize}`,\n            role: \"textbox\",\n            \"aria-multiline\": \"true\"\n        });\n        updateAttrs(this.contentDOM, this.contentAttrs, contentAttrs);\n        this.contentAttrs = contentAttrs;\n    }\n    mountStyles() {\n        this.styleModules = this.state.facet(styleModule);\n        StyleModule.mount(this.root, this.styleModules.concat(baseTheme).reverse());\n    }\n    readMeasured() {\n        if (this.updateState == 2 /* Updating */)\n            throw new Error(\"Reading the editor layout isn't allowed during an update\");\n        if (this.updateState == 0 /* Idle */ && this.measureScheduled > -1)\n            this.measure();\n    }\n    /// Make sure plugins get a chance to measure the DOM layout before\n    /// the next frame. Calling this is preferable reading DOM layout\n    /// directly from, for example, an even handler, because it'll make\n    /// sure measuring and drawing done by other components is\n    /// synchronized, avoiding unnecessary DOM layout computations.\n    requestMeasure(request) {\n        if (this.measureScheduled < 0)\n            this.measureScheduled = requestAnimationFrame(() => this.measure());\n        if (request) {\n            if (request.key != null)\n                for (let i = 0; i < this.measureRequests.length; i++) {\n                    if (this.measureRequests[i].key === request.key) {\n                        this.measureRequests[i] = request;\n                        return;\n                    }\n                }\n            this.measureRequests.push(request);\n        }\n    }\n    /// Collect all values provided by the active plugins for a given\n    /// field.\n    pluginField(field) {\n        let result = [];\n        for (let plugin of this.plugins)\n            plugin.update(this).takeField(field, result);\n        return result;\n    }\n    /// Get the value of a specific plugin, if present. Note that\n    /// plugins that crash can be dropped from a view, so even when you\n    /// know you registered a given plugin, it is recommended to check\n    /// the return value of this method.\n    plugin(plugin) {\n        for (let inst of this.plugins)\n            if (inst.spec == plugin)\n                return inst.update(this).value;\n        return null;\n    }\n    /// Find the line or block widget at the given vertical position.\n    /// `editorTop`, if given, provides the vertical position of the top\n    /// of the editor. It defaults to the editor's screen position\n    /// (which will force a DOM layout). You can explicitly pass 0 to\n    /// use editor-relative offsets.\n    blockAtHeight(height, editorTop) {\n        this.readMeasured();\n        return this.viewState.blockAtHeight(height, ensureTop(editorTop, this.contentDOM));\n    }\n    /// Find information for the visual line (see\n    /// [`visualLineAt`](#view.EditorView.visualLineAt)) at the given\n    /// vertical position. The resulting block info might hold another\n    /// array of block info structs in its `type` field if this line\n    /// consists of more than one block.\n    ///\n    /// Heights are interpreted relative to the given `editorTop`\n    /// position. When not given, the top position of the editor's\n    /// [content element](#view.EditorView.contentDOM) is taken.\n    visualLineAtHeight(height, editorTop) {\n        this.readMeasured();\n        return this.viewState.lineAtHeight(height, ensureTop(editorTop, this.contentDOM));\n    }\n    /// Iterate over the height information of the visual lines in the\n    /// viewport.\n    viewportLines(f, editorTop) {\n        let { from, to } = this.viewport;\n        this.viewState.forEachLine(from, to, f, ensureTop(editorTop, this.contentDOM));\n    }\n    /// Find the extent and height of the visual line (the content shown\n    /// in the editor as a line, which may be smaller than a document\n    /// line when broken up by block widgets, or bigger than a document\n    /// line when line breaks are covered by replaced decorations) at\n    /// the given position.\n    ///\n    /// Vertical positions are computed relative to the `editorTop`\n    /// argument, which defaults to 0 for this method. You can pass\n    /// `view.contentDOM.getBoundingClientRect().top` here to get screen\n    /// coordinates.\n    visualLineAt(pos, editorTop = 0) {\n        return this.viewState.lineAt(pos, editorTop);\n    }\n    /// The editor's total content height.\n    get contentHeight() {\n        return this.viewState.heightMap.height + this.viewState.paddingTop + this.viewState.paddingBottom;\n    }\n    /// Move a cursor position by [grapheme\n    /// cluster](#text.findClusterBreak). `forward` determines whether\n    /// the motion is away from the line start, or towards it. Motion in\n    /// bidirectional text is in visual order, in the editor's [text\n    /// direction](#view.EditorView.textDirection). When the start\n    /// position was the last one on the line, the returned position\n    /// will be across the line break. If there is no further line, the\n    /// original position is returned.\n    ///\n    /// By default, this method moves over a single cluster. The\n    /// optional `by` argument can be used to move across more. It will\n    /// be called with the first cluster as argument, and should return\n    /// a predicate that determines, for each subsequent cluster,\n    /// whether it should also be moved over.\n    moveByChar(start, forward, by) {\n        return moveByChar(this, start, forward, by);\n    }\n    /// Move a cursor position across the next group of either\n    /// [letters](#state.EditorState.charCategorizer) or non-letter\n    /// non-whitespace characters.\n    moveByGroup(start, forward) {\n        return moveByChar(this, start, forward, initial => byGroup(this, start.head, initial));\n    }\n    /// Move to the next line boundary in the given direction. If\n    /// `includeWrap` is true, line wrapping is on, and there is a\n    /// further wrap point on the current line, the wrap point will be\n    /// returned. Otherwise this function will return the start or end\n    /// of the line.\n    moveToLineBoundary(start, forward, includeWrap = true) {\n        return moveToLineBoundary(this, start, forward, includeWrap);\n    }\n    /// Move a cursor position vertically. When `distance` isn't given,\n    /// it defaults to moving to the next line (including wrapped\n    /// lines). Otherwise, `distance` should provide a positive distance\n    /// in pixels.\n    ///\n    /// When `start` has a\n    /// [`goalColumn`](#state.SelectionRange.goalColumn), the vertical\n    /// motion will use that as a target horizontal position. Otherwise,\n    /// the cursor's own horizontal position is used. The returned\n    /// cursor will have its goal column set to whichever column was\n    /// used.\n    moveVertically(start, forward, distance) {\n        return moveVertically(this, start, forward, distance);\n    }\n    /// Scroll the given document position into view.\n    scrollPosIntoView(pos) {\n        this.viewState.scrollTo = EditorSelection.cursor(pos);\n        this.requestMeasure();\n    }\n    /// Find the DOM parent node and offset (child offset if `node` is\n    /// an element, character offset when it is a text node) at the\n    /// given document position.\n    domAtPos(pos) {\n        return this.docView.domAtPos(pos);\n    }\n    /// Find the document position at the given DOM node. Can be useful\n    /// for associating positions with DOM events. Will raise an error\n    /// when `node` isn't part of the editor content.\n    posAtDOM(node, offset = 0) {\n        return this.docView.posFromDOM(node, offset);\n    }\n    /// Get the document position at the given screen coordinates.\n    /// Returns null if no valid position could be found.\n    posAtCoords(coords) {\n        this.readMeasured();\n        return posAtCoords(this, coords);\n    }\n    /// Get the screen coordinates at the given document position.\n    /// `side` determines whether the coordinates are based on the\n    /// element before (-1) or after (1) the position (if no element is\n    /// available on the given side, the method will transparently use\n    /// another strategy to get reasonable coordinates).\n    coordsAtPos(pos, side = 1) {\n        this.readMeasured();\n        let rect = this.docView.coordsAt(pos, side);\n        if (!rect || rect.left == rect.right)\n            return rect;\n        let line = this.state.doc.lineAt(pos), order = this.bidiSpans(line);\n        let span = order[BidiSpan.find(order, pos - line.from, -1, side)];\n        return flattenRect(rect, (span.dir == Direction.LTR) == (side > 0));\n    }\n    /// The default width of a character in the editor. May not\n    /// accurately reflect the width of all characters (given variable\n    /// width fonts or styling of invididual ranges).\n    get defaultCharacterWidth() { return this.viewState.heightOracle.charWidth; }\n    /// The default height of a line in the editor. May not be accurate\n    /// for all lines.\n    get defaultLineHeight() { return this.viewState.heightOracle.lineHeight; }\n    /// The text direction\n    /// ([`direction`](https://developer.mozilla.org/en-US/docs/Web/CSS/direction)\n    /// CSS property) of the editor.\n    get textDirection() { return this.viewState.heightOracle.direction; }\n    /// Whether this editor [wraps lines](#view.EditorView.lineWrapping)\n    /// (as determined by the\n    /// [`white-space`](https://developer.mozilla.org/en-US/docs/Web/CSS/white-space)\n    /// CSS property of its content element).\n    get lineWrapping() { return this.viewState.heightOracle.lineWrapping; }\n    /// Returns the bidirectional text structure of the given line\n    /// (which should be in the current document) as an array of span\n    /// objects. The order of these spans matches the [text\n    /// direction](#view.EditorView.textDirection)—if that is\n    /// left-to-right, the leftmost spans come first, otherwise the\n    /// rightmost spans come first.\n    bidiSpans(line) {\n        if (line.length > MaxBidiLine)\n            return trivialOrder(line.length);\n        let dir = this.textDirection;\n        for (let entry of this.bidiCache)\n            if (entry.from == line.from && entry.dir == dir)\n                return entry.order;\n        let order = computeOrder(line.text, this.textDirection);\n        this.bidiCache.push(new CachedOrder(line.from, line.to, dir, order));\n        return order;\n    }\n    /// Check whether the editor has focus.\n    get hasFocus() {\n        return document.hasFocus() && this.root.activeElement == this.contentDOM;\n    }\n    /// Put focus on the editor.\n    focus() {\n        this.observer.ignore(() => {\n            focusPreventScroll(this.contentDOM);\n            this.docView.updateSelection();\n        });\n    }\n    /// Clean up this editor view, removing its element from the\n    /// document, unregistering event handlers, and notifying\n    /// plugins. The view instance can no longer be used after\n    /// calling this.\n    destroy() {\n        for (let plugin of this.plugins)\n            plugin.destroy(this);\n        this.inputState.destroy();\n        this.dom.remove();\n        this.observer.destroy();\n        if (this.measureScheduled > -1)\n            cancelAnimationFrame(this.measureScheduled);\n    }\n    /// Facet that can be used to add DOM event handlers. The value\n    /// should be an object mapping event names to handler functions. The\n    /// first such function to return true will be assumed to have handled\n    /// that event, and no other handlers or built-in behavior will be\n    /// activated for it.\n    /// These are registered on the [content\n    /// element](#view.EditorView.contentDOM), except for `scroll`\n    /// handlers, which will be called any time the editor's [scroll\n    /// element](#view.EditorView.scrollDOM) or one of its parent nodes\n    /// is scrolled.\n    static domEventHandlers(handlers) {\n        return ViewPlugin.define(() => ({}), { eventHandlers: handlers });\n    }\n    /// Create a theme extension. The first argument can be a\n    /// [`style-mod`](https://github.com/marijnh/style-mod#documentation)\n    /// style spec providing the styles for the theme. These will be\n    /// prefixed with a generated class for the style.\n    ///\n    /// It is highly recommended you use _theme classes_, rather than\n    /// regular CSS classes, in your selectors. These are prefixed with\n    /// a `$` instead of a `.`, and will be expanded (as with\n    /// [`themeClass`](#view.themeClass)) to one or more prefixed class\n    /// names. So for example `$content` targets the editor's [content\n    /// element](#view.EditorView.contentDOM).\n    ///\n    /// Because the selectors will be prefixed with a scope class,\n    /// directly matching the editor's [wrapper\n    /// element](#view.EditorView.dom), which is the element on which\n    /// the scope class will be added, needs to be explicitly\n    /// differentiated by adding an additional `$` to the front of the\n    /// pattern. For example `$$focused $panel` will expand to something\n    /// like `.[scope].cm-focused .cm-panel`.\n    ///\n    /// When `dark` is set to true, the theme will be marked as dark,\n    /// which will add the `$dark` selector to the wrapper element (as\n    /// opposed to `$light` when a light theme is active).\n    static theme(spec, options) {\n        let prefix = StyleModule.newName();\n        let result = [theme.of(prefix), styleModule.of(buildTheme(`.${baseThemeID}.${prefix}`, spec))];\n        if (options && options.dark)\n            result.push(darkTheme.of(true));\n        return result;\n    }\n    /// Create an extension that adds styles to the base theme. The\n    /// given object works much like the one passed to\n    /// [`theme`](#view.EditorView^theme). You'll often want to qualify\n    /// base styles with `$dark` or `$light` so they only apply when\n    /// there is a dark or light theme active. For example `\"$$dark\n    /// $myHighlight\"`.\n    static baseTheme(spec) {\n        return Prec.fallback(styleModule.of(buildTheme(\".\" + baseThemeID, spec)));\n    }\n}\n/// Facet to add a [style\n/// module](https://github.com/marijnh/style-mod#documentation) to\n/// an editor view. The view will ensure that the module is\n/// mounted in its [document\n/// root](#view.EditorView.constructor^config.root).\nEditorView.styleModule = styleModule;\n/// An input handler can override the way changes to the editable\n/// DOM content are handled. Handlers are passed the document\n/// positions between which the change was found, and the new\n/// content. When one returns true, no further input handlers are\n/// called and the default behavior is prevented.\nEditorView.inputHandler = inputHandler;\n/// Allows you to provide a function that should be called when the\n/// library catches an exception from an extension (mostly from view\n/// plugins, but may be used by other extensions to route exceptions\n/// from user-code-provided callbacks). This is mostly useful for\n/// debugging and logging. See [`logException`](#view.logException).\nEditorView.exceptionSink = exceptionSink;\n/// A facet that can be used to register a function to be called\n/// every time the view updates.\nEditorView.updateListener = updateListener;\n/// Facet that controls whether the editor content is editable. When\n/// its highest-precedence value is `false`, editing is disabled,\n/// and the content element will no longer have its\n/// `contenteditable` attribute set to `true`. (Note that this\n/// doesn't affect API calls that change the editor content, even\n/// when those are bound to keys or buttons.)\nEditorView.editable = editable;\n/// Allows you to influence the way mouse selection happens. The\n/// functions in this facet will be called for a `mousedown` event\n/// on the editor, and can return an object that overrides the way a\n/// selection is computed from that mouse click or drag.\nEditorView.mouseSelectionStyle = mouseSelectionStyle;\n/// Facet used to configure whether a given selection drag event\n/// should move or copy the selection. The given predicate will be\n/// called with the `mousedown` event, and can return `true` when\n/// the drag should move the content.\nEditorView.dragMovesSelection = dragMovesSelection;\n/// Facet used to configure whether a given selecting click adds\n/// a new range to the existing selection or replaces it entirely.\nEditorView.clickAddsSelectionRange = clickAddsSelectionRange;\n/// A facet that determines which [decorations](#view.Decoration)\n/// are shown in the view. See also [view\n/// plugins](#view.EditorView^decorations), which have a separate\n/// mechanism for providing decorations.\nEditorView.decorations = decorations;\n/// An extension that enables line wrapping in the editor (by\n/// setting CSS `white-space` to `pre-wrap` in the content).\nEditorView.lineWrapping = EditorView.theme({ $content: { whiteSpace: \"pre-wrap\" } });\n/// Facet that provides additional DOM attributes for the editor's\n/// editable DOM element.\nEditorView.contentAttributes = contentAttributes;\n/// Facet that provides DOM attributes for the editor's outer\n/// element.\nEditorView.editorAttributes = editorAttributes;\n// Maximum line length for which we compute accurate bidi info\nconst MaxBidiLine = 4096;\nfunction ensureTop(given, dom) {\n    return given == null ? dom.getBoundingClientRect().top : given;\n}\nlet resizeDebounce = -1;\nfunction ensureGlobalHandler() {\n    window.addEventListener(\"resize\", () => {\n        if (resizeDebounce == -1)\n            resizeDebounce = setTimeout(handleResize, 50);\n    });\n}\nfunction handleResize() {\n    resizeDebounce = -1;\n    let found = document.querySelectorAll(\".cm-content\");\n    for (let i = 0; i < found.length; i++) {\n        let docView = ContentView.get(found[i]);\n        if (docView)\n            docView.editorView.requestMeasure();\n    }\n}\nconst BadMeasure = {};\nclass CachedOrder {\n    constructor(from, to, dir, order) {\n        this.from = from;\n        this.to = to;\n        this.dir = dir;\n        this.order = order;\n    }\n    static update(cache, changes) {\n        if (changes.empty)\n            return cache;\n        let result = [], lastDir = cache.length ? cache[cache.length - 1].dir : Direction.LTR;\n        for (let i = Math.max(0, cache.length - 10); i < cache.length; i++) {\n            let entry = cache[i];\n            if (entry.dir == lastDir && !changes.touchesRange(entry.from, entry.to))\n                result.push(new CachedOrder(changes.mapPos(entry.from, 1), changes.mapPos(entry.to, -1), entry.dir, entry.order));\n        }\n        return result;\n    }\n}\n\nconst currentPlatform = typeof navigator == \"undefined\" ? \"key\"\n    : /Mac/.test(navigator.platform) ? \"mac\"\n        : /Win/.test(navigator.platform) ? \"win\"\n            : /Linux|X11/.test(navigator.platform) ? \"linux\"\n                : \"key\";\nfunction normalizeKeyName(name, platform) {\n    const parts = name.split(/-(?!$)/);\n    let result = parts[parts.length - 1];\n    if (result == \"Space\")\n        result = \" \";\n    let alt, ctrl, shift, meta;\n    for (let i = 0; i < parts.length - 1; ++i) {\n        const mod = parts[i];\n        if (/^(cmd|meta|m)$/i.test(mod))\n            meta = true;\n        else if (/^a(lt)?$/i.test(mod))\n            alt = true;\n        else if (/^(c|ctrl|control)$/i.test(mod))\n            ctrl = true;\n        else if (/^s(hift)?$/i.test(mod))\n            shift = true;\n        else if (/^mod$/i.test(mod)) {\n            if (platform == \"mac\")\n                meta = true;\n            else\n                ctrl = true;\n        }\n        else\n            throw new Error(\"Unrecognized modifier name: \" + mod);\n    }\n    if (alt)\n        result = \"Alt-\" + result;\n    if (ctrl)\n        result = \"Ctrl-\" + result;\n    if (meta)\n        result = \"Meta-\" + result;\n    if (shift)\n        result = \"Shift-\" + result;\n    return result;\n}\nfunction modifiers(name, event, shift) {\n    if (event.altKey)\n        name = \"Alt-\" + name;\n    if (event.ctrlKey)\n        name = \"Ctrl-\" + name;\n    if (event.metaKey)\n        name = \"Meta-\" + name;\n    if (shift !== false && event.shiftKey)\n        name = \"Shift-\" + name;\n    return name;\n}\nconst handleKeyEvents = EditorView.domEventHandlers({\n    keydown(event, view) {\n        return runHandlers(getKeymap(view.state), event, view, \"editor\");\n    }\n});\n/// Facet used for registering keymaps.\n///\n/// You can add multiple keymaps to an editor. Their priorities\n/// determine their precedence (the ones specified early or with high\n/// priority get checked first). When a handler has returned `true`\n/// for a given key, no further handlers are called.\nconst keymap = Facet.define({ enables: handleKeyEvents });\nconst Keymaps = new WeakMap();\n// This is hidden behind an indirection, rather than directly computed\n// by the facet, to keep internal types out of the facet's type.\nfunction getKeymap(state) {\n    let bindings = state.facet(keymap);\n    let map = Keymaps.get(bindings);\n    if (!map)\n        Keymaps.set(bindings, map = buildKeymap(bindings.reduce((a, b) => a.concat(b), [])));\n    return map;\n}\n/// Run the key handlers registered for a given scope. The event\n/// object should be `\"keydown\"` event. Returns true if any of the\n/// handlers handled it.\nfunction runScopeHandlers(view, event, scope) {\n    return runHandlers(getKeymap(view.state), event, view, scope);\n}\nlet storedPrefix = null;\nconst PrefixTimeout = 4000;\nfunction buildKeymap(bindings, platform = currentPlatform) {\n    let bound = Object.create(null);\n    let isPrefix = Object.create(null);\n    let checkPrefix = (name, is) => {\n        let current = isPrefix[name];\n        if (current == null)\n            isPrefix[name] = is;\n        else if (current != is)\n            throw new Error(\"Key binding \" + name + \" is used both as a regular binding and as a multi-stroke prefix\");\n    };\n    let add = (scope, key, command, preventDefault) => {\n        let scopeObj = bound[scope] || (bound[scope] = Object.create(null));\n        let parts = key.split(/ (?!$)/).map(k => normalizeKeyName(k, platform));\n        for (let i = 1; i < parts.length; i++) {\n            let prefix = parts.slice(0, i).join(\" \");\n            checkPrefix(prefix, true);\n            if (!scopeObj[prefix])\n                scopeObj[prefix] = {\n                    preventDefault: true,\n                    commands: [(view) => {\n                            let ourObj = storedPrefix = { view, prefix, scope };\n                            setTimeout(() => { if (storedPrefix == ourObj)\n                                storedPrefix = null; }, PrefixTimeout);\n                            return true;\n                        }]\n                };\n        }\n        let full = parts.join(\" \");\n        checkPrefix(full, false);\n        let binding = scopeObj[full] || (scopeObj[full] = { preventDefault: false, commands: [] });\n        binding.commands.push(command);\n        if (preventDefault)\n            binding.preventDefault = true;\n    };\n    for (let b of bindings) {\n        let name = b[platform] || b.key;\n        if (!name)\n            continue;\n        for (let scope of b.scope ? b.scope.split(\" \") : [\"editor\"]) {\n            add(scope, name, b.run, b.preventDefault);\n            if (b.shift)\n                add(scope, \"Shift-\" + name, b.shift, b.preventDefault);\n        }\n    }\n    return bound;\n}\nfunction runHandlers(map, event, view, scope) {\n    let name = keyName(event), isChar = name.length == 1 && name != \" \";\n    let prefix = \"\", fallthrough = false;\n    if (storedPrefix && storedPrefix.view == view && storedPrefix.scope == scope) {\n        prefix = storedPrefix.prefix + \" \";\n        if (fallthrough = modifierCodes.indexOf(event.keyCode) < 0)\n            storedPrefix = null;\n    }\n    let runFor = (binding) => {\n        if (binding) {\n            for (let cmd of binding.commands)\n                if (cmd(view))\n                    return true;\n            if (binding.preventDefault)\n                fallthrough = true;\n        }\n        return false;\n    };\n    let scopeObj = map[scope], baseName;\n    if (scopeObj) {\n        if (runFor(scopeObj[prefix + modifiers(name, event, !isChar)]))\n            return true;\n        if (isChar && (event.shiftKey || event.altKey || event.metaKey) &&\n            (baseName = base[event.keyCode]) && baseName != name) {\n            if (runFor(scopeObj[prefix + modifiers(baseName, event, true)]))\n                return true;\n        }\n        else if (isChar && event.shiftKey) {\n            if (runFor(scopeObj[prefix + modifiers(name, event, true)]))\n                return true;\n        }\n    }\n    return fallthrough;\n}\n\nconst CanHidePrimary = !browser.ios; // FIXME test IE\nconst selectionConfig = Facet.define({\n    combine(configs) {\n        return combineConfig(configs, {\n            cursorBlinkRate: 1200,\n            drawRangeCursor: true\n        }, {\n            cursorBlinkRate: (a, b) => Math.min(a, b),\n            drawRangeCursor: (a, b) => a || b\n        });\n    }\n});\n/// Returns an extension that hides the browser's native selection and\n/// cursor, replacing the selection with a background behind the text\n/// (labeled with the `$selectionBackground` theme class), and the\n/// cursors with elements overlaid over the code (using\n/// `$cursor.primary` and `$cursor.secondary`).\n///\n/// This allows the editor to display secondary selection ranges, and\n/// tends to produce a type of selection more in line with that users\n/// expect in a text editor (the native selection styling will often\n/// leave gaps between lines and won't fill the horizontal space after\n/// a line when the selection continues past it).\n///\n/// It does have a performance cost, in that it requires an extra DOM\n/// layout cycle for many updates (the selection is drawn based on DOM\n/// layout information that's only available after laying out the\n/// content).\nfunction drawSelection(config = {}) {\n    return [\n        selectionConfig.of(config),\n        drawSelectionPlugin,\n        hideNativeSelection\n    ];\n}\nclass Piece {\n    constructor(left, top, width, height, className) {\n        this.left = left;\n        this.top = top;\n        this.width = width;\n        this.height = height;\n        this.className = className;\n    }\n    draw() {\n        let elt = document.createElement(\"div\");\n        elt.className = this.className;\n        elt.style.left = this.left + \"px\";\n        elt.style.top = this.top + \"px\";\n        if (this.width >= 0)\n            elt.style.width = this.width + \"px\";\n        elt.style.height = this.height + \"px\";\n        return elt;\n    }\n    eq(p) {\n        return this.left == p.left && this.top == p.top && this.width == p.width && this.height == p.height &&\n            this.className == p.className;\n    }\n}\nconst drawSelectionPlugin = ViewPlugin.fromClass(class {\n    constructor(view) {\n        this.view = view;\n        this.rangePieces = [];\n        this.cursors = [];\n        this.measureReq = { read: this.readPos.bind(this), write: this.drawSel.bind(this) };\n        this.selectionLayer = view.scrollDOM.appendChild(document.createElement(\"div\"));\n        this.selectionLayer.className = themeClass(\"selectionLayer\");\n        this.selectionLayer.setAttribute(\"aria-hidden\", \"true\");\n        this.cursorLayer = view.scrollDOM.appendChild(document.createElement(\"div\"));\n        this.cursorLayer.className = themeClass(\"cursorLayer\");\n        this.cursorLayer.setAttribute(\"aria-hidden\", \"true\");\n        view.requestMeasure(this.measureReq);\n        this.setBlinkRate();\n    }\n    setBlinkRate() {\n        this.cursorLayer.style.animationDuration = this.view.state.facet(selectionConfig).cursorBlinkRate + \"ms\";\n    }\n    update(update) {\n        let confChanged = update.startState.facet(selectionConfig) != update.state.facet(selectionConfig);\n        if (confChanged || update.selectionSet || update.geometryChanged || update.viewportChanged)\n            this.view.requestMeasure(this.measureReq);\n        if (update.transactions.some(tr => tr.scrollIntoView))\n            this.cursorLayer.style.animationName = this.cursorLayer.style.animationName == \"cm-blink\" ? \"cm-blink2\" : \"cm-blink\";\n        if (confChanged)\n            this.setBlinkRate();\n    }\n    readPos() {\n        let { state } = this.view, conf = state.facet(selectionConfig);\n        let rangePieces = state.selection.ranges.map(r => r.empty ? [] : measureRange(this.view, r)).reduce((a, b) => a.concat(b));\n        let cursors = [];\n        for (let r of state.selection.ranges) {\n            let prim = r == state.selection.main;\n            if (r.empty ? !prim || CanHidePrimary : conf.drawRangeCursor) {\n                let piece = measureCursor(this.view, r, prim);\n                if (piece)\n                    cursors.push(piece);\n            }\n        }\n        return { rangePieces, cursors };\n    }\n    drawSel({ rangePieces, cursors }) {\n        if (rangePieces.length != this.rangePieces.length || rangePieces.some((p, i) => !p.eq(this.rangePieces[i]))) {\n            this.selectionLayer.textContent = \"\";\n            for (let p of rangePieces)\n                this.selectionLayer.appendChild(p.draw());\n            this.rangePieces = rangePieces;\n        }\n        if (cursors.length != this.cursors.length || cursors.some((c, i) => !c.eq(this.cursors[i]))) {\n            this.cursorLayer.textContent = \"\";\n            for (let c of cursors)\n                this.cursorLayer.appendChild(c.draw());\n            this.cursors = cursors;\n        }\n    }\n    destroy() {\n        this.selectionLayer.remove();\n        this.cursorLayer.remove();\n    }\n});\nconst themeSpec = {\n    $line: {\n        \"& ::selection\": { backgroundColor: \"transparent !important\" },\n        \"&::selection\": { backgroundColor: \"transparent !important\" }\n    }\n};\nif (CanHidePrimary)\n    themeSpec.$line.caretColor = \"transparent !important\";\nconst hideNativeSelection = Prec.override(EditorView.theme(themeSpec));\nconst selectionClass = themeClass(\"selectionBackground\");\nfunction getBase(view) {\n    let rect = view.scrollDOM.getBoundingClientRect();\n    return { left: rect.left - view.scrollDOM.scrollLeft, top: rect.top - view.scrollDOM.scrollTop };\n}\nfunction wrappedLine(view, pos, inside) {\n    let range = EditorSelection.cursor(pos);\n    return { from: Math.max(inside.from, view.moveToLineBoundary(range, false, true).from),\n        to: Math.min(inside.to, view.moveToLineBoundary(range, true, true).from) };\n}\nfunction measureRange(view, range) {\n    if (range.to <= view.viewport.from || range.from >= view.viewport.to)\n        return [];\n    let from = Math.max(range.from, view.viewport.from), to = Math.min(range.to, view.viewport.to);\n    let ltr = view.textDirection == Direction.LTR;\n    let content = view.contentDOM, contentRect = content.getBoundingClientRect(), base = getBase(view);\n    let lineStyle = window.getComputedStyle(content.firstChild);\n    let leftSide = contentRect.left + parseInt(lineStyle.paddingLeft);\n    let rightSide = contentRect.right - parseInt(lineStyle.paddingRight);\n    let visualStart = view.visualLineAt(from);\n    let visualEnd = view.visualLineAt(to);\n    if (view.lineWrapping) {\n        visualStart = wrappedLine(view, from, visualStart);\n        visualEnd = wrappedLine(view, to, visualEnd);\n    }\n    if (visualStart.from == visualEnd.from) {\n        return pieces(drawForLine(range.from, range.to));\n    }\n    else {\n        let top = drawForLine(range.from, null);\n        let bottom = drawForLine(null, range.to);\n        let between = [];\n        if (visualStart.to < visualEnd.from - 1)\n            between.push(piece(leftSide, top.bottom, rightSide, bottom.top));\n        else if (top.bottom < bottom.top && bottom.top - top.bottom < 4)\n            top.bottom = bottom.top = (top.bottom + bottom.top) / 2;\n        return pieces(top).concat(between).concat(pieces(bottom));\n    }\n    function piece(left, top, right, bottom) {\n        return new Piece(left - base.left, top - base.top, right - left, bottom - top, selectionClass);\n    }\n    function pieces({ top, bottom, horizontal }) {\n        let pieces = [];\n        for (let i = 0; i < horizontal.length; i += 2)\n            pieces.push(piece(horizontal[i], top, horizontal[i + 1], bottom));\n        return pieces;\n    }\n    // Gets passed from/to in line-local positions\n    function drawForLine(from, to) {\n        let top = 1e9, bottom = -1e9, horizontal = [];\n        function addSpan(from, fromOpen, to, toOpen, dir) {\n            let fromCoords = view.coordsAtPos(from, 1), toCoords = view.coordsAtPos(to, -1);\n            top = Math.min(fromCoords.top, toCoords.top, top);\n            bottom = Math.max(fromCoords.bottom, toCoords.bottom, bottom);\n            if (dir == Direction.LTR)\n                horizontal.push(ltr && fromOpen ? leftSide : fromCoords.left, ltr && toOpen ? rightSide : toCoords.right);\n            else\n                horizontal.push(!ltr && toOpen ? leftSide : toCoords.left, !ltr && fromOpen ? rightSide : fromCoords.right);\n        }\n        let start = from !== null && from !== void 0 ? from : view.moveToLineBoundary(EditorSelection.cursor(to, 1), false).head;\n        let end = to !== null && to !== void 0 ? to : view.moveToLineBoundary(EditorSelection.cursor(from, -1), true).head;\n        // Split the range by visible range and document line\n        for (let r of view.visibleRanges)\n            if (r.to > start && r.from < end) {\n                for (let pos = Math.max(r.from, start), endPos = Math.min(r.to, end);;) {\n                    let docLine = view.state.doc.lineAt(pos);\n                    for (let span of view.bidiSpans(docLine)) {\n                        let spanFrom = span.from + docLine.from, spanTo = span.to + docLine.from;\n                        if (spanFrom >= endPos)\n                            break;\n                        if (spanTo > pos)\n                            addSpan(Math.max(spanFrom, pos), from == null && spanFrom <= start, Math.min(spanTo, endPos), to == null && spanTo >= end, span.dir);\n                    }\n                    pos = docLine.to + 1;\n                    if (pos >= endPos)\n                        break;\n                }\n            }\n        if (horizontal.length == 0) {\n            let coords = view.coordsAtPos(start, -1);\n            top = Math.min(coords.top, top);\n            bottom = Math.max(coords.bottom, bottom);\n        }\n        return { top, bottom, horizontal };\n    }\n}\nconst primaryCursorClass = themeClass(\"cursor.primary\");\nconst cursorClass = themeClass(\"cursor.secondary\");\nfunction measureCursor(view, cursor, primary) {\n    let pos = view.coordsAtPos(cursor.head, cursor.assoc || 1);\n    if (!pos)\n        return null;\n    let base = getBase(view);\n    return new Piece(pos.left - base.left, pos.top - base.top, -1, pos.bottom - pos.top, primary ? primaryCursorClass : cursorClass);\n}\n\nconst Specials = /[\\u0000-\\u0008\\u000a-\\u001f\\u007f-\\u009f\\u00ad\\u061c\\u200b-\\u200c\\u200e\\u200f\\u2028\\u2029\\ufeff\\ufff9-\\ufffc]/gu;\nconst Names = {\n    0: \"null\",\n    7: \"bell\",\n    8: \"backspace\",\n    10: \"newline\",\n    11: \"vertical tab\",\n    13: \"carriage return\",\n    27: \"escape\",\n    8203: \"zero width space\",\n    8204: \"zero width non-joiner\",\n    8205: \"zero width joiner\",\n    8206: \"left-to-right mark\",\n    8207: \"right-to-left mark\",\n    8232: \"line separator\",\n    8233: \"paragraph separator\",\n    65279: \"zero width no-break space\",\n    65532: \"object replacement\"\n};\nlet _supportsTabSize = null;\nfunction supportsTabSize() {\n    if (_supportsTabSize == null && typeof document != \"undefined\" && document.body) {\n        let styles = document.body.style;\n        _supportsTabSize = (styles.tabSize || styles.MozTabSize) != null;\n    }\n    return _supportsTabSize || false;\n}\nconst UnicodeRegexpSupport = /x/.unicode != null ? \"gu\" : \"g\";\nconst specialCharConfig = Facet.define({\n    combine(configs) {\n        let config = combineConfig(configs, {\n            render: null,\n            specialChars: Specials,\n            addSpecialChars: null\n        });\n        if (config.replaceTabs = !supportsTabSize())\n            config.specialChars = new RegExp(\"\\t|\" + config.specialChars.source, UnicodeRegexpSupport);\n        if (config.addSpecialChars)\n            config.specialChars = new RegExp(config.specialChars.source + \"|\" + config.addSpecialChars.source, UnicodeRegexpSupport);\n        return config;\n    }\n});\n/// Returns an extension that installs highlighting of special\n/// characters.\nfunction highlightSpecialChars(\n/// Configuration options.\nconfig = {}) {\n    let ext = [specialCharConfig.of(config), specialCharPlugin];\n    if (!supportsTabSize())\n        ext.push(tabStyle);\n    return ext;\n}\nconst specialCharPlugin = ViewPlugin.fromClass(class {\n    constructor(view) {\n        this.view = view;\n        this.decorations = Decoration.none;\n        this.decorationCache = Object.create(null);\n        this.recompute();\n    }\n    update(update) {\n        let confChange = update.startState.facet(specialCharConfig) != update.state.facet(specialCharConfig);\n        if (confChange)\n            this.decorationCache = Object.create(null);\n        if (confChange || update.changes.length || update.viewportChanged)\n            this.recompute();\n    }\n    recompute() {\n        let decorations = [];\n        for (let { from, to } of this.view.visibleRanges)\n            this.getDecorationsFor(from, to, decorations);\n        this.decorations = Decoration.set(decorations);\n    }\n    getDecorationsFor(from, to, target) {\n        let config = this.view.state.facet(specialCharConfig);\n        let { doc } = this.view.state;\n        for (let pos = from, cursor = doc.iterRange(from, to), m; !cursor.next().done;) {\n            if (!cursor.lineBreak) {\n                while (m = config.specialChars.exec(cursor.value)) {\n                    let code = codePointAt(m[0], 0), deco;\n                    if (code == null)\n                        continue;\n                    if (code == 9) {\n                        let line = doc.lineAt(pos + m.index);\n                        let size = this.view.state.tabSize, col = countColumn(doc.sliceString(line.from, pos + m.index), 0, size);\n                        deco = Decoration.replace({ widget: new TabWidget((size - (col % size)) * this.view.defaultCharacterWidth) });\n                    }\n                    else {\n                        deco = this.decorationCache[code] ||\n                            (this.decorationCache[code] = Decoration.replace({ widget: new SpecialCharWidget(config, code) }));\n                    }\n                    target.push(deco.range(pos + m.index, pos + m.index + m[0].length));\n                }\n            }\n            pos += cursor.value.length;\n        }\n    }\n}, {\n    decorations: v => v.decorations\n});\nconst DefaultPlaceholder = \"\\u2022\";\n// Assigns placeholder characters from the Control Pictures block to\n// ASCII control characters\nfunction placeholder(code) {\n    if (code >= 32)\n        return DefaultPlaceholder;\n    if (code == 10)\n        return \"\\u2424\";\n    return String.fromCharCode(9216 + code);\n}\nclass SpecialCharWidget extends WidgetType {\n    constructor(options, code) {\n        super();\n        this.options = options;\n        this.code = code;\n    }\n    eq(other) { return other.code == this.code; }\n    toDOM(view) {\n        let ph = placeholder(this.code);\n        let desc = view.state.phrase(\"Control character \") + (Names[this.code] || \"0x\" + this.code.toString(16));\n        let custom = this.options.render && this.options.render(this.code, desc, ph);\n        if (custom)\n            return custom;\n        let span = document.createElement(\"span\");\n        span.textContent = ph;\n        span.title = desc;\n        span.setAttribute(\"aria-label\", desc);\n        span.style.color = \"red\";\n        return span;\n    }\n    ignoreEvent() { return false; }\n}\nclass TabWidget extends WidgetType {\n    constructor(width) {\n        super();\n        this.width = width;\n    }\n    eq(other) { return other.width == this.width; }\n    toDOM() {\n        let span = document.createElement(\"span\");\n        span.textContent = \"\\t\";\n        span.className = tab;\n        span.style.width = this.width + \"px\";\n        return span;\n    }\n    ignoreEvent() { return false; }\n}\nconst tab = StyleModule.newName(), tabStyle = EditorView.styleModule.of(new StyleModule({\n    [\".\" + tab]: {\n        display: \"inline-block\",\n        overflow: \"hidden\",\n        verticalAlign: \"bottom\"\n    }\n}));\n\n/// Mark lines that have a cursor on them with the `$activeLine`\n/// theme class.\nfunction highlightActiveLine() {\n    return activeLineHighlighter;\n}\nconst lineDeco = Decoration.line({ attributes: { class: themeClass(\"activeLine\") } });\nconst activeLineHighlighter = ViewPlugin.fromClass(class {\n    constructor(view) {\n        this.decorations = this.getDeco(view);\n    }\n    update(update) {\n        if (update.docChanged || update.selectionSet)\n            this.decorations = this.getDeco(update.view);\n    }\n    getDeco(view) {\n        let lastLineStart = -1, deco = [];\n        for (let r of view.state.selection.ranges) {\n            if (!r.empty)\n                continue;\n            let line = view.visualLineAt(r.head);\n            if (line.from > lastLineStart) {\n                deco.push(lineDeco.range(line.from));\n                lastLineStart = line.from;\n            }\n        }\n        return Decoration.set(deco);\n    }\n}, {\n    decorations: v => v.decorations\n});\n\nclass Placeholder extends WidgetType {\n    constructor(content) {\n        super();\n        this.content = content;\n    }\n    toDOM() {\n        let wrap = document.createElement(\"span\");\n        wrap.className = themeClass(\"placeholder\");\n        wrap.style.pointerEvents = \"none\";\n        wrap.appendChild(typeof this.content == \"string\" ? document.createTextNode(this.content) : this.content);\n        if (typeof this.content == \"string\")\n            wrap.setAttribute(\"aria-label\", \"placeholder \" + this.content);\n        else\n            wrap.setAttribute(\"aria-hidden\", \"true\");\n        return wrap;\n    }\n    ignoreEvent() { return false; }\n}\n/// Extension that enables a placeholder—a piece of extample content\n/// to show when the editor is empty.\nfunction placeholder$1(content) {\n    return ViewPlugin.fromClass(class {\n        constructor(view) {\n            this.view = view;\n            this.placeholder = Decoration.set([Decoration.widget({ widget: new Placeholder(content), side: 1 }).range(0)]);\n        }\n        get decorations() { return this.view.state.doc.length ? Decoration.none : this.placeholder; }\n    }, { decorations: v => v.decorations });\n}\n\n/// @internal\nconst __test = { HeightMap, HeightOracle, MeasuredHeights, QueryType, ChangedRange, computeOrder, moveVisually };\n\nexport { BidiSpan, BlockInfo, BlockType, Decoration, Direction, EditorView, PluginField, PluginFieldProvider, ViewPlugin, ViewUpdate, WidgetType, __test, drawSelection, highlightActiveLine, highlightSpecialChars, keymap, logException, placeholder$1 as placeholder, runScopeHandlers, themeClass };\n","export * from \"./schema/index.js\";\nexport * from \"./instance/index.js\";\nexport * from \"./mapping/index.js\";\nexport * from \"./utils.js\";\n","import * as Instance_1 from \"./instance.js\";\nexport { Instance_1 as Instance };\nexport * from \"./utils.js\";\n","import { forEntries, getKeyIndex, getKeys, signalInvalidType, } from \"../utils.js\";\nexport const instance = (schema, instance) => {\n    for (const [_, values] of forEntries(instance)) {\n        Object.freeze(values);\n    }\n    return Object.freeze(instance);\n};\nexport function fromJSON(value) {\n    if (value.kind === \"reference\") {\n        return Reference.fromJSON(value);\n    }\n    else if (value.kind === \"uri\") {\n        return Uri.fromJSON(value);\n    }\n    else if (value.kind === \"literal\") {\n        return Literal.fromJSON(value);\n    }\n    else if (value.kind === \"product\") {\n        return Product.fromJSON(value);\n    }\n    else if (value.kind === \"coproduct\") {\n        return Coproduct.fromJSON(value);\n    }\n    else {\n        signalInvalidType(value);\n    }\n}\nexport class Reference {\n    constructor(index) {\n        this.index = index;\n        Object.freeze(this);\n    }\n    static fromJSON({ index }) {\n        return new Reference(index);\n    }\n    get kind() {\n        return \"reference\";\n    }\n    toJSON() {\n        return { kind: \"reference\", index: this.index };\n    }\n}\nexport const reference = (type, index) => new Reference(index);\nexport const isReference = (value) => value.kind === \"reference\";\nexport class Uri {\n    constructor(value) {\n        this.value = value;\n        Object.freeze(this);\n    }\n    static fromJSON({ value }) {\n        return new Uri(value);\n    }\n    get kind() {\n        return \"uri\";\n    }\n    toJSON() {\n        return { kind: \"uri\", value: this.value };\n    }\n}\nexport const uri = (type, value) => new Uri(value);\nexport const isUri = (value) => value.kind === \"uri\";\nexport class Literal {\n    constructor(value) {\n        this.value = value;\n        Object.freeze(this);\n    }\n    static fromJSON({ value }) {\n        return new Literal(value);\n    }\n    get kind() {\n        return \"literal\";\n    }\n    toJSON() {\n        return { kind: \"literal\", value: this.value };\n    }\n}\nexport const literal = (type, value) => new Literal(value);\nexport const isLiteral = (value) => value.kind === \"literal\";\nexport class Product extends Array {\n    static fromJSON({ components, }) {\n        return new Product(components.map(fromJSON));\n    }\n    get kind() {\n        return \"product\";\n    }\n    constructor(values) {\n        super(...values);\n        Object.freeze(this);\n    }\n    toJSON() {\n        return { kind: \"product\", components: this.map((value) => value.toJSON()) };\n    }\n    map(f) {\n        const result = new Array(this.length);\n        for (const [i, value] of this.entries()) {\n            result[i] = f(value, i, this);\n        }\n        return result;\n    }\n    get(type, key) {\n        const index = getKeyIndex(type.components, key);\n        if (index in this) {\n            return this[index];\n        }\n        else {\n            throw new Error(`Index out of range: ${index}`);\n        }\n    }\n}\nexport const product = (type, components) => new Product(getKeys(type.components).map((key) => components[key]));\nexport const isProduct = (value) => value.kind === \"product\";\nexport const unit = (type) => new Product([]);\nexport const isUnit = (value) => value.kind === \"product\" && value.length === 0;\nexport class Coproduct {\n    constructor(index, value) {\n        this.index = index;\n        this.value = value;\n        Object.freeze(this);\n    }\n    static fromJSON({ index, value }) {\n        return new Coproduct(index, fromJSON(value));\n    }\n    get kind() {\n        return \"coproduct\";\n    }\n    toJSON() {\n        return { kind: \"coproduct\", index: this.index, value: this.value.toJSON() };\n    }\n    key(type) {\n        const keys = getKeys(type.options);\n        if (this.index in keys) {\n            return keys[this.index];\n        }\n        else {\n            throw new Error(`Index out of range: ${this.index}`);\n        }\n    }\n    is(type, key) {\n        return getKeyIndex(type.options, key) === this.index;\n    }\n}\nexport const coproduct = (type, key, value) => new Coproduct(getKeyIndex(type.options, key), value);\nexport const isCoproduct = (value) => value.kind === \"coproduct\";\n","import * as Schema from \"../schema/schema.js\";\nimport * as Instance from \"./instance.js\";\nimport { getKeys, zip } from \"../utils.js\";\nexport function validateInstance(schema, instance) {\n    for (const key of getKeys(schema)) {\n        if (key in instance) {\n            for (const value of instance[key]) {\n                if (validateValue(schema[key], value)) {\n                    continue;\n                }\n                else {\n                    return false;\n                }\n            }\n        }\n        else {\n            return false;\n        }\n    }\n    return true;\n}\nexport function validateValue(type, value) {\n    if (Schema.isReference(type)) {\n        return Instance.isReference(value);\n    }\n    else if (Schema.isUri(type)) {\n        return Instance.isUri(value);\n    }\n    else if (Schema.isLiteral(type)) {\n        return Instance.isLiteral(value);\n    }\n    else if (Schema.isProduct(type)) {\n        if (Instance.isProduct(value)) {\n            const keys = getKeys(type.components);\n            if (keys.length !== value.length) {\n                return false;\n            }\n            for (const [key, component] of zip(keys, value)) {\n                if (validateValue(type.components[key], component)) {\n                    continue;\n                }\n                else {\n                    return false;\n                }\n            }\n            return true;\n        }\n        else {\n            return false;\n        }\n    }\n    else if (Schema.isCoproduct(type)) {\n        const keys = getKeys(type.options);\n        if (Instance.isCoproduct(value) && value.index in keys) {\n            const key = keys[value.index];\n            return validateValue(type.options[key], value.value);\n        }\n        else {\n            return false;\n        }\n    }\n    else {\n        console.error(type);\n        throw new Error(\"Unexpected type\");\n    }\n}\n// type IndexValue<Schema extends Record<string, Schema.Type>> =\nfunction* indexValue(type, value, path) {\n    if (path.length === 0) {\n        yield value;\n    }\n    else {\n        const [key, ...rest] = path;\n        if (type.kind === \"product\" && value.kind === \"product\") {\n            if (key in type.components) {\n                yield* indexValue(type.components[key], value.get(type, key), rest);\n            }\n            else {\n                throw new Error(`Invalid product component: ${key}`);\n            }\n        }\n        else if (type.kind === \"coproduct\" && value.kind === \"coproduct\") {\n            if (key in type.options) {\n                if (value.is(type, key)) {\n                    yield* indexValue(type.options[key], value.value, rest);\n                }\n            }\n            else {\n                throw new Error(`Invalid coproduct option: ${key}`);\n            }\n        }\n    }\n}\nexport function* forValues(schema, instance, key, path) {\n    if (key in schema && key in instance) {\n        for (const value of instance[key]) {\n            yield* indexValue(schema[key], value, path);\n        }\n    }\n    else {\n        console.error(key, schema, instance);\n        throw new Error(`Invalid key ${key}`);\n    }\n}\n","import { Schema, unify, isTypeAssignable } from \"../schema/index.js\";\nimport { getKeys, mapKeys, signalInvalidType } from \"../utils.js\";\nexport const applyExpressions = (S, expressions, source) => expressions.reduce((type, expression) => apply(S, expression, type), source);\nexport function apply(S, expression, source) {\n    if (expression.kind === \"identifier\") {\n        return Schema.uri();\n    }\n    else if (expression.kind === \"constant\") {\n        return Schema.literal(expression.datatype);\n    }\n    else if (expression.kind === \"dereference\") {\n        if (source.kind === \"reference\" &&\n            source.value in S &&\n            source.value === expression.key) {\n            return S[source.value];\n        }\n        else {\n            throw new Error(\"Invalid dereference morphism\");\n        }\n    }\n    else if (expression.kind === \"projection\") {\n        if (source.kind === \"product\" && expression.key in source.components) {\n            return source.components[expression.key];\n        }\n        else {\n            throw new Error(\"Invalid projection morphism\");\n        }\n    }\n    else if (expression.kind === \"injection\") {\n        const { key } = expression;\n        return Schema.coproduct({ [key]: source });\n    }\n    else if (expression.kind === \"tuple\") {\n        return Schema.product(mapKeys(expression.slots, (value) => applyExpressions(S, value, source)));\n    }\n    else if (expression.kind === \"match\") {\n        if (source.kind === \"coproduct\") {\n            const cases = Array.from(applyCases(S, source, expression));\n            if (cases.length === 0) {\n                throw new Error(\"Empty case analysis\");\n            }\n            else {\n                return cases.reduce(unify);\n            }\n        }\n        else {\n            throw new Error(\"Invalid match morphism\");\n        }\n    }\n    else {\n        signalInvalidType(expression);\n    }\n}\nfunction* applyCases(S, source, { cases }) {\n    for (const key of getKeys(source.options)) {\n        if (key in cases) {\n            yield applyExpressions(S, cases[key], source.options[key]);\n        }\n        else {\n            throw new Error(\"Invalid case analysis\");\n        }\n    }\n}\nexport function validateExpressions(S, expressions, source, target) {\n    let type;\n    try {\n        type = applyExpressions(S, expressions, source);\n    }\n    catch (e) {\n        return false;\n    }\n    return isTypeAssignable(type, target);\n}\n","import * as Schema from \"../schema/schema.js\";\nimport * as Instance from \"../instance/instance.js\";\nimport { signalInvalidType, getKeys, mapKeys } from \"../utils.js\";\nimport { mapExpressions } from \"./map.js\";\nexport function delta(M, S, T, TI) {\n    const SI = mapKeys(S, () => []);\n    const indices = mapKeys(S, () => new Map());\n    for (const key of getKeys(S)) {\n        if (!(key in M) || !(key in indices)) {\n            throw new Error(\"Invalid mapping\");\n        }\n        const { source, value: expressions } = M[key];\n        if (!(source in TI)) {\n            throw new Error(\"Invalid instance\");\n        }\n        for (const value of TI[source]) {\n            if (indices[key].has(value)) {\n                continue;\n            }\n            else {\n                const [imageType, imageValue] = mapExpressions({ S: T, SI: TI }, expressions, T[source], value);\n                const i = SI[key].push(placeholder) - 1;\n                indices[key].set(value, i);\n                SI[key][i] = pullback({ M, S, T, SI, TI, indices }, S[key], imageType, imageValue);\n            }\n        }\n    }\n    for (const key of getKeys(S)) {\n        Object.freeze(SI[key]);\n    }\n    Object.freeze(SI);\n    return SI;\n}\nconst placeholder = new Instance.Product([]);\n// pullback basically just rewrites the values to be instances of\n// the actual source types instead of the mapped result types, which\n// might only be *assignable* to the source types.\n// However if the source type is a reference, then we have to do a\n// little magic to locate the corresponding pointer value in state.indices\nfunction pullback(state, sourceType, imageType, imageValue) {\n    if (Schema.isReference(sourceType)) {\n        // Here we actually know that value is an instance of M1[sourceType.value]\n        // So now what?\n        // First we check to see if the value is in the index cache.\n        // (We're ultimately going to return a Instance.Reference for sure)\n        const index = state.indices[sourceType.value].get(imageValue);\n        if (index !== undefined) {\n            return Instance.reference(sourceType, index);\n        }\n        else {\n            // Otherwise, we map value along the morphism M2[sourceType.value].\n            // This gives us a value that is an instance of the image of the referenced type\n            // - ie an instance of fold(M1, T, S[sourceType.value])\n            const t = state.S[sourceType.value]; // t is basically a \"dereferenced source type\"\n            const { value: expressions } = state.M[sourceType.value]; // m is the map that will give us an instance of t\n            // resultType and resultValue are the \"dereferenced image type & value\"\n            const [resultType, resultValue] = mapExpressions({ S: state.T, SI: state.TI }, expressions, imageType, imageValue);\n            // here resultType should be equal to fold(M1, T, S[sourceType.value])\n            const index = state.SI[sourceType.value].push(placeholder) - 1;\n            state.indices[sourceType.value].set(imageValue, index);\n            const p = pullback(state, t, resultType, resultValue);\n            state.SI[sourceType.value][index] = p;\n            return Instance.reference(sourceType, index);\n        }\n    }\n    else if (Schema.isUri(sourceType)) {\n        if (imageType.kind !== \"uri\" || imageValue.kind !== \"uri\") {\n            throw new Error(\"Invalid image value: expected iri\");\n        }\n        else {\n            return imageValue;\n        }\n    }\n    else if (Schema.isLiteral(sourceType)) {\n        if (imageType.kind !== \"literal\" || imageValue.kind !== \"literal\") {\n            throw new Error(\"Invalid image value: expected literal\");\n        }\n        else {\n            return imageValue;\n        }\n    }\n    else if (Schema.isProduct(sourceType)) {\n        if (imageType.kind !== \"product\" || imageValue.kind !== \"product\") {\n            throw new Error(\"Invalid image value: expected record\");\n        }\n        else {\n            return new Instance.Product(pullbackComponents(state, sourceType, imageType, imageValue));\n        }\n    }\n    else if (Schema.isCoproduct(sourceType)) {\n        if (imageType.kind !== \"coproduct\" || imageValue.kind !== \"coproduct\") {\n            throw new Error(\"Invalid image value: expected variant\");\n        }\n        else {\n            const key = imageValue.key(imageType);\n            return Instance.coproduct(sourceType, key, pullback(state, sourceType.options[key], imageType.options[key], imageValue.value));\n        }\n    }\n    else {\n        signalInvalidType(sourceType);\n    }\n}\nfunction* pullbackComponents(state, sourceType, imageType, imageValue) {\n    for (const key of getKeys(sourceType.components)) {\n        if (key in imageType.components) {\n            yield pullback(state, sourceType.components[key], imageType.components[key], imageValue.get(imageType, key));\n        }\n        else {\n            throw new Error(`Invalid image value: missing component ${key}`);\n        }\n    }\n}\n","import * as Mapping_1 from \"./mapping.js\";\nexport { Mapping_1 as Mapping };\nexport * from \"./utils.js\";\nexport * from \"./apply.js\";\nexport * from \"./map.js\";\nexport * from \"./delta.js\";\n","import * as Schema from \"../schema/schema.js\";\nimport * as Instance from \"../instance/instance.js\";\nimport { signalInvalidType, getKeys } from \"../utils.js\";\nexport const mapExpressions = ({ S, SI }, expressions, type, value) => expressions.reduce(([type, value], expression) => map({ S, SI }, expression, type, value), [type, value]);\nexport function map({ S, SI }, expression, type, value) {\n    if (expression.kind === \"identifier\") {\n        return [Schema.uri(), new Instance.Uri(expression.value)];\n    }\n    else if (expression.kind === \"constant\") {\n        return [\n            Schema.literal(expression.datatype),\n            new Instance.Literal(expression.value),\n        ];\n    }\n    else if (expression.kind === \"dereference\") {\n        const { key } = expression;\n        if (type.kind === \"reference\" &&\n            type.value === key &&\n            value.kind === \"reference\") {\n            if (key in SI && value.index in SI[key]) {\n                return [S[key], SI[key][value.index]];\n            }\n            else {\n                throw new Error(\"Invalid pointer dereference\");\n            }\n        }\n        else {\n            throw new Error(\"Invalid pointer dereference\");\n        }\n    }\n    else if (expression.kind === \"projection\") {\n        if (type.kind === \"product\" &&\n            expression.key in type.components &&\n            value.kind === \"product\") {\n            return [type.components[expression.key], value.get(type, expression.key)];\n        }\n        else {\n            throw new Error(\"Invalid projection\");\n        }\n    }\n    else if (expression.kind === \"match\") {\n        if (type.kind === \"coproduct\" && value.kind === \"coproduct\") {\n            const key = value.key(type);\n            if (key in expression.cases) {\n                return mapExpressions({ S, SI }, expression.cases[key], type.options[key], value.value);\n            }\n            else {\n                throw new Error(\"Invalid case analysis\");\n            }\n        }\n        else {\n            throw new Error(\"Invalid match morphism\");\n        }\n    }\n    else if (expression.kind === \"tuple\") {\n        const types = {};\n        const values = {};\n        for (const key of getKeys(expression.slots)) {\n            const slot = expression.slots[key];\n            const [t, v] = mapExpressions({ S, SI }, slot, type, value);\n            types[key] = t;\n            values[key] = v;\n        }\n        const product = Schema.product(types);\n        return [product, Instance.product(product, values)];\n    }\n    else if (expression.kind === \"injection\") {\n        return [\n            Schema.coproduct({ [expression.key]: type }),\n            new Instance.Coproduct(0, value),\n        ];\n    }\n    else {\n        signalInvalidType(expression);\n    }\n}\n","export * from \"./utils.js\";\nexport * from \"./apply.js\";\nexport const identifier = (value) => Object.freeze({ kind: \"identifier\", value });\nexport const constant = (value, datatype) => Object.freeze({ kind: \"constant\", value, datatype });\nexport const dereference = (key) => Object.freeze({ kind: \"dereference\", key });\nexport const projection = (key) => Object.freeze({ kind: \"projection\", key });\nexport const injection = (key) => Object.freeze({ kind: \"injection\", key });\nexport const tuple = (slots) => Object.freeze({ kind: \"tuple\", slots: Object.freeze(slots) });\nexport const match = (cases) => Object.freeze({ kind: \"match\", cases: Object.freeze(cases) });\nexport const map = (source, value) => Object.freeze({ kind: \"map\", source, value });\nexport const mapping = (maps) => Object.freeze(maps);\n","import * as Schema from \"../schema/schema.js\";\nimport { signalInvalidType, forEntries, mapKeys } from \"../utils.js\";\nimport { validateExpressions } from \"./apply.js\";\nexport function validateMapping(M, S, T) {\n    for (const [key, type] of forEntries(S)) {\n        if (!(key in M)) {\n            return false;\n        }\n        const { source, value } = M[key];\n        if (validateExpressions(S, value, T[source], fold(M, S, T, type))) {\n            continue;\n        }\n        else {\n            return false;\n        }\n    }\n    return true;\n}\nexport function fold(M, S, T, type) {\n    if (type.kind === \"reference\") {\n        const { source } = M[type.value];\n        const value = T[source];\n        if (value === undefined) {\n            throw new Error(\"Invalid reference index\");\n        }\n        else {\n            return value;\n        }\n    }\n    else if (type.kind === \"uri\") {\n        return type;\n    }\n    else if (type.kind === \"literal\") {\n        return type;\n    }\n    else if (type.kind === \"product\") {\n        return Schema.product(mapKeys(type.components, (value) => fold(M, S, T, value)));\n    }\n    else if (type.kind === \"coproduct\") {\n        return Schema.coproduct(mapKeys(type.options, (value) => fold(M, S, T, value)));\n    }\n    else {\n        signalInvalidType(type);\n    }\n}\n","import * as Schema_1 from \"./schema.js\";\nexport { Schema_1 as Schema };\nexport * from \"./utils.js\";\n","import { getKeys } from \"../utils.js\";\nexport const schema = (labels) => Object.freeze(labels);\nexport const reference = (value) => Object.freeze({ kind: \"reference\", value });\nexport const isReference = (type) => type.kind === \"reference\";\nexport const uri = () => Object.freeze({ kind: \"uri\" });\nexport const isUri = (type) => type.kind === \"uri\";\nexport const literal = (datatype) => Object.freeze({ kind: \"literal\", datatype });\nexport const isLiteral = (type) => type.kind === \"literal\";\nexport const product = (components) => Object.freeze({ kind: \"product\", components: Object.freeze(components) });\nexport const isProduct = (type) => type.kind === \"product\";\nexport const unit = () => product({});\nexport const isUnit = (type) => type.kind === \"product\" && getKeys(type.components).length === 0;\nexport const coproduct = (options) => Object.freeze({ kind: \"coproduct\", options: Object.freeze(options) });\nexport const isCoproduct = (type) => type.kind === \"coproduct\";\n","import * as Schema from \"./schema.js\";\nimport { getKeys, zip } from \"../utils.js\";\nfunction* forType(type, key, path) {\n    yield [type, key, path];\n    if (type.kind === \"product\") {\n        for (const component of getKeys(type.components)) {\n            path.push(component);\n            yield* forType(type.components[component], key, path);\n            path.pop();\n        }\n    }\n    else if (type.kind === \"coproduct\") {\n        for (const option of getKeys(type.options)) {\n            path.push(option);\n            yield* forType(type.options[option], key, path);\n            path.pop();\n        }\n    }\n}\nexport function* forTypes(schema) {\n    for (const key of getKeys(schema)) {\n        yield* forType(schema[key], key, []);\n    }\n}\nexport function isTypeEqual(a, b) {\n    if (a === b) {\n        return true;\n    }\n    else if (a.kind !== b.kind) {\n        return false;\n    }\n    else if (a.kind === \"reference\" && b.kind === \"reference\") {\n        return a.value === b.value;\n    }\n    else if (a.kind === \"uri\" && b.kind === \"uri\") {\n        return true;\n    }\n    else if (a.kind === \"literal\" && b.kind === \"literal\") {\n        return a.datatype === b.datatype;\n    }\n    else if (a.kind === \"product\" && b.kind === \"product\") {\n        const A = getKeys(a.components);\n        const B = getKeys(b.components);\n        if (A.length !== B.length) {\n            return false;\n        }\n        for (const [keyA, keyB] of zip(A, B)) {\n            if (keyA !== keyB) {\n                return false;\n            }\n            else if (isTypeEqual(a.components[keyA], a.components[keyB])) {\n                continue;\n            }\n            else {\n                return false;\n            }\n        }\n        return true;\n    }\n    else if (a.kind === \"coproduct\" && b.kind === \"coproduct\") {\n        const A = getKeys(a.options);\n        const B = getKeys(b.options);\n        if (A.length !== B.length) {\n            return false;\n        }\n        for (const [keyA, keyB] of zip(A, B)) {\n            if (keyA !== keyB) {\n                return false;\n            }\n            else if (isTypeEqual(a.options[keyA], b.options[keyB])) {\n                continue;\n            }\n            else {\n                return false;\n            }\n        }\n        return true;\n    }\n    else {\n        return false;\n    }\n}\nexport function isTypeAssignable(a, b) {\n    if (a === b) {\n        return true;\n    }\n    else if (a.kind !== b.kind) {\n        return false;\n    }\n    else if (a.kind === \"reference\" && b.kind === \"reference\") {\n        return a.value === b.value;\n    }\n    else if (a.kind === \"uri\" && b.kind === \"uri\") {\n        return true;\n    }\n    else if (a.kind === \"literal\" && b.kind === \"literal\") {\n        return a.datatype === b.datatype;\n    }\n    else if (a.kind === \"product\" && b.kind === \"product\") {\n        for (const key of getKeys(b.components)) {\n            if (key in a.components &&\n                isTypeAssignable(a.components[key], b.components[key])) {\n                continue;\n            }\n            else {\n                return false;\n            }\n        }\n        return true;\n    }\n    else if (a.kind === \"coproduct\" && b.kind === \"coproduct\") {\n        for (const key of getKeys(a.options)) {\n            if (key in b.options &&\n                isTypeAssignable(a.options[key], b.options[key])) {\n                continue;\n            }\n            else {\n                return false;\n            }\n        }\n        return true;\n    }\n    else {\n        return false;\n    }\n}\nexport function unify(a, b) {\n    if (a === b) {\n        return b;\n    }\n    else if (a.kind === \"reference\" && b.kind === \"reference\") {\n        if (a.value === b.value) {\n            return b;\n        }\n    }\n    else if (a.kind === \"uri\" && b.kind === \"uri\") {\n        return b;\n    }\n    else if (a.kind === \"literal\" && b.kind === \"literal\") {\n        if (a.datatype === b.datatype) {\n            return b;\n        }\n    }\n    else if (a.kind === \"product\" && b.kind === \"product\") {\n        return Schema.product(Object.fromEntries(unifyComponents(a, b)));\n    }\n    if (a.kind === \"coproduct\" && b.kind === \"coproduct\") {\n        return Schema.coproduct(Object.fromEntries(unifyOptions(a, b)));\n    }\n    else {\n        throw new Error(\"Cannot unify unequal types\");\n    }\n}\nfunction* unifyComponents(a, b) {\n    const A = getKeys(a.components);\n    const B = getKeys(b.components);\n    if (A.length !== B.length) {\n        throw new Error(\"Cannot unify unequal products\");\n    }\n    for (const [keyA, keyB] of zip(A, B)) {\n        if (keyA !== keyB) {\n            throw new Error(\"Cannot unify unequal types\");\n        }\n        else {\n            yield [keyA, unify(a.components[keyA], b.components[keyB])];\n        }\n    }\n}\nfunction* unifyOptions(a, b) {\n    const keys = Array.from(new Set([...getKeys(a.options), ...getKeys(b.options)])).sort();\n    for (const key of keys) {\n        const A = a.options[key];\n        const B = b.options[key];\n        if (A !== undefined && B === undefined) {\n            yield [key, A];\n        }\n        else if (A === undefined && B !== undefined) {\n            yield [key, B];\n        }\n        else if (A !== undefined && B !== undefined) {\n            yield [key, unify(A, B)];\n        }\n        else {\n            throw new Error(\"Error unifying options\");\n        }\n    }\n}\n","const keyMap = new WeakMap();\nexport function* forEntries(object) {\n    for (const [index, key] of getKeys(object).entries()) {\n        yield [key, object[key], index];\n    }\n}\nexport function getKeys(object) {\n    if (keyMap.has(object)) {\n        return keyMap.get(object);\n    }\n    else {\n        const keys = Object.keys(object).sort();\n        Object.freeze(keys);\n        keyMap.set(object, keys);\n        return keys;\n    }\n}\nexport function getKeyIndex(object, key) {\n    if (keyMap.has(object)) {\n        const index = keyMap.get(object).indexOf(key);\n        if (index === -1) {\n            throw new Error(`Key not found: ${key}`);\n        }\n        return index;\n    }\n    else {\n        const keys = Object.keys(object).sort();\n        Object.freeze(keys);\n        keyMap.set(object, keys);\n        const index = keys.indexOf(key);\n        if (index === -1) {\n            throw new Error(`Key not found: ${key}`);\n        }\n        return index;\n    }\n}\nexport function mapKeys(object, map) {\n    const keys = getKeys(object);\n    const result = Object.fromEntries(keys.map((key) => [key, map(object[key], key)]));\n    keyMap.set(result, keys);\n    Object.freeze(result);\n    return result;\n}\nexport function signalInvalidType(type) {\n    console.error(type);\n    throw new Error(\"Invalid type\");\n}\nexport const zip = (...args) => ({\n    [Symbol.iterator]() {\n        const iterators = args.map((arg) => arg[Symbol.iterator]());\n        let i = 0;\n        return {\n            next() {\n                const results = iterators.map((iter) => iter.next());\n                if (results.some(({ done }) => done)) {\n                    return { done: true, value: undefined };\n                }\n                else {\n                    const values = results.map(({ value }) => value);\n                    return { done: false, value: [...values, i++] };\n                }\n            },\n        };\n    },\n});\n","import * as rdf from \"./rdf.js\";\nimport * as xsd from \"./xsd.js\";\nimport * as ul from \"./ul.js\";\nexport { rdf, xsd, ul };\n","export const type = \"http://www.w3.org/1999/02/22-rdf-syntax-ns#type\", nil = \"http://www.w3.org/1999/02/22-rdf-syntax-ns#nil\", first = \"http://www.w3.org/1999/02/22-rdf-syntax-ns#first\", rest = \"http://www.w3.org/1999/02/22-rdf-syntax-ns#rest\", langString = \"http://www.w3.org/1999/02/22-rdf-syntax-ns#langString\", JSON = \"http://www.w3.org/1999/02/22-rdf-syntax-ns#JSON\";\n","export const label = \"http://underlay.org/ns/label\", reference = \"http://underlay.org/ns/reference\", uri = \"http://underlay.org/ns/uri\", literal = \"http://underlay.org/ns/literal\", datatype = \"http://underlay.org/ns/datatype\", product = \"http://underlay.org/ns/product\", coproduct = \"http://underlay.org/ns/coproduct\", component = \"http://underlay.org/ns/component\", option = \"http://underlay.org/ns/option\", key = \"http://underlay.org/ns/key\", value = \"http://underlay.org/ns/value\", source = \"http://underlay.org/ns/source\", target = \"http://underlay.org/ns/target\", none = \"http://underlay.org/ns/none\", some = \"http://underlay.org/ns/some\", head = \"http://underlay.org/ns/head\", tail = \"http://underlay.org/ns/tail\", expression = \"http://underlay.org/ns/expression\", identity = \"http://underlay.org/ns/identity\", identifier = \"http://underlay.org/ns/identifier\", constant = \"http://underlay.org/ns/constant\", dereference = \"http://underlay.org/ns/dereference\", projection = \"http://underlay.org/ns/injection\", injection = \"http://underlay.org/ns/injection\", tuple = \"http://underlay.org/ns/tuple\", slot = \"http://underlay.org/ns/slot\", match = \"http://underlay.org/ns/match\", CASE = \"http://underlay.org/ns/case\", path = \"http://underlay.org/ns/path\", map = \"http://underlay.org/ns/map\";\n","export const string = \"http://www.w3.org/2001/XMLSchema#string\", boolean = \"http://www.w3.org/2001/XMLSchema#boolean\", Decimal = \"http://www.w3.org/2001/XMLSchema#decimal\", integer = \"http://www.w3.org/2001/XMLSchema#integer\", double = \"http://www.w3.org/2001/XMLSchema#double\", float = \"http://www.w3.org/2001/XMLSchema#float\", date = \"http://www.w3.org/2001/XMLSchema#date\", time = \"http://www.w3.org/2001/XMLSchema#time\", dateTime = \"http://www.w3.org/2001/XMLSchema#dateTime\", dateTimeStamp = \"http://www.w3.org/2001/XMLSchema#dateTimeStamp\", gYear = \"http://www.w3.org/2001/XMLSchema#gYear\", gMonth = \"http://www.w3.org/2001/XMLSchema#gMonth\", gDay = \"http://www.w3.org/2001/XMLSchema#gDay\", gYearMonth = \"http://www.w3.org/2001/XMLSchema#gYearMonth\", gMonthDay = \"http://www.w3.org/2001/XMLSchema#gMonthDay\", duration = \"http://www.w3.org/2001/XMLSchema#duration\", yearMonthDuration = \"http://www.w3.org/2001/XMLSchema#yearMonthDuration\", dayTimeDuration = \"http://www.w3.org/2001/XMLSchema#dayTimeDuration\", byte = \"http://www.w3.org/2001/XMLSchema#byte\", short = \"http://www.w3.org/2001/XMLSchema#short\", int = \"http://www.w3.org/2001/XMLSchema#int\", long = \"http://www.w3.org/2001/XMLSchema#long\", unsignedByte = \"http://www.w3.org/2001/XMLSchema#unsignedByte\", unsignedShort = \"http://www.w3.org/2001/XMLSchema#unsignedShort\", unsignedInt = \"http://www.w3.org/2001/XMLSchema#unsignedInt\", unsignedLong = \"http://www.w3.org/2001/XMLSchema#unsignedLong\", positiveInteger = \"http://www.w3.org/2001/XMLSchema#positiveInteger\", nonNegativeInteger = \"http://www.w3.org/2001/XMLSchema#nonNegativeInteger\", nonPositiveInteger = \"http://www.w3.org/2001/XMLSchema#nonPositiveInteger\", hexBinary = \"http://www.w3.org/2001/XMLSchema#hexBinary\", base64Binary = \"http://www.w3.org/2001/XMLSchema#base64Binary\", anyURI = \"http://www.w3.org/2001/XMLSchema#anyURI\", language = \"http://www.w3.org/2001/XMLSchema#language\", normalizedString = \"http://www.w3.org/2001/XMLSchema#normalizedString\", token = \"http://www.w3.org/2001/XMLSchema#token\", NMTOKEN = \"http://www.w3.org/2001/XMLSchema#NMTOKEN\", Name = \"http://www.w3.org/2001/XMLSchema#Name\", NCNames = \"http://www.w3.org/2001/XMLSchema#NCNames\";\n","// This file was generated by lezer-generator. You probably shouldn't edit it.\nimport {Parser} from \"lezer\"\nimport {NodeProp} from \"lezer\"\nconst spec_identifier = {__proto__:null,namespace:8, type:16, class:42, edge:46, list:50}\nexport const parser = Parser.deserialize({\n  version: 13,\n  states: \")`QYQPOOOkQPO'#C_OpQPO'#CcOuQQO'#CpOzQQO'#CrO!PQQO'#CtOOQO'#C|'#C|OOQO'#Cv'#CvQYQPOOOOQO'#Ca'#CaO!UQQO,58yOOQO'#Ce'#CeO!ZQPO,58}O!ZQPO,59[O!rQPO,59^O!wQPO,59`OOQO-E6t-E6tOOQO1G.e1G.eOOQO'#Cf'#CfO!ZQPO'#CgO!|QQO'#ChO#RQQO'#CkO#WQQO'#ClO#`QQO'#CnOOQO'#DO'#DOOOQO1G.i1G.iOOQO1G.v1G.vO#hQQO1G.xO!ZQPO1G.zOOQO,59R,59ROOQO,59S,59SO#mQPO,59VO#rQPO'#CmO#wQPO'#DTO$PQPO,59WO$UQQO'#CoO$aQPO'#DYO$iQPO,59YO$nQPO7+$dOOQO7+$f7+$fOOQO1G.q1G.qO!ZQPO,59XO$uQQO,59oO$}QPO,59oOOQO1G.r1G.rO!ZQPO,59ZO%VQQO,59tO%_QPO,59tOOQO1G.t1G.tO%gQQO<<HOO%lQPO<<HOOOQO1G.s1G.sOOQO,59c,59cO%qQQO1G/ZOOQO-E6u-E6uOOQO1G.u1G.uOOQO,59d,59dO%yQQO1G/`OOQO-E6v-E6vOOQOAN=jAN=jO&RQQOAN=jP&WQQO'#CwP&]QQO'#CxOOQOG23UG23U\",\n  stateData: \"&b~OoOSPOS~OSPOWQOeROgSOiTO~OqXO~OqZO~OU]O~OU^O~OU_O~OUaO~O]dO^hOqbOscOteOvfO{gO~O!PkO~O!RlO~OUnO~OUoO~OUpOzwP~OUsO!O|P~OUvO~OuxO~OxyO~OyzOzwX~Oz|O~O}}OycX!OcX~Oy!OO!O|X~O!O!QO~O!Q!RO~P!ZOUpOzwa~Oy!VOzwa~OUsO!O|a~Oy!ZO!O|a~OU!]O~O!Q!^O~OUpOzwi~OUsO!O|i~OU!aO~OUpO~OUsO~O\",\n  goto: \"#v}PPP!OP!SP!OP!V!Y!Y!YPP!Y!Y!c!Y!k!OP!OP!OP!s!y#PPPP#VP#ZPPPP#pPPPP#sTUOWRYPR[Q_h[]clvy}QqfV!Uz!V!_QtgV!Y!O!Z!`QWOR`WQ{qR!W{Q!PtR![!PTVOWQi[Qj]QmcQwlQ!SvQ!TyR!X}RrfRug\",\n  nodeNames: \"⚠ Comment Schema Namespace namespace Prefix Term Type type TypeName Variable Optional Reference Pointer Uri Literal Product Component Coproduct Option Class class Edge edge List list\",\n  maxTerm: 49,\n  nodeProps: [\n    [NodeProp.group, -7,10,11,12,14,15,16,18,\"Expression\"]\n  ],\n  skippedNodes: [0,1],\n  repeatNodeCount: 3,\n  tokenData: \"'c~RjX^!spq!sst#hz{#s}!O#x!P!Q$T![!]$f!]!^$q!^!_$v!_!`%T!`!a%f!a!b%s!c!}%x!}#O&}#P#Q'S#T#o%x#o#p'X#q#r'^#y#z!s$f$g!s#BY#BZ!s$IS$I_!s$I|$JO!s$JT$JU!s$KV$KW!s&FU&FV!s~!xYo~X^!spq!s#y#z!s$f$g!s#BY#BZ!s$IS$I_!s$I|$JO!s$JT$JU!s$KV$KW!s&FU&FV!s~#mQP~OY#hZ~#h~#xO]~~#{P!`!a$O~$TOx~~$WP!_!`$Z~$^P!`!a$a~$fO!Q~~$iP![!]$l~$qO!R~~$vOy~~${Pt~!`!a%O~%TO^~~%WP!_!`%Z~%^P!P!Q%a~%fO!P~R%kPuP}!O%nQ%sO}Q~%xOs~R&PSUQqP!Q![%x![!]&]!c!}%x#T#o%xQ&bXUQst&]}!O&]!O!P&]!P!Q&]!Q![&]![!]&]!c!}&]#R#S&]#T#o&]~'SO{~~'XO!O~~'^Ov~~'cOz~\",\n  tokenizers: [0, 1],\n  topRules: {\"Schema\":[0,2]},\n  specialized: [{term: 33, get: value => spec_identifier[value] || -1}],\n  tokenPrec: 0\n})\n","export * from \"./parse.js\";\nexport * from \"./stdlib.js\";\nexport * from \"./utils.js\";\n","import { Schema } from \"@underlay/apg\";\nimport { ul } from \"@underlay/namespaces\";\nimport { parser } from \"../grammar/tasl.js\";\nimport { LintError, namespacePattern, parseURI, uriPattern, } from \"./utils.js\";\nimport { defaultTypes } from \"./stdlib.js\";\nexport function parse(input) {\n    const tree = parser.configure({ strict: true }).parse(input);\n    const cursor = tree.cursor();\n    if (cursor.name === \"Schema\") {\n        cursor.firstChild();\n    }\n    else {\n        throw new LintError(cursor.from, cursor.to, \"\", \"Invalid top-level node\");\n    }\n    const slice = ({ from, to }) => input.slice(from, to);\n    const error = (node, message) => new LintError(node.from, node.to, slice(node), message);\n    const state = {\n        slice,\n        error,\n        namespaces: {},\n        types: { ...defaultTypes },\n        schema: {},\n        references: [],\n    };\n    do {\n        if (cursor.type.name === \"Namespace\") {\n            const term = cursor.node.getChild(\"Term\");\n            const namespace = state.slice(term);\n            if (!uriPattern.test(namespace)) {\n                throw state.error(term, `Invalid URI: URIs must match ${uriPattern.source}`);\n            }\n            else if (!namespacePattern.test(namespace)) {\n                throw state.error(term, \"Invalid namespace: namespaces must end in / or #\");\n            }\n            const identifier = cursor.node.getChild(\"Prefix\");\n            const prefix = state.slice(identifier);\n            if (prefix in state.namespaces) {\n                throw state.error(identifier, `Duplicate namespace: ${prefix}`);\n            }\n            else {\n                state.namespaces[prefix] = namespace;\n            }\n        }\n        else if (cursor.type.name === \"Type\") {\n            const identifier = cursor.node.getChild(\"TypeName\");\n            const expression = cursor.node.getChild(\"Expression\");\n            const type = parseType(state, expression);\n            const name = state.slice(identifier);\n            if (name in state.types) {\n                throw state.error(identifier, `Invalid type declaration: type ${name} has already been declared`);\n            }\n            else {\n                state.types[name] = type;\n            }\n        }\n        else if (cursor.type.name === \"Class\") {\n            const node = cursor.node.getChild(\"Term\");\n            const term = parseURI(state, node);\n            if (term in state.schema) {\n                throw state.error(node, `Invalid class declaration: class ${term} has already been declared`);\n            }\n            else {\n                const expression = cursor.node.getChild(\"Expression\");\n                state.schema[term] = parseType(state, expression);\n            }\n        }\n        else if (cursor.type.name === \"Edge\") {\n            const terms = cursor.node.getChildren(\"Term\");\n            const names = terms.map((uri) => parseURI(state, uri));\n            const expression = cursor.node.getChild(\"Expression\");\n            const value = expression && parseType(state, expression);\n            const [sourceNode, labelNode, targetNode] = terms;\n            const [source, label, target] = names;\n            if (label in state.schema) {\n                throw state.error(labelNode, `Invalid edge declaration: class ${label} has already been declared`);\n            }\n            else {\n                if (!(source in state.schema)) {\n                    const { from, to } = sourceNode;\n                    state.references.push({ from, to, key: source });\n                }\n                if (!(target in state.schema)) {\n                    const { from, to } = targetNode;\n                    state.references.push({ from, to, key: target });\n                }\n                const components = {\n                    [ul.source]: Schema.reference(source),\n                    [ul.target]: Schema.reference(target),\n                };\n                if (value !== null) {\n                    components[ul.value] = value;\n                }\n                state.schema[label] = Schema.product(components);\n            }\n        }\n        else if (cursor.type.name === \"List\") {\n            const node = cursor.node.getChild(\"Term\");\n            const term = parseURI(state, node);\n            if (term in state.schema) {\n                throw state.error(node, `Invalid list declaration: class ${term} has already been declared`);\n            }\n            else {\n                const expression = cursor.node.getChild(\"Expression\");\n                state.schema[term] = Schema.coproduct({\n                    [ul.none]: Schema.product({}),\n                    [ul.some]: Schema.product({\n                        [ul.head]: parseType(state, expression),\n                        [ul.tail]: Schema.reference(term),\n                    }),\n                });\n            }\n        }\n    } while (cursor.nextSibling());\n    for (const { from, to, key } of state.references) {\n        if (key in state.schema) {\n            continue;\n        }\n        else {\n            const message = `Invalid reference: class ${key} is not defined`;\n            throw new LintError(from, to, key, message);\n        }\n    }\n    return { schema: Schema.schema(state.schema), namespaces: state.namespaces };\n}\n// Variable | Optional | Reference  | Uri | Literal | Product | Coproduct\nexport function parseType(state, node) {\n    if (node.name === \"Variable\") {\n        const value = state.slice(node);\n        if (value in state.types) {\n            return state.types[value];\n        }\n        else {\n            throw state.error(node, `Type ${value} is not defined`);\n        }\n    }\n    else if (node.name === \"Optional\") {\n        const expression = node.getChild(\"Expression\");\n        const type = parseType(state, expression);\n        return Schema.coproduct({ [ul.none]: Schema.product({}), [ul.some]: type });\n    }\n    else if (node.name === \"Reference\") {\n        const term = node.getChild(\"Term\");\n        const key = parseURI(state, term);\n        if (!(key in state.schema)) {\n            const { from, to } = term;\n            state.references.push({ from, to, key });\n        }\n        return Schema.reference(key);\n    }\n    else if (node.name === \"Uri\") {\n        return Schema.uri();\n    }\n    else if (node.name === \"Literal\") {\n        const term = node.getChild(\"Term\");\n        const datatype = parseURI(state, term);\n        return Schema.literal(datatype);\n    }\n    else if (node.name === \"Product\") {\n        const components = {};\n        for (const component of node.getChildren(\"Component\")) {\n            const term = component.getChild(\"Term\");\n            const key = parseURI(state, term);\n            if (key in components) {\n                throw state.error(term, `Duplicate product component key: ${key}`);\n            }\n            else {\n                const expression = component.getChild(\"Expression\");\n                components[key] = parseType(state, expression);\n            }\n        }\n        return Schema.product(components);\n    }\n    else if (node.name === \"Coproduct\") {\n        const options = {};\n        for (const option of node.getChildren(\"Option\")) {\n            const term = option.getChild(\"Term\");\n            const key = parseURI(state, term);\n            if (key in options) {\n                throw state.error(term, `Duplicate coproduct option key: ${key}`);\n            }\n            else {\n                const expression = option.getChild(\"Expression\");\n                if (expression === null) {\n                    options[key] = Schema.product({});\n                }\n                else {\n                    options[key] = parseType(state, expression);\n                }\n            }\n        }\n        return Schema.coproduct(options);\n    }\n    else {\n        throw new Error(\"Unexpected Expression node\");\n    }\n}\n","import { Schema } from \"@underlay/apg\";\nimport { rdf, xsd } from \"@underlay/namespaces\";\nexport const defaultTypes = {\n    unit: Schema.product({}),\n    uri: Schema.uri(),\n    string: Schema.literal(xsd.string),\n    boolean: Schema.literal(xsd.boolean),\n    integer: Schema.literal(xsd.integer),\n    double: Schema.literal(xsd.double),\n    date: Schema.literal(xsd.date),\n    dateTime: Schema.literal(xsd.dateTime),\n    base64Binary: Schema.literal(xsd.base64Binary),\n    JSON: Schema.literal(rdf.JSON),\n};\nexport const defaultNamespaces = {\n    ul: \"http://underlay.org/ns/\",\n    xsd: \"http://www.w3.org/2001/XMLSchema#\",\n    rdf: \"http://www.w3.org/1999/02/22-rdf-syntax-ns#\",\n};\n","export class LintError extends Error {\n    constructor(from, to, value, message) {\n        super(message);\n        this.from = from;\n        this.to = to;\n        this.value = value;\n    }\n}\nexport const uriPattern = /^[a-z]+:[a-zA-Z0-9-/_.:#]+$/;\nexport const namespacePattern = /[#/]$/;\nexport function parseURI(state, node) {\n    const value = state.slice(node);\n    const index = value.indexOf(\":\");\n    if (index === -1) {\n        const { from, to } = node;\n        const message = `Invalid URI: URIs must be of the form [namespace]:[path]`;\n        throw new LintError(from, to, value, message);\n    }\n    const prefix = value.slice(0, index);\n    if (prefix in state.namespaces) {\n        return state.namespaces[prefix] + value.slice(index + 1);\n    }\n    else {\n        const { from, to } = node;\n        const message = `Invalid URI: namespace ${prefix} is not defined`;\n        throw new LintError(from, to, value, message);\n    }\n}\nexport function printSyntax(node, prefix = \"\") {\n    console.log(`${prefix}- ${node.type.name} ${node.from} ${node.to}`);\n    for (let child = node.firstChild; child !== null; child = child.nextSibling) {\n        printSyntax(child, prefix + \"  \");\n    }\n}\n","export default function crelt() {\n  var elt = arguments[0]\n  if (typeof elt == \"string\") elt = document.createElement(elt)\n  var i = 1, next = arguments[1]\n  if (next && typeof next == \"object\" && next.nodeType == null && !Array.isArray(next)) {\n    for (var name in next) if (Object.prototype.hasOwnProperty.call(next, name)) {\n      var value = next[name]\n      if (typeof value == \"string\") elt.setAttribute(name, value)\n      else if (value != null) elt[name] = value\n    }\n    i++\n  }\n  for (; i < arguments.length; i++) add(elt, arguments[i])\n  return elt\n}\n\nfunction add(elt, child) {\n  if (typeof child == \"string\") {\n    elt.appendChild(document.createTextNode(child))\n  } else if (child == null) {\n  } else if (child.nodeType != null) {\n    elt.appendChild(child)\n  } else if (Array.isArray(child)) {\n    for (var i = 0; i < child.length; i++) add(elt, child[i])\n  } else {\n    throw new RangeError(\"Unsupported child node: \" + child)\n  }\n}\n","/// The default maximum length of a `TreeBuffer` node.\nexport const DefaultBufferLength = 1024\n\nlet nextPropID = 0\n\nconst CachedNode = new WeakMap<Tree, TreeNode>()\n\n/// Each [node type](#tree.NodeType) can have metadata associated with\n/// it in props. Instances of this class represent prop names.\nexport class NodeProp<T> {\n  /// @internal\n  id: number\n\n  /// A method that deserializes a value of this prop from a string.\n  /// Can be used to allow a prop to be directly written in a grammar\n  /// file. Defaults to raising an error.\n  deserialize: (str: string) => T\n\n  /// Create a new node prop type. You can optionally pass a\n  /// `deserialize` function.\n  constructor({deserialize}: {deserialize?: (str: string) => T} = {}) {\n    this.id = nextPropID++\n    this.deserialize = deserialize || (() => {\n      throw new Error(\"This node type doesn't define a deserialize function\")\n    })\n  }\n\n  /// Create a string-valued node prop whose deserialize function is\n  /// the identity function.\n  static string() { return new NodeProp<string>({deserialize: str => str}) }\n\n  /// Create a number-valued node prop whose deserialize function is\n  /// just `Number`.\n  static number() { return new NodeProp<number>({deserialize: Number}) }\n\n  /// Creates a boolean-valued node prop whose deserialize function\n  /// returns true for any input.\n  static flag() { return new NodeProp<boolean>({deserialize: () => true}) }\n\n  /// Store a value for this prop in the given object. This can be\n  /// useful when building up a prop object to pass to the\n  /// [`NodeType`](#tree.NodeType) constructor. Returns its first\n  /// argument.\n  set(propObj: {[prop: number]: any}, value: T) {\n    propObj[this.id] = value\n    return propObj\n  }\n\n  /// This is meant to be used with\n  /// [`NodeSet.extend`](#tree.NodeSet.extend) or\n  /// [`Parser.withProps`](#lezer.Parser.withProps) to compute prop\n  /// values for each node type in the set. Takes a [match\n  /// object](#tree.NodeType^match) or function that returns undefined\n  /// if the node type doesn't get this prop, and the prop's value if\n  /// it does.\n  add(match: {[selector: string]: T} | ((type: NodeType) => T | undefined)): NodePropSource {\n    if (typeof match != \"function\") match = NodeType.match(match)\n    return (type) => {\n      let result = (match as (type: NodeType) => T | undefined)(type)\n      return result === undefined ? null : [this, result]\n    }\n  }\n\n  /// Prop that is used to describe matching delimiters. For opening\n  /// delimiters, this holds an array of node names (written as a\n  /// space-separated string when declaring this prop in a grammar)\n  /// for the node types of closing delimiters that match it.\n  static closedBy = new NodeProp<readonly string[]>({deserialize: str => str.split(\" \")})\n\n  /// The inverse of [`openedBy`](#tree.NodeProp^closedBy). This is\n  /// attached to closing delimiters, holding an array of node names\n  /// of types of matching opening delimiters.\n  static openedBy = new NodeProp<readonly string[]>({deserialize: str => str.split(\" \")})\n\n  /// Used to assign node types to groups (for example, all node\n  /// types that represent an expression could be tagged with an\n  /// `\"Expression\"` group).\n  static group = new NodeProp<readonly string[]>({deserialize: str => str.split(\" \")})\n}\n\n/// Type returned by [`NodeProp.add`](#tree.NodeProp.add). Describes\n/// the way a prop should be added to each node type in a node set.\nexport type NodePropSource = (type: NodeType) => null | [NodeProp<any>, any]\n\n// Note: this is duplicated in lezer/src/constants.ts\nconst enum NodeFlag {\n  Top = 1,\n  Skipped = 2,\n  Error = 4,\n  Anonymous = 8\n}\n\nconst noProps: {[propID: number]: any} = Object.create(null)\n\n/// Each node in a syntax tree has a node type associated with it.\nexport class NodeType {\n  /// @internal\n  constructor(\n    /// The name of the node type. Not necessarily unique, but if the\n    /// grammar was written properly, different node types with the\n    /// same name within a node set should play the same semantic\n    /// role.\n    readonly name: string,\n    /// @internal\n    readonly props: {readonly [prop: number]: any},\n    /// The id of this node in its set. Corresponds to the term ids\n    /// used in the parser.\n    readonly id: number,\n    /// @internal\n    readonly flags: number = 0) {}\n\n  static define(spec: {\n    /// The ID of the node type. When this type is used in a\n    /// [set](#tree.NodeSet), the ID must correspond to its index in\n    /// the type array.\n    id: number, \n    /// The name of the node type. Leave empty to define an anonymous\n    /// node.\n    name?: string,\n    /// [Node props](#tree.NodeProp) to assign to the type. The value\n    /// given for any given prop should correspond to the prop's type.\n    props?: readonly ([NodeProp<any>, any] | NodePropSource)[],\n    /// Whether is is a [top node](#tree.NodeType.isTop).\n    top?: boolean,\n    /// Whether this node counts as an [error\n    /// node](#tree.NodeType.isError).\n    error?: boolean,\n    /// Whether this node is a [skipped](#tree.NodeType.isSkipped)\n    /// node.\n    skipped?: boolean\n  }) {\n    let props = spec.props && spec.props.length ? Object.create(null) : noProps\n    let flags = (spec.top ? NodeFlag.Top : 0) | (spec.skipped ? NodeFlag.Skipped : 0) |\n      (spec.error ? NodeFlag.Error : 0) | (spec.name == null ? NodeFlag.Anonymous : 0)\n    let type = new NodeType(spec.name || \"\", props, spec.id, flags)\n    if (spec.props) for (let src of spec.props) {\n      if (!Array.isArray(src)) src = src(type)!\n      if (src) src[0].set(props, src[1])\n    }\n    return type\n  }\n\n  /// Retrieves a node prop for this type. Will return `undefined` if\n  /// the prop isn't present on this node.\n  prop<T>(prop: NodeProp<T>): T | undefined { return this.props[prop.id] }\n\n  /// True when this is the top node of a grammar.\n  get isTop() { return (this.flags & NodeFlag.Top) > 0 }\n\n  /// True when this node is produced by a skip rule.\n  get isSkipped() { return (this.flags & NodeFlag.Skipped) > 0 }\n\n  /// Indicates whether this is an error node.\n  get isError() { return (this.flags & NodeFlag.Error) > 0 }\n\n  /// When true, this node type doesn't correspond to a user-declared\n  /// named node, for example because it is used to cache repetition.\n  get isAnonymous() { return (this.flags & NodeFlag.Anonymous) > 0 }\n\n  /// Returns true when this node's name or one of its\n  /// [groups](#tree.NodeProp^group) matches the given string.\n  is(name: string | number) {\n    if (typeof name == 'string') {\n      if (this.name == name) return true\n      let group = this.prop(NodeProp.group)\n      return group ? group.indexOf(name) > -1 : false\n    }\n    return this.id == name\n  }\n\n  /// An empty dummy node type to use when no actual type is available.\n  static none: NodeType = new NodeType(\"\", Object.create(null), 0, NodeFlag.Anonymous)\n\n  /// Create a function from node types to arbitrary values by\n  /// specifying an object whose property names are node or\n  /// [group](#tree.NodeProp^group) names. Often useful with\n  /// [`NodeProp.add`](#tree.NodeProp.add). You can put multiple\n  /// names, separated by spaces, in a single property name to map\n  /// multiple node names to a single value.\n  static match<T>(map: {[selector: string]: T}): (node: NodeType) => T | undefined {\n    let direct = Object.create(null)\n    for (let prop in map)\n      for (let name of prop.split(\" \")) direct[name] = map[prop]\n    return (node: NodeType) => {\n      for (let groups = node.prop(NodeProp.group), i = -1; i < (groups ? groups.length : 0); i++) {\n        let found = direct[i < 0 ? node.name : groups![i]]\n        if (found) return found\n      }\n    }\n  }\n}\n\n/// A node set holds a collection of node types. It is used to\n/// compactly represent trees by storing their type ids, rather than a\n/// full pointer to the type object, in a number array. Each parser\n/// [has](#lezer.Parser.nodeSet) a node set, and [tree\n/// buffers](#tree.TreeBuffer) can only store collections of nodes\n/// from the same set. A set can have a maximum of 2**16 (65536)\n/// node types in it, so that the ids fit into 16-bit typed array\n/// slots.\nexport class NodeSet {\n  /// Create a set with the given types. The `id` property of each\n  /// type should correspond to its position within the array.\n  constructor(\n    /// The node types in this set, by id.\n    readonly types: readonly NodeType[]\n  ) {\n    for (let i = 0; i < types.length; i++) if (types[i].id != i)\n      throw new RangeError(\"Node type ids should correspond to array positions when creating a node set\")\n  }\n\n  /// Create a copy of this set with some node properties added. The\n  /// arguments to this method should be created with\n  /// [`NodeProp.add`](#tree.NodeProp.add).\n  extend(...props: NodePropSource[]): NodeSet {\n    let newTypes: NodeType[] = []\n    for (let type of this.types) {\n      let newProps = null\n      for (let source of props) {\n        let add = source(type)\n        if (add) {\n          if (!newProps) newProps = Object.assign({}, type.props)\n          add[0].set(newProps, add[1])\n        }\n      }\n      newTypes.push(newProps ? new NodeType(type.name, newProps, type.id, type.flags) : type)\n    }\n    return new NodeSet(newTypes)\n  }\n}\n\n/// A piece of syntax tree. There are two ways to approach these\n/// trees: the way they are actually stored in memory, and the\n/// convenient way.\n///\n/// Syntax trees are stored as a tree of `Tree` and `TreeBuffer`\n/// objects. By packing detail information into `TreeBuffer` leaf\n/// nodes, the representation is made a lot more memory-efficient.\n///\n/// However, when you want to actually work with tree nodes, this\n/// representation is very awkward, so most client code will want to\n/// use the `TreeCursor` interface instead, which provides a view on\n/// some part of this data structure, and can be used to move around\n/// to adjacent nodes.\nexport class Tree {\n  /// Construct a new tree. You usually want to go through\n  /// [`Tree.build`](#tree.Tree^build) instead.\n  constructor(\n    readonly type: NodeType,\n    /// The tree's child nodes. Children small enough to fit in a\n    /// `TreeBuffer will be represented as such, other children can be\n    /// further `Tree` instances with their own internal structure.\n    readonly children: readonly (Tree | TreeBuffer)[],\n    /// The positions (offsets relative to the start of this tree) of\n    /// the children.\n    readonly positions: readonly number[],\n    /// The total length of this tree\n    readonly length: number\n  ) {}\n\n  /// @internal\n  toString(): string {\n    let children = this.children.map(c => c.toString()).join()\n    return !this.type.name ? children :\n      (/\\W/.test(this.type.name) && !this.type.isError ? JSON.stringify(this.type.name) : this.type.name) +\n      (children.length ? \"(\" + children + \")\" : \"\")\n  }\n\n  /// The empty tree\n  static empty = new Tree(NodeType.none, [], [], 0)\n\n  /// Get a [tree cursor](#tree.TreeCursor) rooted at this tree. When\n  /// `pos` is given, the cursor is [moved](#tree.TreeCursor.moveTo)\n  /// to the given position and side.\n  cursor(pos?: number, side: -1 | 0 | 1 = 0): TreeCursor {\n    let scope = (pos != null && CachedNode.get(this)) || (this.topNode as TreeNode)\n    let cursor = new TreeCursor(scope)\n    if (pos != null) {\n      cursor.moveTo(pos, side)\n      CachedNode.set(this, cursor._tree)\n    }\n    return cursor\n  }\n\n  /// Get a [tree cursor](#tree.TreeCursor) that, unlike regular\n  /// cursors, doesn't skip [anonymous](#tree.NodeType.isAnonymous)\n  /// nodes.\n  fullCursor(): TreeCursor {\n    return new TreeCursor(this.topNode as TreeNode, true)\n  }\n\n  /// Get a [syntax node](#tree.SyntaxNode) object for the top of the\n  /// tree.\n  get topNode(): SyntaxNode {\n    return new TreeNode(this, 0, 0, null)\n  }\n\n  /// Get the [syntax node](#tree.SyntaxNode) at the given position.\n  /// If `side` is -1, this will move into nodes that end at the\n  /// position. If 1, it'll move into nodes that start at the\n  /// position. With 0, it'll only enter nodes that cover the position\n  /// from both sides.\n  resolve(pos: number, side: -1 | 0 | 1 = 0) {\n    return this.cursor(pos, side).node\n  }\n\n  /// Iterate over the tree and its children, calling `enter` for any\n  /// node that touches the `from`/`to` region (if given) before\n  /// running over such a node's children, and `leave` (if given) when\n  /// leaving the node. When `enter` returns `false`, the given node\n  /// will not have its children iterated over (or `leave` called).\n  iterate(spec: {\n    enter(type: NodeType, from: number, to: number): false | void,\n    leave?(type: NodeType, from: number, to: number): void,\n    from?: number,\n    to?: number\n  }) {\n    let {enter, leave, from = 0, to = this.length} = spec\n    for (let c = this.cursor();;) {\n      let mustLeave = false\n      if (c.from <= to && c.to >= from && (c.type.isAnonymous || enter(c.type, c.from, c.to) !== false)) {\n        if (c.firstChild()) continue\n        if (!c.type.isAnonymous) mustLeave = true\n      }\n      for (;;) {\n        if (mustLeave && leave) leave(c.type, c.from, c.to)\n        mustLeave = c.type.isAnonymous\n        if (c.nextSibling()) break\n        if (!c.parent()) return\n        mustLeave = true\n      }\n    }\n  }\n\n  /// Balance the direct children of this tree.\n  balance(maxBufferLength = DefaultBufferLength) {\n    return this.children.length <= BalanceBranchFactor ? this\n      : balanceRange(this.type, NodeType.none, this.children, this.positions, 0, this.children.length, 0,\n                     maxBufferLength, this.length, 0)\n  }\n\n  /// Build a tree from a postfix-ordered buffer of node information,\n  /// or a cursor over such a buffer.\n  static build(data: BuildData) { return buildTree(data) }\n}\n\n// For trees that need a context hash attached, we're using this\n// kludge which assigns an extra property directly after\n// initialization (creating a single new object shape).\nfunction withHash(tree: Tree, hash: number) {\n  if (hash) (tree as any).contextHash = hash\n  return tree\n}\n\ntype BuildData = {\n  /// The buffer or buffer cursor to read the node data from.\n  ///\n  /// When this is an array, it should contain four values for every\n  /// node in the tree.\n  ///\n  ///  - The first holds the node's type, as a node ID pointing into\n  ///    the given `NodeSet`.\n  ///  - The second holds the node's start offset.\n  ///  - The third the end offset.\n  ///  - The fourth the amount of space taken up in the array by this\n  ///    node and its children. Since there's four values per node,\n  ///    this is the total number of nodes inside this node (children\n  ///    and transitive children) plus one for the node itself, times\n  ///    four.\n  ///\n  /// Parent nodes should appear _after_ child nodes in the array. As\n  /// an example, a node of type 10 spanning positions 0 to 4, with\n  /// two children, of type 11 and 12, might look like this:\n  ///\n  ///     [11, 0, 1, 4, 12, 2, 4, 4, 10, 0, 4, 12]\n  buffer: BufferCursor | readonly number[],\n  /// The node types to use.\n  nodeSet: NodeSet,\n  /// The id of the top node type, if any.\n  topID?: number,\n  /// The position the tree should start at. Defaults to 0.\n  start?: number,\n  /// The length of the wrapping node. The end offset of the last\n  /// child is used when not provided.\n  length?: number,\n  /// The maximum buffer length to use. Defaults to\n  /// [`DefaultBufferLength`](#tree.DefaultBufferLength).\n  maxBufferLength?: number,\n  /// An optional set of reused nodes that the buffer can refer to.\n  reused?: (Tree | TreeBuffer)[],\n  /// The first node type that indicates repeat constructs in this\n  /// grammar.\n  minRepeatType?: number\n}\n\n/// Tree buffers contain (type, start, end, endIndex) quads for each\n/// node. In such a buffer, nodes are stored in prefix order (parents\n/// before children, with the endIndex of the parent indicating which\n/// children belong to it)\nexport class TreeBuffer {\n  /// Create a tree buffer @internal\n  constructor(\n    /// @internal\n    readonly buffer: Uint16Array,\n    // The total length of the group of nodes in the buffer.\n    readonly length: number,\n    /// @internal\n    readonly set: NodeSet,\n    readonly type = NodeType.none\n  ) {}\n\n  /// @internal\n  toString() {\n    let result: string[] = []\n    for (let index = 0; index < this.buffer.length;) {\n      result.push(this.childString(index))\n      index = this.buffer[index + 3]\n    }\n    return result.join(\",\")\n  }\n\n  /// @internal\n  childString(index: number): string {\n    let id = this.buffer[index], endIndex = this.buffer[index + 3]\n    let type = this.set.types[id], result = type.name\n    if (/\\W/.test(result) && !type.isError) result = JSON.stringify(result)\n    index += 4\n    if (endIndex == index) return result\n    let children: string[] = []\n    while (index < endIndex) {\n      children.push(this.childString(index))\n      index = this.buffer[index + 3]\n    }\n    return result + \"(\" + children.join(\",\") + \")\"\n  }\n\n  /// @internal\n  findChild(startIndex: number, endIndex: number, dir: 1 | -1, after: number) {\n    let {buffer} = this, pick = -1\n    for (let i = startIndex; i != endIndex; i = buffer[i + 3]) {\n      if (after != After.None) {\n        let start = buffer[i + 1], end = buffer[i + 2]\n        if (dir > 0) {\n          if (end > after) pick = i\n          if (end > after) break\n        } else {\n          if (start < after) pick = i\n          if (end >= after) break\n        }\n      } else {\n        pick = i\n        if (dir > 0) break\n      }\n    }\n    return pick\n  }\n}\n\nconst enum After { None = -1e8 }\n\n/// A syntax node provides an immutable pointer at a given node in a\n/// tree. When iterating over large amounts of nodes, you may want to\n/// use a mutable [cursor](#tree.TreeCursor) instead, which is more\n/// efficient.\nexport interface SyntaxNode {\n  /// The type of the node.\n  type: NodeType\n  /// The name of the node (`.type.name`).\n  name: string\n  /// The start position of the node.\n  from: number\n  /// The end position of the node.\n  to: number\n\n  /// The node's parent node, if any.\n  parent: SyntaxNode | null\n  /// The first child, if the node has children.\n  firstChild: SyntaxNode | null\n  /// The node's last child, if available.\n  lastChild: SyntaxNode | null\n  /// The first child that starts at or after `pos`.\n  childAfter(pos: number): SyntaxNode | null\n  /// The last child that ends at or before `pos`.\n  childBefore(pos: number): SyntaxNode | null\n  /// This node's next sibling, if any.\n  nextSibling: SyntaxNode | null\n  /// This node's previous sibling.\n  prevSibling: SyntaxNode | null\n  /// A [tree cursor](#tree.TreeCursor) starting at this node.\n  cursor: TreeCursor\n  /// Find the node around, before (if `side` is -1), or after (`side`\n  /// is 1) the given position. Will look in parent nodes if the\n  /// position is outside this node.\n  resolve(pos: number, side?: -1 | 0 | 1): SyntaxNode\n\n  /// Get the first child of the given type (which may be a [node\n  /// name](#tree.NodeProp.name) or a [group\n  /// name](#tree.NodeProp^group)). If `before` is non-null, only\n  /// return children that occur somewhere after a node with that name\n  /// or group. If `after` is non-null, only return children that\n  /// occur somewhere before a node with that name or group.\n  getChild(type: string | number, before?: string | number | null, after?: string | number | null): SyntaxNode | null\n\n  /// Like [`getChild`](#tree.SyntaxNode.getChild), but return all\n  /// matching children, not just the first.\n  getChildren(type: string | number, before?: string | number | null, after?: string | number | null): SyntaxNode[]\n}\n\nclass TreeNode implements SyntaxNode {\n  constructor(readonly node: Tree,\n              readonly from: number,\n              readonly index: number,\n              readonly _parent: TreeNode | null) {}\n\n  get type() { return this.node.type }\n\n  get name() { return this.node.type.name }\n\n  get to() { return this.from + this.node.length }\n\n  nextChild(i: number, dir: 1 | -1, after: number, full = false): TreeNode | BufferNode | null {\n    for (let parent: TreeNode = this;;) {\n      for (let {children, positions} = parent.node, e = dir > 0 ? children.length : -1; i != e; i += dir) {\n        let next = children[i], start = positions[i] + parent.from\n        if (after != After.None && (dir < 0 ? start >= after : start + next.length <= after))\n          continue\n        if (next instanceof TreeBuffer) {\n          let index = next.findChild(0, next.buffer.length, dir, after == After.None ? After.None : after - start)\n          if (index > -1) return new BufferNode(new BufferContext(parent, next, i, start), null, index)\n        } else if (full || (!next.type.isAnonymous || hasChild(next))) {\n          let inner = new TreeNode(next, start, i, parent)\n          return full || !inner.type.isAnonymous ? inner : inner.nextChild(dir < 0 ? next.children.length - 1 : 0, dir, after)\n        }\n      }\n      if (full || !parent.type.isAnonymous) return null\n      i = parent.index + dir\n      parent = parent._parent!\n      if (!parent) return null\n    }\n  }\n\n  get firstChild() { return this.nextChild(0, 1, After.None) }\n  get lastChild() { return this.nextChild(this.node.children.length - 1, -1, After.None) }\n\n  childAfter(pos: number) { return this.nextChild(0, 1, pos) }\n  childBefore(pos: number) { return this.nextChild(this.node.children.length - 1, -1, pos) }\n\n  nextSignificantParent() {\n    let val: TreeNode = this\n    while (val.type.isAnonymous && val._parent) val = val._parent\n    return val\n  }\n\n  get parent() {\n    return this._parent ? this._parent.nextSignificantParent() : null\n  }\n\n  get nextSibling() {\n    return this._parent ? this._parent.nextChild(this.index + 1, 1, -1) : null\n  }\n  get prevSibling() {\n    return this._parent ? this._parent.nextChild(this.index - 1, -1, -1) : null\n  }\n\n  get cursor() { return new TreeCursor(this) }\n\n  resolve(pos: number, side: -1 | 0 | 1 = 0) {\n    return this.cursor.moveTo(pos, side).node\n  }\n\n  getChild(type: string | number, before: string | number | null = null, after: string | number | null = null) {\n    let r = getChildren(this, type, before, after)\n    return r.length ? r[0] : null\n  }\n\n  getChildren(type: string | number, before: string | number | null = null, after: string | number | null = null) {\n    return getChildren(this, type, before, after)\n  }\n\n  /// @internal\n  toString() { return this.node.toString() }\n}\n\nfunction getChildren(node: SyntaxNode, type: string | number, before: string | number | null, after: string | number | null): SyntaxNode[] {\n  let cur = node.cursor, result: SyntaxNode[] = []\n  if (!cur.firstChild()) return result\n  if (before != null) while (!cur.type.is(before)) if (!cur.nextSibling()) return result\n  for (;;) {\n    if (after != null && cur.type.is(after)) return result\n    if (cur.type.is(type)) result.push(cur.node)\n    if (!cur.nextSibling()) return after == null ? result : []\n  }\n}\n\nclass BufferContext {\n  constructor(readonly parent: TreeNode,\n              readonly buffer: TreeBuffer,\n              readonly index: number,\n              readonly start: number) {}\n}\n\nclass BufferNode implements SyntaxNode {\n  type: NodeType\n\n  get name() { return this.type.name }\n\n  get from() { return this.context.start + this.context.buffer.buffer[this.index + 1] }\n\n  get to() { return this.context.start + this.context.buffer.buffer[this.index + 2] }\n\n  constructor(readonly context: BufferContext,\n              readonly _parent: BufferNode | null,\n              readonly index: number) {\n    this.type = context.buffer.set.types[context.buffer.buffer[index]]\n  }\n\n  child(dir: 1 | -1, after: number): BufferNode | null {\n    let {buffer} = this.context\n    let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir,\n                                 after == After.None ? After.None : after - this.context.start)\n    return index < 0 ? null : new BufferNode(this.context, this, index)\n  }\n\n  get firstChild() { return this.child(1, After.None) }\n  get lastChild() { return this.child(-1, After.None) }\n\n  childAfter(pos: number) { return this.child(1, pos) }\n  childBefore(pos: number) { return this.child(-1, pos) }\n\n  get parent() {\n    return this._parent || this.context.parent.nextSignificantParent()\n  }\n\n  externalSibling(dir: 1 | -1) {\n    return this._parent ? null : this.context.parent.nextChild(this.context.index + dir, dir, -1)\n  }\n\n  get nextSibling(): SyntaxNode | null {\n    let {buffer} = this.context\n    let after = buffer.buffer[this.index + 3]\n    if (after < (this._parent ? buffer.buffer[this._parent.index + 3] : buffer.buffer.length))\n      return new BufferNode(this.context, this._parent, after)\n    return this.externalSibling(1)\n  }\n\n  get prevSibling(): SyntaxNode | null {\n    let {buffer} = this.context\n    let parentStart = this._parent ? this._parent.index + 4 : 0\n    if (this.index == parentStart) return this.externalSibling(-1)\n    return new BufferNode(this.context, this._parent, buffer.findChild(parentStart, this.index, -1, After.None))\n  }\n\n  get cursor() { return new TreeCursor(this) }\n\n  resolve(pos: number, side: -1 | 0 | 1 = 0) {\n    return this.cursor.moveTo(pos, side).node\n  }\n\n  /// @internal\n  toString() { return this.context.buffer.childString(this.index) }\n\n  getChild(type: string | number, before: string | number | null = null, after: string | number | null = null) {\n    let r = getChildren(this, type, before, after)\n    return r.length ? r[0] : null\n  }\n\n  getChildren(type: string | number, before: string | number | null = null, after: string | number | null = null) {\n    return getChildren(this, type, before, after)\n  }\n}\n\n/// A tree cursor object focuses on a given node in a syntax tree, and\n/// allows you to move to adjacent nodes.\nexport class TreeCursor {\n  /// The node's type.\n  type!: NodeType\n\n  /// Shorthand for `.type.name`.\n  get name() { return this.type.name }\n\n  /// The start source offset of this node.\n  from!: number\n\n  /// The end source offset.\n  to!: number\n\n  /// @internal\n  _tree!: TreeNode\n  private buffer: BufferContext | null = null\n  private stack: number[] = []\n  private index: number = 0\n  private bufferNode: BufferNode | null = null\n\n  /// @internal\n  constructor(node: TreeNode | BufferNode, readonly full = false) {\n    if (node instanceof TreeNode) {\n      this.yieldNode(node)\n    } else {\n      this._tree = node.context.parent\n      this.buffer = node.context\n      for (let n: BufferNode | null = node._parent; n; n = n._parent) this.stack.unshift(n.index)\n      this.bufferNode = node\n      this.yieldBuf(node.index)\n    }\n  }\n\n  private yieldNode(node: TreeNode | null) {\n    if (!node) return false\n    this._tree = node\n    this.type = node.type\n    this.from = node.from\n    this.to = node.to\n    return true\n  }\n\n  private yieldBuf(index: number, type?: NodeType) {\n    this.index = index\n    let {start, buffer} = this.buffer!\n    this.type = type || buffer.set.types[buffer.buffer[index]]\n    this.from = start + buffer.buffer[index + 1]\n    this.to = start + buffer.buffer[index + 2]\n    return true\n  }\n\n  private yield(node: TreeNode | BufferNode | null) {\n    if (!node) return false\n    if (node instanceof TreeNode) {\n      this.buffer = null\n      return this.yieldNode(node)\n    }\n    this.buffer = node.context\n    return this.yieldBuf(node.index, node.type)\n  }\n\n  /// @internal\n  toString() {\n    return this.buffer ? this.buffer.buffer.childString(this.index) : this._tree.toString()\n  }\n\n  /// @internal\n  enter(dir: 1 | -1, after: number) {\n    if (!this.buffer)\n      return this.yield(this._tree.nextChild(dir < 0 ? this._tree.node.children.length - 1 : 0, dir, after, this.full))\n\n    let {buffer} = this.buffer\n    let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir,\n                                 after == After.None ? After.None : after - this.buffer.start)\n    if (index < 0) return false\n    this.stack.push(this.index)\n    return this.yieldBuf(index)\n  }\n\n  /// Move the cursor to this node's first child. When this returns\n  /// false, the node has no child, and the cursor has not been moved.\n  firstChild() { return this.enter(1, After.None) }\n\n  /// Move the cursor to this node's last child.\n  lastChild() { return this.enter(-1, After.None) }\n\n  /// Move the cursor to the first child that starts at or after `pos`.\n  childAfter(pos: number) { return this.enter(1, pos) }\n\n  /// Move to the last child that ends at or before `pos`.\n  childBefore(pos: number) { return this.enter(-1, pos) }\n\n  /// Move the node's parent node, if this isn't the top node.\n  parent() {\n    if (!this.buffer) return this.yieldNode(this.full ? this._tree._parent : this._tree.parent)\n    if (this.stack.length) return this.yieldBuf(this.stack.pop()!)\n    let parent = this.full ? this.buffer.parent : this.buffer.parent.nextSignificantParent()\n    this.buffer = null\n    return this.yieldNode(parent)\n  }\n\n  /// @internal\n  sibling(dir: 1 | -1) {\n    if (!this.buffer)\n      return !this._tree._parent ? false\n        : this.yield(this._tree._parent.nextChild(this._tree.index + dir, dir, After.None, this.full))\n\n    let {buffer} = this.buffer, d = this.stack.length - 1\n    if (dir < 0) {\n      let parentStart = d < 0 ? 0 : this.stack[d] + 4\n      if (this.index != parentStart)\n        return this.yieldBuf(buffer.findChild(parentStart, this.index, -1, After.None))\n    } else {\n      let after = buffer.buffer[this.index + 3]\n      if (after < (d < 0 ? buffer.buffer.length : buffer.buffer[this.stack[d] + 3]))\n        return this.yieldBuf(after)\n    }\n    return d < 0 ? this.yield(this.buffer.parent.nextChild(this.buffer.index + dir, dir, After.None, this.full)) : false\n  }\n\n  /// Move to this node's next sibling, if any.\n  nextSibling() { return this.sibling(1) }\n\n  /// Move to this node's previous sibling, if any.\n  prevSibling() { return this.sibling(-1) }\n\n  private atLastNode(dir: 1 | -1) {\n    let index, parent: TreeNode | null, {buffer} = this\n    if (buffer) {\n      if (dir > 0) {\n        if (this.index < buffer.buffer.buffer.length) return false\n      } else {\n        for (let i = 0; i < this.index; i++) if (buffer.buffer.buffer[i + 3] < this.index) return false\n      }\n      ;({index, parent} = buffer)\n    } else {\n      ({index, _parent: parent} = this._tree)\n    }\n    for (; parent; {index, _parent: parent} = parent) {\n      for (let i = index + dir, e = dir < 0 ? -1 : parent.node.children.length; i != e; i += dir) {\n        let child = parent.node.children[i]\n        if (this.full || !child.type.isAnonymous || child instanceof TreeBuffer || hasChild(child)) return false\n      }\n    }\n    return true\n  }\n\n  private move(dir: 1 | -1) {\n    if (this.enter(dir, After.None)) return true\n    for (;;) {\n      if (this.sibling(dir)) return true\n      if (this.atLastNode(dir) || !this.parent()) return false\n    }\n  }\n\n  /// Move to the next node in a\n  /// [pre-order](https://en.wikipedia.org/wiki/Tree_traversal#Pre-order_(NLR))\n  /// traversal, going from a node to its first child or, if the\n  /// current node is empty, its next sibling or the next sibling of\n  /// the first parent node that has one.\n  next() { return this.move(1) }\n\n  /// Move to the next node in a last-to-first pre-order traveral. A\n  /// node is followed by ist last child or, if it has none, its\n  /// previous sibling or the previous sibling of the first parent\n  /// node that has one.\n  prev() { return this.move(-1) }\n\n  /// Move the cursor to the innermost node that covers `pos`. If\n  /// `side` is -1, it will enter nodes that end at `pos`. If it is 1,\n  /// it will enter nodes that start at `pos`.\n  moveTo(pos: number, side: -1 | 0 | 1 = 0) {\n    // Move up to a node that actually holds the position, if possible\n    while (this.from == this.to ||\n           (side < 1 ? this.from >= pos : this.from > pos) ||\n           (side > -1 ? this.to <= pos : this.to < pos))\n      if (!this.parent()) break\n\n    // Then scan down into child nodes as far as possible\n    for (;;) {\n      if (side < 0 ? !this.childBefore(pos) : !this.childAfter(pos)) break\n      if (this.from == this.to ||\n          (side < 1 ? this.from >= pos : this.from > pos) ||\n          (side > -1 ? this.to <= pos : this.to < pos)) {\n        this.parent()\n        break\n      }\n    }\n    return this\n  }\n\n  /// Get a [syntax node](#tree.SyntaxNode) at the cursor's current\n  /// position.\n  get node(): SyntaxNode {\n    if (!this.buffer) return this._tree\n    \n    let cache = this.bufferNode, result: BufferNode | null = null, depth = 0\n    if (cache && cache.context == this.buffer) {\n      scan: for (let index = this.index, d = this.stack.length; d >= 0;) {\n        for (let c: BufferNode | null = cache; c; c = c._parent) if (c.index == index) {\n          if (index == this.index) return c\n          result = c\n          depth = d + 1\n          break scan\n        }\n        index = this.stack[--d]\n      }\n    }\n    for (let i = depth; i < this.stack.length; i++) result = new BufferNode(this.buffer, result, this.stack[i])\n    return this.bufferNode = new BufferNode(this.buffer, result, this.index)\n  }\n\n  /// Get the [tree](#tree.Tree) that represents the current node, if\n  /// any. Will return null when the node is in a [tree\n  /// buffer](#tree.TreeBuffer).\n  get tree(): Tree | null {\n    return this.buffer ? null : this._tree.node\n  }\n}\n\nfunction hasChild(tree: Tree): boolean {\n  return tree.children.some(ch => !ch.type.isAnonymous || ch instanceof TreeBuffer || hasChild(ch))\n}\n\n/// This is used by `Tree.build` as an abstraction for iterating over\n/// a tree buffer. A cursor initially points at the very last element\n/// in the buffer. Every time `next()` is called it moves on to the\n/// previous one.\nexport interface BufferCursor {\n  /// The current buffer position (four times the number of nodes\n  /// remaining).\n  pos: number\n  /// The node ID of the next node in the buffer.\n  id: number\n  /// The start position of the next node in the buffer.\n  start: number\n  /// The end position of the next node.\n  end: number\n  /// The size of the next node (the number of nodes inside, counting\n  /// the node itself, times 4).\n  size: number\n  /// Moves `this.pos` down by 4.\n  next(): void\n  /// Create a copy of this cursor.\n  fork(): BufferCursor\n}\n\nclass FlatBufferCursor implements BufferCursor {\n  constructor(readonly buffer: readonly number[], public index: number) {}\n\n  get id() { return this.buffer[this.index - 4] }\n  get start() { return this.buffer[this.index - 3] }\n  get end() { return this.buffer[this.index - 2] }\n  get size() { return this.buffer[this.index - 1] }\n\n  get pos() { return this.index }\n\n  next() { this.index -= 4 }\n\n  fork() { return new FlatBufferCursor(this.buffer, this.index) }\n}\n\nconst BalanceBranchFactor = 8\n\nfunction buildTree(data: BuildData) {\n  let {buffer, nodeSet, topID = 0,\n       maxBufferLength = DefaultBufferLength,\n       reused = [],\n       minRepeatType = nodeSet.types.length} = data as BuildData\n  let cursor = Array.isArray(buffer) ? new FlatBufferCursor(buffer, buffer.length) : buffer as BufferCursor\n  let types = nodeSet.types\n\n  let contextHash = 0\n\n  function takeNode(parentStart: number, minPos: number,\n                    children: (Tree | TreeBuffer)[], positions: number[],\n                    inRepeat: number) {\n    let {id, start, end, size} = cursor\n    let startPos = start - parentStart\n    if (size < 0) {\n      if (size == -1) { // Reused node\n        children.push(reused[id])\n        positions.push(startPos)\n      } else { // Context change\n        contextHash = id\n      }\n      cursor.next()\n      return\n    }\n\n    let type = types[id], node, buffer: {size: number, start: number, skip: number} | undefined\n    if (end - start <= maxBufferLength && (buffer = findBufferSize(cursor.pos - minPos, inRepeat))) {\n      // Small enough for a buffer, and no reused nodes inside\n      let data = new Uint16Array(buffer.size - buffer.skip)\n      let endPos = cursor.pos - buffer.size, index = data.length\n      while (cursor.pos > endPos)\n        index = copyToBuffer(buffer.start, data, index, inRepeat)\n      node = new TreeBuffer(data, end - buffer.start, nodeSet, inRepeat < 0 ? NodeType.none : types[inRepeat])\n      startPos = buffer.start - parentStart\n    } else { // Make it a node\n      let endPos = cursor.pos - size\n      cursor.next()\n      let localChildren: (Tree | TreeBuffer)[] = [], localPositions: number[] = []\n      let localInRepeat = id >= minRepeatType ? id : -1\n      while (cursor.pos > endPos) {\n        if (cursor.id == localInRepeat) cursor.next()\n        else takeNode(start, endPos, localChildren, localPositions, localInRepeat)\n      }\n      localChildren.reverse(); localPositions.reverse()\n\n      if (localInRepeat > -1 && localChildren.length > BalanceBranchFactor)\n        node = balanceRange(type, type, localChildren, localPositions, 0, localChildren.length, 0, maxBufferLength,\n                            end - start, contextHash)\n      else\n        node = withHash(new Tree(type, localChildren, localPositions, end - start), contextHash)\n    }\n\n    children.push(node)\n    positions.push(startPos)\n  }\n\n  function findBufferSize(maxSize: number, inRepeat: number) {\n    // Scan through the buffer to find previous siblings that fit\n    // together in a TreeBuffer, and don't contain any reused nodes\n    // (which can't be stored in a buffer).\n    // If `inRepeat` is > -1, ignore node boundaries of that type for\n    // nesting, but make sure the end falls either at the start\n    // (`maxSize`) or before such a node.\n    let fork = cursor.fork()\n    let size = 0, start = 0, skip = 0, minStart = fork.end - maxBufferLength\n    let result = {size: 0, start: 0, skip: 0}\n    scan: for (let minPos = fork.pos - maxSize; fork.pos > minPos;) {\n      // Pretend nested repeat nodes of the same type don't exist\n      if (fork.id == inRepeat) {\n        // Except that we store the current state as a valid return\n        // value.\n        result.size = size; result.start = start; result.skip = skip\n        skip += 4; size += 4\n        fork.next()\n        continue\n      }\n      let nodeSize = fork.size, startPos = fork.pos - nodeSize\n      if (nodeSize < 0 || startPos < minPos || fork.start < minStart) break\n      let localSkipped = fork.id >= minRepeatType ? 4 : 0\n      let nodeStart = fork.start\n      fork.next()\n      while (fork.pos > startPos) {\n        if (fork.size < 0) break scan\n        if (fork.id >= minRepeatType) localSkipped += 4\n        fork.next()\n      }\n      start = nodeStart\n      size += nodeSize\n      skip += localSkipped\n    }\n    if (inRepeat < 0 || size == maxSize) {\n      result.size = size; result.start = start; result.skip = skip\n    }\n    return result.size > 4 ? result : undefined\n  }\n\n  function copyToBuffer(bufferStart: number, buffer: Uint16Array, index: number, inRepeat: number): number {\n    let {id, start, end, size} = cursor\n    cursor.next()\n    if (id == inRepeat) return index\n    let startIndex = index\n    if (size > 4) {\n      let endPos = cursor.pos - (size - 4)\n      while (cursor.pos > endPos)\n        index = copyToBuffer(bufferStart, buffer, index, inRepeat)\n    }\n    if (id < minRepeatType) { // Don't copy repeat nodes into buffers\n      buffer[--index] = startIndex\n      buffer[--index] = end - bufferStart\n      buffer[--index] = start - bufferStart\n      buffer[--index] = id\n    }\n    return index\n  }\n\n  let children: (Tree | TreeBuffer)[] = [], positions: number[] = []\n  while (cursor.pos > 0) takeNode(data.start || 0, 0, children, positions, -1)\n  let length = data.length ?? (children.length ? positions[0] + children[0].length : 0)\n  return new Tree(types[topID], children.reverse(), positions.reverse(), length)\n}\n\nfunction balanceRange(outerType: NodeType, innerType: NodeType,\n                      children: readonly (Tree | TreeBuffer)[], positions: readonly number[],\n                      from: number, to: number,\n                      start: number, maxBufferLength: number,\n                      length: number, contextHash: number): Tree {\n  let localChildren: (Tree | TreeBuffer)[] = [], localPositions: number[] = []\n  if (length <= maxBufferLength) {\n    for (let i = from; i < to; i++) {\n      localChildren.push(children[i])\n      localPositions.push(positions[i] - start)\n    }\n  } else {\n    let maxChild = Math.max(maxBufferLength, Math.ceil(length * 1.5 / BalanceBranchFactor))\n    for (let i = from; i < to;) {\n      let groupFrom = i, groupStart = positions[i]\n      i++\n      for (; i < to; i++) {\n        let nextEnd = positions[i] + children[i].length\n        if (nextEnd - groupStart > maxChild) break\n      }\n      if (i == groupFrom + 1) {\n        let only = children[groupFrom]\n        if (only instanceof Tree && only.type == innerType && only.length > maxChild << 1) { // Too big, collapse\n          for (let j = 0; j < only.children.length; j++) {\n            localChildren.push(only.children[j])\n            localPositions.push(only.positions[j] + groupStart - start)\n          }\n          continue\n        }\n        localChildren.push(only)\n      } else if (i == groupFrom + 1) {\n        localChildren.push(children[groupFrom])\n      } else {\n        let inner = balanceRange(innerType, innerType, children, positions, groupFrom, i, groupStart,\n                                 maxBufferLength, positions[i - 1] + children[i - 1].length - groupStart, contextHash)\n        if (innerType != NodeType.none && !containsType(inner.children, innerType))\n          inner = withHash(new Tree(NodeType.none, inner.children, inner.positions, inner.length), contextHash)\n        localChildren.push(inner)\n      }\n      localPositions.push(groupStart - start)\n    }\n  }\n  return withHash(new Tree(outerType, localChildren, localPositions, length), contextHash)\n}\n\nfunction containsType(nodes: readonly (Tree | TreeBuffer)[], type: NodeType) {\n  for (let elt of nodes) if (elt.type == type) return true\n  return false\n}\n\n/// The [`TreeFragment.applyChanges`](#tree.TreeFragment^applyChanges)\n/// method expects changed ranges in this format.\nexport interface ChangedRange {\n  /// The start of the change in the start document\n  fromA: number\n  /// The end of the change in the start document\n  toA: number\n  /// The start of the replacement in the new document\n  fromB: number\n  /// The end of the replacement in the new document\n  toB: number\n}\n\nconst enum Open { Start = 1, End = 2 }\n\n/// Tree fragments are used during [incremental\n/// parsing](#lezer.ParseOptions.fragments) to track parts of old\n/// trees that can be reused in a new parse. An array of fragments is\n/// used to track regions of an old tree whose nodes might be reused\n/// in new parses. Use the static\n/// [`applyChanges`](#tree.TreeFragment^applyChanges) method to update\n/// fragments for document changes.\nexport class TreeFragment {\n  constructor(\n    /// The start of the unchanged range pointed to by this fragment.\n    /// This refers to an offset in the _updated_ document (as opposed\n    /// to the original tree).\n    readonly from: number,\n    /// The end of the unchanged range.\n    readonly to: number,\n    /// The tree that this fragment is based on.\n    readonly tree: Tree,\n    /// The offset between the fragment's tree and the document that\n    /// this fragment can be used against. Add this when going from\n    /// document to tree positions, subtract it to go from tree to\n    /// document positions.\n    readonly offset: number,\n    private open: number\n  ) {}\n\n  get openStart() { return (this.open & Open.Start) > 0 }\n\n  get openEnd() { return (this.open & Open.End) > 0 }\n\n  /// Apply a set of edits to an array of fragments, removing or\n  /// splitting fragments as necessary to remove edited ranges, and\n  /// adjusting offsets for fragments that moved.\n  static applyChanges(fragments: readonly TreeFragment[], changes: readonly ChangedRange[], minGap = 128) {\n    if (!changes.length) return fragments\n    let result: TreeFragment[] = []\n    let fI = 1, nextF = fragments.length ? fragments[0] : null\n    let cI = 0, pos = 0, off = 0\n    for (;;) {\n      let nextC = cI < changes.length ? changes[cI++] : null\n      let nextPos = nextC ? nextC.fromA : 1e9\n      if (nextPos - pos >= minGap) while (nextF && nextF.from < nextPos) {\n        let cut: TreeFragment | null = nextF\n        if (pos >= cut.from || nextPos <= cut.to || off) {\n          let fFrom = Math.max(cut.from, pos) - off, fTo = Math.min(cut.to, nextPos) - off\n          cut = fFrom >= fTo ? null :\n            new TreeFragment(fFrom, fTo, cut.tree, cut.offset + off,\n                             (cI > 0 ? Open.Start : 0) | (nextC ? Open.End : 0))\n        }\n        if (cut) result.push(cut)\n        if (nextF.to > nextPos) break\n        nextF = fI < fragments.length ? fragments[fI++] : null\n      }\n      if (!nextC) break\n      pos = nextC.toA\n      off = nextC.toA - nextC.toB\n    }\n    return result\n  }\n\n  /// Create a set of fragments from a freshly parsed tree, or update\n  /// an existing set of fragments by replacing the ones that overlap\n  /// with a tree with content from the new tree. When `partial` is\n  /// true, the parse is treated as incomplete, and the token at its\n  /// end is not included in [`safeTo`](#tree.TreeFragment.safeTo).\n  static addTree(tree: Tree, fragments: readonly TreeFragment[] = [], partial = false) {\n    let result = [new TreeFragment(0, tree.length, tree, 0, partial ? Open.End : 0)]\n    for (let f of fragments) if (f.to > tree.length) result.push(f)\n    return result\n  }\n}\n\n/// Interface used to represent an in-progress parse, which can be\n/// moved forward piece-by-piece.\nexport interface PartialParse {\n  /// Advance the parse state by some amount.\n  advance(): Tree | null\n  /// The current parse position.\n  pos: number\n  /// Get the currently parsed content as a tree, even though the\n  /// parse hasn't finished yet.\n  forceFinish(): Tree\n}\n\n/// A parse context is an object providing additional information to the\n/// parser. It is passed through to nested parsers.\nexport interface ParseContext {\n  /// A set of fragments from a previous parse to be used for incremental\n  /// parsing. These should be aligned with the current document\n  /// (through a call to\n  /// [`TreeFragment.applyChanges`](#tree.TreeFragment^applyChanges))\n  /// if any changes were made since they were produced. The parser\n  /// will try to reuse nodes from the fragments in the new parse,\n  /// greatly speeding up the parse when it can do so for most of the\n  /// document.\n  fragments?: readonly TreeFragment[]\n}\n\n/// This is the interface the parser uses to access the document. It\n/// exposes a sequence of UTF16 code units. Most (but not _all_)\n/// access, especially through `get`, will be sequential, so\n/// implementations can optimize for that.\nexport interface Input {\n  /// The end of the stream.\n  length: number\n  /// Get the code unit at the given position. Will return -1 when\n  /// asked for a point below 0 or beyond the end of the stream.\n  get(pos: number): number\n  /// Returns the string between `pos` and the next newline character\n  /// or the end of the document. Not used by the built-in tokenizers,\n  /// but can be useful in custom tokenizers or completely custom\n  /// parsers.\n  lineAfter(pos: number): string\n  /// Read part of the stream as a string\n  read(from: number, to: number): string\n  /// Return a new `Input` over the same data, but with a lower\n  /// `length`. Used, for example, when nesting grammars to give the\n  /// inner grammar a narrower view of the input.\n  clip(at: number): Input\n}\n\n// Creates an `Input` that is backed by a single, flat string.\nexport function stringInput(input: string): Input { return new StringInput(input) }\n\nclass StringInput implements Input {\n  constructor(readonly string: string, readonly length = string.length) {}\n\n  get(pos: number) {\n    return pos < 0 || pos >= this.length ? -1 : this.string.charCodeAt(pos)\n  }\n\n  lineAfter(pos: number) {\n    if (pos < 0) return \"\"\n    let end = this.string.indexOf(\"\\n\", pos)\n    return this.string.slice(pos, end < 0 ? this.length : Math.min(end, this.length))\n  }\n  \n  read(from: number, to: number): string { return this.string.slice(from, Math.min(this.length, to)) }\n\n  clip(at: number) { return new StringInput(this.string, at) }\n}\n","import {Action, Term, StateFlag, ParseState, Seq} from \"./constants\"\nimport {Parse, ContextTracker} from \"./parse\"\nimport {Tree, TreeBuffer, BufferCursor} from \"lezer-tree\"\n\n/// A parse stack. These are used internally by the parser to track\n/// parsing progress. They also provide some properties and methods\n/// that external code such as a tokenizer can use to get information\n/// about the parse state.\nexport class Stack {\n  /// @internal\n  constructor(\n    /// A the parse that this stack is part of @internal\n    readonly p: Parse,\n    /// Holds state, pos, value stack pos (15 bits array index, 15 bits\n    /// buffer index) triplets for all but the top state\n    /// @internal\n    readonly stack: number[],\n    /// The current parse state @internal\n    public state: number,\n    // The position at which the next reduce should take place. This\n    // can be less than `this.pos` when skipped expressions have been\n    // added to the stack (which should be moved outside of the next\n    // reduction)\n    /// @internal\n    public reducePos: number,\n    /// The input position up to which this stack has parsed.\n    public pos: number,\n    /// The dynamic score of the stack, including dynamic precedence\n    /// and error-recovery penalties\n    /// @internal\n    public score: number,\n    // The output buffer. Holds (type, start, end, size) quads\n    // representing nodes created by the parser, where `size` is\n    // amount of buffer array entries covered by this node.\n    /// @internal\n    readonly buffer: number[],\n    // The base offset of the buffer. When stacks are split, the split\n    // instance shared the buffer history with its parent up to\n    // `bufferBase`, which is the absolute offset (including the\n    // offset of previous splits) into the buffer at which this stack\n    // starts writing.\n    /// @internal\n    readonly bufferBase: number,\n    /// @internal\n    public curContext: StackContext | null,\n    // A parent stack from which this was split off, if any. This is\n    // set up so that it always points to a stack that has some\n    // additional buffer content, never to a stack with an equal\n    // `bufferBase`.\n    /// @internal\n    readonly parent: Stack | null\n  ) {}\n\n  /// @internal\n  toString() {\n    return `[${this.stack.filter((_, i) => i % 3 == 0).concat(this.state)}]@${this.pos}${this.score ? \"!\" + this.score : \"\"}`\n  }\n\n  // Start an empty stack\n  /// @internal\n  static start(p: Parse, state: number, pos = 0) {\n    let cx = p.parser.context\n    return new Stack(p, [], state, pos, pos, 0, [], 0, cx ? new StackContext(cx, cx.start) : null, null)\n  }\n\n  /// The stack's current [context](#lezer.ContextTracker) value, if\n  /// any. Its type will depend on the context tracker's type\n  /// parameter, or it will be `null` if there is no context\n  /// tracker.\n  get context() { return this.curContext ? this.curContext.context : null }\n\n  // Push a state onto the stack, tracking its start position as well\n  // as the buffer base at that point.\n  /// @internal\n  pushState(state: number, start: number) {\n    this.stack.push(this.state, start, this.bufferBase + this.buffer.length)\n    this.state = state\n  }\n\n  // Apply a reduce action\n  /// @internal\n  reduce(action: number) {\n    let depth = action >> Action.ReduceDepthShift, type = action & Action.ValueMask\n    let {parser} = this.p\n\n    let dPrec = parser.dynamicPrecedence(type)\n    if (dPrec) this.score += dPrec\n\n    if (depth == 0) {\n      // Zero-depth reductions are a special case—they add stuff to\n      // the stack without popping anything off.\n      if (type < parser.minRepeatTerm) this.storeNode(type, this.reducePos, this.reducePos, 4, true)\n      this.pushState(parser.getGoto(this.state, type, true), this.reducePos)\n      this.reduceContext(type)\n      return\n    }\n\n    // Find the base index into `this.stack`, content after which will\n    // be dropped. Note that with `StayFlag` reductions we need to\n    // consume two extra frames (the dummy parent node for the skipped\n    // expression and the state that we'll be staying in, which should\n    // be moved to `this.state`).\n    let base = this.stack.length - ((depth - 1) * 3) - (action & Action.StayFlag ? 6 : 0)\n    let start = this.stack[base - 2]\n    let bufferBase = this.stack[base - 1], count = this.bufferBase + this.buffer.length - bufferBase\n    // Store normal terms or `R -> R R` repeat reductions\n    if (type < parser.minRepeatTerm || (action & Action.RepeatFlag)) {\n      let pos = parser.stateFlag(this.state, StateFlag.Skipped) ? this.pos : this.reducePos\n      this.storeNode(type, start, pos, count + 4, true)\n    }\n    if (action & Action.StayFlag) {\n      this.state = this.stack[base]\n    } else {\n      let baseStateID = this.stack[base - 3]\n      this.state = parser.getGoto(baseStateID, type, true)\n    }\n    while (this.stack.length > base) this.stack.pop()\n    this.reduceContext(type)\n  }\n\n  // Shift a value into the buffer\n  /// @internal\n  storeNode(term: number, start: number, end: number, size = 4, isReduce = false) {\n    if (term == Term.Err) { // Try to omit/merge adjacent error nodes\n      let cur: Stack | null = this, top = this.buffer.length\n      if (top == 0 && cur.parent) {\n        top = cur.bufferBase - cur.parent.bufferBase\n        cur = cur.parent\n      }\n      if (top > 0 && cur.buffer[top - 4] == Term.Err && cur.buffer[top - 1] > -1) {\n        if (start == end) return\n        if (cur.buffer[top - 2] >= start) { cur.buffer[top - 2] = end; return }\n      }\n    }\n\n    if (!isReduce || this.pos == end) { // Simple case, just append\n      this.buffer.push(term, start, end, size)\n    } else { // There may be skipped nodes that have to be moved forward\n      let index = this.buffer.length\n      if (index > 0 && this.buffer[index - 4] != Term.Err) while (index > 0 && this.buffer[index - 2] > end) {\n        // Move this record forward\n        this.buffer[index] = this.buffer[index - 4]\n        this.buffer[index + 1] = this.buffer[index - 3]\n        this.buffer[index + 2] = this.buffer[index - 2]\n        this.buffer[index + 3] = this.buffer[index - 1]\n        index -= 4\n        if (size > 4) size -= 4\n      }\n      this.buffer[index] = term\n      this.buffer[index + 1] = start\n      this.buffer[index + 2] = end\n      this.buffer[index + 3] = size\n    }\n  }\n\n  // Apply a shift action\n  /// @internal\n  shift(action: number, next: number, nextEnd: number) {\n    if (action & Action.GotoFlag) {\n      this.pushState(action & Action.ValueMask, this.pos)\n    } else if ((action & Action.StayFlag) == 0) { // Regular shift\n      let start = this.pos, nextState = action, {parser} = this.p\n      if (nextEnd > this.pos || next <= parser.maxNode) {\n        this.pos = nextEnd\n        if (!parser.stateFlag(nextState, StateFlag.Skipped)) this.reducePos = nextEnd\n      }\n      this.pushState(nextState, start)\n      if (next <= parser.maxNode) this.buffer.push(next, start, nextEnd, 4)\n      this.shiftContext(next)\n    } else { // Shift-and-stay, which means this is a skipped token\n      if (next <= this.p.parser.maxNode) this.buffer.push(next, this.pos, nextEnd, 4)\n      this.pos = nextEnd\n    }\n  }\n\n  // Apply an action\n  /// @internal\n  apply(action: number, next: number, nextEnd: number) {\n    if (action & Action.ReduceFlag) this.reduce(action)\n    else this.shift(action, next, nextEnd)\n  }\n\n  // Add a prebuilt node into the buffer. This may be a reused node or\n  // the result of running a nested parser.\n  /// @internal\n  useNode(value: Tree | TreeBuffer, next: number) {\n    let index = this.p.reused.length - 1\n    if (index < 0 || this.p.reused[index] != value) {\n      this.p.reused.push(value)\n      index++\n    }\n    let start = this.pos\n    this.reducePos = this.pos = start + value.length\n    this.pushState(next, start)\n    this.buffer.push(index, start, this.reducePos, -1 /* size < 0 means this is a reused value */)\n    if (this.curContext) this.updateContext(this.curContext.tracker.reuse(this.curContext.context, value, this.p.input, this))\n  }\n\n  // Split the stack. Due to the buffer sharing and the fact\n  // that `this.stack` tends to stay quite shallow, this isn't very\n  // expensive.\n  /// @internal\n  split() {\n    let parent: Stack | null = this\n    let off = parent.buffer.length\n    // Because the top of the buffer (after this.pos) may be mutated\n    // to reorder reductions and skipped tokens, and shared buffers\n    // should be immutable, this copies any outstanding skipped tokens\n    // to the new buffer, and puts the base pointer before them.\n    while (off > 0 && parent.buffer[off - 2] > parent.reducePos) off -= 4\n    let buffer = parent.buffer.slice(off), base = parent.bufferBase + off\n    // Make sure parent points to an actual parent with content, if there is such a parent.\n    while (parent && base == parent.bufferBase) parent = parent.parent\n    return new Stack(this.p, this.stack.slice(), this.state, this.reducePos, this.pos,\n                     this.score, buffer, base, this.curContext, parent)\n  }\n\n  // Try to recover from an error by 'deleting' (ignoring) one token.\n  /// @internal\n  recoverByDelete(next: number, nextEnd: number) {\n    let isNode = next <= this.p.parser.maxNode\n    if (isNode) this.storeNode(next, this.pos, nextEnd)\n    this.storeNode(Term.Err, this.pos, nextEnd, isNode ? 8 : 4)\n    this.pos = this.reducePos = nextEnd\n    this.score -= Recover.Token\n  }\n\n  /// Check if the given term would be able to be shifted (optionally\n  /// after some reductions) on this stack. This can be useful for\n  /// external tokenizers that want to make sure they only provide a\n  /// given token when it applies.\n  canShift(term: number) {\n    for (let sim = new SimulatedStack(this);;) {\n      let action = this.p.parser.stateSlot(sim.top, ParseState.DefaultReduce) || this.p.parser.hasAction(sim.top, term)\n      if ((action & Action.ReduceFlag) == 0) return true\n      if (action == 0) return false\n      sim.reduce(action)\n    }\n  }\n\n  /// Find the start position of the rule that is currently being parsed.\n  get ruleStart() {\n    for (let state = this.state, base = this.stack.length;;) {\n      let force = this.p.parser.stateSlot(state, ParseState.ForcedReduce)\n      if (!(force & Action.ReduceFlag)) return 0\n      base -= 3 * (force >> Action.ReduceDepthShift)\n      if ((force & Action.ValueMask) < this.p.parser.minRepeatTerm)\n        return this.stack[base + 1]\n      state = this.stack[base]\n    }\n  }\n\n  /// Find the start position of an instance of any of the given term\n  /// types, or return `null` when none of them are found.\n  ///\n  /// **Note:** this is only reliable when there is at least some\n  /// state that unambiguously matches the given rule on the stack.\n  /// I.e. if you have a grammar like this, where the difference\n  /// between `a` and `b` is only apparent at the third token:\n  ///\n  ///     a { b | c }\n  ///     b { \"x\" \"y\" \"x\" }\n  ///     c { \"x\" \"y\" \"z\" }\n  ///\n  /// Then a parse state after `\"x\"` will not reliably tell you that\n  /// `b` is on the stack. You _can_ pass `[b, c]` to reliably check\n  /// for either of those two rules (assuming that `a` isn't part of\n  /// some rule that includes other things starting with `\"x\"`).\n  ///\n  /// When `before` is given, this keeps scanning up the stack until\n  /// it finds a match that starts before that position.\n  ///\n  /// Note that you have to be careful when using this in tokenizers,\n  /// since it's relatively easy to introduce data dependencies that\n  /// break incremental parsing by using this method.\n  startOf(types: readonly number[], before?: number) {\n    let state = this.state, frame = this.stack.length, {parser} = this.p\n    for (;;) {\n      let force = parser.stateSlot(state, ParseState.ForcedReduce)\n      let depth = force >> Action.ReduceDepthShift, term = force & Action.ValueMask\n      if (types.indexOf(term) > -1) {\n        let base = frame - (3 * (force >> Action.ReduceDepthShift)), pos = this.stack[base + 1]\n        if (before == null || before > pos) return pos\n      }\n      if (frame == 0) return null\n      if (depth == 0) {\n        frame -= 3\n        state = this.stack[frame]\n      } else {\n        frame -= 3 * (depth - 1)\n        state = parser.getGoto(this.stack[frame - 3], term, true)\n      }\n    }\n  }\n\n  // Apply up to Recover.MaxNext recovery actions that conceptually\n  // inserts some missing token or rule.\n  /// @internal\n  recoverByInsert(next: number): Stack[] {\n    if (this.stack.length >= Recover.MaxInsertStackDepth) return []\n\n    let nextStates = this.p.parser.nextStates(this.state)\n    if (nextStates.length > Recover.MaxNext << 1 || this.stack.length >= Recover.DampenInsertStackDepth) {\n      let best = []\n      for (let i = 0, s; i < nextStates.length; i += 2) {\n        if ((s = nextStates[i + 1]) != this.state && this.p.parser.hasAction(s, next))\n          best.push(nextStates[i], s)\n      }\n      if (this.stack.length < Recover.DampenInsertStackDepth)\n        for (let i = 0; best.length < Recover.MaxNext << 1 && i < nextStates.length; i += 2) {\n          let s = nextStates[i + 1]\n          if (!best.some((v, i) => (i & 1) && v == s)) best.push(nextStates[i], s)\n        }\n      nextStates = best\n    }\n    let result: Stack[] = []\n    for (let i = 0; i < nextStates.length && result.length < Recover.MaxNext; i += 2) {\n      let s = nextStates[i + 1]\n      if (s == this.state) continue\n      let stack = this.split()\n      stack.storeNode(Term.Err, stack.pos, stack.pos, 4, true)\n      stack.pushState(s, this.pos)\n      stack.shiftContext(nextStates[i])\n      stack.score -= Recover.Token\n      result.push(stack)\n    }\n    return result\n  }\n\n  // Force a reduce, if possible. Return false if that can't\n  // be done.\n  /// @internal\n  forceReduce() {\n    let reduce = this.p.parser.stateSlot(this.state, ParseState.ForcedReduce)\n    if ((reduce & Action.ReduceFlag) == 0) return false\n    if (!this.p.parser.validAction(this.state, reduce)) {\n      this.storeNode(Term.Err, this.reducePos, this.reducePos, 4, true)\n      this.score -= Recover.Reduce\n    }\n    this.reduce(reduce)\n    return true\n  }\n\n  /// @internal\n  forceAll() {\n    while (!this.p.parser.stateFlag(this.state, StateFlag.Accepting) && this.forceReduce()) {}\n    return this\n  }\n\n  /// Check whether this state has no further actions (assumed to be a direct descendant of the\n  /// top state, since any other states must be able to continue\n  /// somehow). @internal\n  get deadEnd() {\n    if (this.stack.length != 3) return false\n    let {parser} = this.p\n    return parser.data[parser.stateSlot(this.state, ParseState.Actions)] == Seq.End &&\n      !parser.stateSlot(this.state, ParseState.DefaultReduce)\n  }\n\n  /// Restart the stack (put it back in its start state). Only safe\n  /// when this.stack.length == 3 (state is directly below the top\n  /// state). @internal\n  restart() {\n    this.state = this.stack[0]\n    this.stack.length = 0\n  }\n\n  /// @internal\n  sameState(other: Stack) {\n    if (this.state != other.state || this.stack.length != other.stack.length) return false\n    for (let i = 0; i < this.stack.length; i += 3)\n      if (this.stack[i] != other.stack[i]) return false\n    return true\n  }\n\n  /// Get the parser used by this stack.\n  get parser() { return this.p.parser }\n\n  /// Test whether a given dialect (by numeric ID, as exported from\n  /// the terms file) is enabled.\n  dialectEnabled(dialectID: number) { return this.p.parser.dialect.flags[dialectID] }\n\n  private shiftContext(term: number) {\n    if (this.curContext)\n      this.updateContext(this.curContext.tracker.shift(this.curContext.context, term, this.p.input, this))\n  }\n\n  private reduceContext(term: number) {\n    if (this.curContext)\n      this.updateContext(this.curContext.tracker.reduce(this.curContext.context, term, this.p.input, this))\n  }\n\n  /// @internal\n  emitContext() {\n    let cx = this.curContext!\n    if (!cx.tracker.strict) return\n    let last = this.buffer.length - 1\n    if (last < 0 || this.buffer[last] != -2)\n      this.buffer.push(cx.hash, this.reducePos, this.reducePos, -2)\n  }\n\n  private updateContext(context: any) {\n    if (context != this.curContext!.context) {\n      let newCx = new StackContext(this.curContext!.tracker, context)\n      if (newCx.hash != this.curContext!.hash) this.emitContext()\n      this.curContext = newCx\n    }\n  }\n}\n\nclass StackContext {\n  readonly hash: number\n  constructor(readonly tracker: ContextTracker<any>, readonly context: any) {\n    this.hash = tracker.hash(context)\n  }\n}\n\nexport const enum Recover {\n  Token = 200,\n  Reduce = 100,\n  MaxNext = 4,\n  MaxInsertStackDepth = 300,\n  DampenInsertStackDepth = 120\n}\n\n// Used to cheaply run some reductions to scan ahead without mutating\n// an entire stack\nclass SimulatedStack {\n  top: number\n  rest: number[]\n  offset: number\n\n  constructor(readonly stack: Stack) {\n    this.top = stack.state\n    this.rest = stack.stack\n    this.offset = this.rest.length\n  }\n\n  reduce(action: number) {\n    let term = action & Action.ValueMask, depth = action >> Action.ReduceDepthShift\n    if (depth == 0) {\n      if (this.rest == this.stack.stack) this.rest = this.rest.slice()\n      this.rest.push(this.top, 0, 0)\n      this.offset += 3\n    } else {\n      this.offset -= (depth - 1) * 3\n    }\n    let goto = this.stack.p.parser.getGoto(this.rest[this.offset - 3], term, true)\n    this.top = goto\n  }\n}\n\n// This is given to `Tree.build` to build a buffer, and encapsulates\n// the parent-stack-walking necessary to read the nodes.\nexport class StackBufferCursor implements BufferCursor {\n  buffer: number[]\n\n  constructor(public stack: Stack, public pos: number, public index: number) {\n    this.buffer = stack.buffer\n    if (this.index == 0) this.maybeNext()\n  }\n\n  static create(stack: Stack) {\n    return new StackBufferCursor(stack, stack.bufferBase + stack.buffer.length, stack.buffer.length)\n  }\n\n  maybeNext() {\n    let next = this.stack.parent\n    if (next != null) {\n      this.index = this.stack.bufferBase - next.bufferBase\n      this.stack = next\n      this.buffer = next.buffer\n    }\n  }\n\n  get id() { return this.buffer[this.index - 4] }\n  get start() { return this.buffer[this.index - 3] }\n  get end() { return this.buffer[this.index - 2] }\n  get size() { return this.buffer[this.index - 1] }\n\n  next() {\n    this.index -= 4\n    this.pos -= 4\n    if (this.index == 0) this.maybeNext()\n  }\n\n  fork() {\n    return new StackBufferCursor(this.stack, this.pos, this.index)\n  }\n}\n","import {Input} from \"lezer-tree\"\nimport {Stack} from \"./stack\"\n\n/// Tokenizers write the tokens they read into instances of this class.\nexport class Token {\n  /// The start of the token. This is set by the parser, and should not\n  /// be mutated by the tokenizer.\n  start = -1\n  /// This starts at -1, and should be updated to a term id when a\n  /// matching token is found.\n  value = -1\n  /// When setting `.value`, you should also set `.end` to the end\n  /// position of the token. (You'll usually want to use the `accept`\n  /// method.)\n  end = -1\n\n  /// Accept a token, setting `value` and `end` to the given values.\n  accept(value: number, end: number) {\n    this.value = value\n    this.end = end\n  }\n}\n\nexport interface Tokenizer {\n  token(input: Input, token: Token, stack: Stack): void\n  contextual: boolean\n  fallback: boolean\n  extend: boolean\n}\n\n/// @internal\nexport class TokenGroup implements Tokenizer {\n  contextual!: boolean\n  fallback!: boolean\n  extend!: boolean\n\n  constructor(readonly data: Readonly<Uint16Array>, readonly id: number) {}\n\n  token(input: Input, token: Token, stack: Stack) { readToken(this.data, input, token, stack, this.id) }\n}\n\nTokenGroup.prototype.contextual = TokenGroup.prototype.fallback = TokenGroup.prototype.extend = false\n\ninterface ExternalOptions {\n  /// When set to true, mark this tokenizer as depending on the\n  /// current parse stack, which prevents its result from being cached\n  /// between parser actions at the same positions.\n  contextual?: boolean,\n  /// By defaults, when a tokenizer returns a token, that prevents\n  /// tokenizers with lower precedence from even running. When\n  /// `fallback` is true, the tokenizer is allowed to run when a\n  /// previous tokenizer returned a token that didn't match any of the\n  /// current state's actions.\n  fallback?: boolean\n  /// When set to true, tokenizing will not stop after this tokenizer\n  /// has produced a token. (But it will still fail to reach this one\n  /// if a higher-precedence tokenizer produced a token.)\n  extend?: boolean\n}\n\n/// Exports that are used for `@external tokens` in the grammar should\n/// export an instance of this class.\nexport class ExternalTokenizer {\n  /// @internal\n  contextual: boolean\n  /// @internal\n  fallback: boolean\n  /// @internal\n  extend: boolean\n\n  /// Create a tokenizer. The first argument is the function that,\n  /// given an input stream and a token object,\n  /// [fills](#lezer.Token.accept) the token object if it recognizes a\n  /// token. `token.start` should be used as the start position to\n  /// scan from.\n  constructor(\n    /// @internal\n    readonly token: (input: Input, token: Token, stack: Stack) => void,\n    options: ExternalOptions = {}\n  ) {\n    this.contextual = !!options.contextual\n    this.fallback = !!options.fallback\n    this.extend = !!options.extend\n  }\n}\n\n// Tokenizer data is stored a big uint16 array containing, for each\n// state:\n//\n//  - A group bitmask, indicating what token groups are reachable from\n//    this state, so that paths that can only lead to tokens not in\n//    any of the current groups can be cut off early.\n//\n//  - The position of the end of the state's sequence of accepting\n//    tokens\n//\n//  - The number of outgoing edges for the state\n//\n//  - The accepting tokens, as (token id, group mask) pairs\n//\n//  - The outgoing edges, as (start character, end character, state\n//    index) triples, with end character being exclusive\n//\n// This function interprets that data, running through a stream as\n// long as new states with the a matching group mask can be reached,\n// and updating `token` when it matches a token.\nfunction readToken(data: Readonly<Uint16Array>,\n                   input: Input,\n                   token: Token,\n                   stack: Stack,\n                   group: number) {\n  let state = 0, groupMask = 1 << group, dialect = stack.p.parser.dialect\n  scan: for (let pos = token.start;;) {\n    if ((groupMask & data[state]) == 0) break\n    let accEnd = data[state + 1]\n    // Check whether this state can lead to a token in the current group\n    // Accept tokens in this state, possibly overwriting\n    // lower-precedence / shorter tokens\n    for (let i = state + 3; i < accEnd; i += 2) if ((data[i + 1] & groupMask) > 0) {\n      let term = data[i]\n      if (dialect.allows(term) &&\n          (token.value == -1 || token.value == term || stack.p.parser.overrides(term, token.value))) {\n        token.accept(term, pos)\n        break\n      }\n    }\n    let next = input.get(pos++)\n    // Do a binary search on the state's edges\n    for (let low = 0, high = data[state + 2]; low < high;) {\n      let mid = (low + high) >> 1\n      let index = accEnd + mid + (mid << 1)\n      let from = data[index], to = data[index + 1]\n      if (next < from) high = mid\n      else if (next >= to) low = mid + 1\n      else { state = data[index + 2]; continue scan }\n    }\n    break\n  }\n}\n","// See lezer-generator/src/encode.ts for comments about the encoding\n// used here\n\nimport {Encode} from \"./constants\"\n\nexport function decodeArray<T extends {[i: number]: number} = Uint16Array>(\n  input: string | T,\n  Type: {new (n: number): T} = Uint16Array as any\n): T {\n  if (typeof input != \"string\") return input\n  let array: T | null = null\n  for (let pos = 0, out = 0; pos < input.length;) {\n    let value = 0\n    for (;;) {\n      let next = input.charCodeAt(pos++), stop = false\n      if (next == Encode.BigValCode) { value = Encode.BigVal; break }\n      if (next >= Encode.Gap2) next--\n      if (next >= Encode.Gap1) next--\n      let digit = next - Encode.Start\n      if (digit >= Encode.Base) { digit -= Encode.Base; stop = true }\n      value += digit\n      if (stop) break\n      value *= Encode.Base\n    }\n    if (array) array[out++] = value\n    else array = new Type(value)\n  }\n  return array!\n}\n","import {DefaultBufferLength, Tree, TreeBuffer, TreeFragment, NodeSet, NodeType, NodeProp, NodePropSource,\n        Input, stringInput, PartialParse, ParseContext} from \"lezer-tree\"\nimport {Stack, StackBufferCursor} from \"./stack\"\nimport {Action, Specialize, Term, Seq, StateFlag, ParseState, File} from \"./constants\"\nimport {Token, Tokenizer, TokenGroup, ExternalTokenizer} from \"./token\"\nimport {decodeArray} from \"./decode\"\n\n// FIXME find some way to reduce recovery work done when the input\n// doesn't match the grammar at all.\n\n// Environment variable used to control console output\nconst verbose = typeof process != \"undefined\" && /\\bparse\\b/.test(process.env.LOG!)\n\nlet stackIDs: WeakMap<Stack, string> | null = null\n\n/// Used to configure a [nested parse](#lezer.Parser.withNested).\nexport type NestedParserSpec = {\n  /// The inner parser. Will be passed the input,\n  /// [clipped](#lezer.Input.clip) to the size of the parseable\n  /// region, the start position of the inner region as `startPos`,\n  /// and an optional array of tree fragments from a previous parse\n  /// that can be reused.\n  ///\n  /// When this property isn't given, the inner region is simply\n  /// skipped over intead of parsed.\n  startParse?: (input: Input, startPos: number, context: ParseContext) => PartialParse\n  /// When given, an additional node will be wrapped around the\n  /// part of the tree produced by this inner parse.\n  wrapType?: NodeType | number\n  /// When given, this will be called with the token that ends the\n  /// inner region. It can return `false` to cause a given end token\n  /// to be ignored.\n  filterEnd?(endToken: string): boolean\n}\n\n/// This type is used to specify a nested parser. It may directly be a\n/// nested parse [spec](#lezer.NestedParseSpec), or a function that,\n/// given an input document and a stack, returns such a spec or `null`\n/// to indicate that the nested parse should not happen (and the\n/// grammar's fallback expression should be used).\nexport type NestedParser = NestedParserSpec | ((input: Input, stack: Stack) => NestedParserSpec | null)\n\nfunction cutAt(tree: Tree, pos: number, side: 1 | -1) {\n  let cursor = tree.cursor(pos)\n  for (;;) {\n    if (!(side < 0 ? cursor.childBefore(pos) : cursor.childAfter(pos))) for (;;) {\n      if ((side < 0 ? cursor.to <= pos : cursor.from >= pos) && !cursor.type.isError)\n        return side < 0 ? Math.max(0, Math.min(cursor.to - 1, pos - 5)) : Math.min(tree.length, Math.max(cursor.from + 1, pos + 5))\n      if (side < 0 ? cursor.prevSibling() : cursor.nextSibling()) break\n      if (!cursor.parent()) return side < 0 ? 0 : tree.length\n    }\n  }\n}\n\nclass FragmentCursor {\n  i = 0\n  fragment: TreeFragment | null = null\n  safeFrom = -1\n  safeTo = -1\n  trees: Tree[] = []\n  start: number[] = []\n  index: number[] = []\n  nextStart!: number\n\n  constructor(readonly fragments: readonly TreeFragment[]) {\n    this.nextFragment()\n  }\n\n  nextFragment() {\n    let fr = this.fragment = this.i == this.fragments.length ? null : this.fragments[this.i++]\n    if (fr) {\n      this.safeFrom = fr.openStart ? cutAt(fr.tree, fr.from + fr.offset, 1) - fr.offset : fr.from\n      this.safeTo = fr.openEnd ? cutAt(fr.tree, fr.to + fr.offset, -1) - fr.offset : fr.to\n      while (this.trees.length) { this.trees.pop(); this.start.pop(); this.index.pop() }\n      this.trees.push(fr.tree)\n      this.start.push(-fr.offset)\n      this.index.push(0)\n      this.nextStart = this.safeFrom\n    } else {\n      this.nextStart = 1e9\n    }\n  }\n\n  // `pos` must be >= any previously given `pos` for this cursor\n  nodeAt(pos: number): Tree | TreeBuffer | null {\n    if (pos < this.nextStart) return null\n    while (this.fragment && this.safeTo <= pos) this.nextFragment()\n    if (!this.fragment) return null\n\n    for (;;) {\n      let last = this.trees.length - 1\n      if (last < 0) { // End of tree\n        this.nextFragment()\n        return null\n      }\n      let top = this.trees[last], index = this.index[last]\n      if (index == top.children.length) {\n        this.trees.pop()\n        this.start.pop()\n        this.index.pop()\n        continue\n      }\n      let next = top.children[index]\n      let start = this.start[last] + top.positions[index]\n      if (start > pos) {\n        this.nextStart = start\n        return null\n      } else if (start == pos && start + next.length <= this.safeTo) {\n        return start == pos && start >= this.safeFrom ? next : null\n      }\n      if (next instanceof TreeBuffer) {\n        this.index[last]++\n        this.nextStart = start + next.length\n      } else {\n        this.index[last]++\n        if (start + next.length >= pos) { // Enter this node\n          this.trees.push(next)\n          this.start.push(start)\n          this.index.push(0)\n        }\n      }\n    }\n  }\n}\n\nclass CachedToken extends Token {\n  extended = -1\n  mask = 0\n  context = 0\n\n  clear(start: number) {\n    this.start = start\n    this.value = this.extended = -1\n  }\n}\n\nconst dummyToken = new Token\n\nclass TokenCache {\n  tokens: CachedToken[] = []\n  mainToken: Token = dummyToken\n\n  actions: number[] = []\n\n  constructor(parser: Parser) {\n    this.tokens = parser.tokenizers.map(_ => new CachedToken)\n  }\n\n  getActions(stack: Stack, input: Input) {\n    let actionIndex = 0\n    let main: Token | null = null\n    let {parser} = stack.p, {tokenizers} = parser\n\n    let mask = parser.stateSlot(stack.state, ParseState.TokenizerMask)\n    let context = stack.curContext ? stack.curContext.hash : 0\n    for (let i = 0; i < tokenizers.length; i++) {\n      if (((1 << i) & mask) == 0) continue\n      let tokenizer = tokenizers[i], token = this.tokens[i]\n      if (main && !tokenizer.fallback) continue\n      if (tokenizer.contextual || token.start != stack.pos || token.mask != mask || token.context != context) {\n        this.updateCachedToken(token, tokenizer, stack, input)\n        token.mask = mask\n        token.context = context\n      }\n\n      if (token.value != Term.Err) {\n        let startIndex = actionIndex\n        if (token.extended > -1) actionIndex = this.addActions(stack, token.extended, token.end, actionIndex)\n        actionIndex = this.addActions(stack, token.value, token.end, actionIndex)\n        if (!tokenizer.extend) {\n          main = token\n          if (actionIndex > startIndex) break\n        }\n      }\n    }\n\n    while (this.actions.length > actionIndex) this.actions.pop()\n    if (!main) {\n      main = dummyToken\n      main.start = stack.pos\n      if (stack.pos == input.length) main.accept(stack.p.parser.eofTerm, stack.pos)\n      else main.accept(Term.Err, stack.pos + 1)\n    }\n    this.mainToken = main\n    return this.actions\n  }\n\n  updateCachedToken(token: CachedToken, tokenizer: Tokenizer, stack: Stack, input: Input) {\n    token.clear(stack.pos)\n    tokenizer.token(input, token, stack)\n    if (token.value > -1) {\n      let {parser} = stack.p\n\n      for (let i = 0; i < parser.specialized.length; i++) if (parser.specialized[i] == token.value) {\n        let result = parser.specializers[i](input.read(token.start, token.end), stack)\n        if (result >= 0 && stack.p.parser.dialect.allows(result >> 1)) {\n          if ((result & 1) == Specialize.Specialize) token.value = result >> 1\n          else token.extended = result >> 1\n          break\n        }\n      }\n    } else if (stack.pos == input.length) {\n      token.accept(stack.p.parser.eofTerm, stack.pos)\n    } else {\n      token.accept(Term.Err, stack.pos + 1)\n    }\n  }\n\n  putAction(action: number, token: number, end: number, index: number) {\n    // Don't add duplicate actions\n    for (let i = 0; i < index; i += 3) if (this.actions[i] == action) return index\n    this.actions[index++] = action\n    this.actions[index++] = token\n    this.actions[index++] = end\n    return index\n  }\n\n  addActions(stack: Stack, token: number, end: number, index: number) {\n    let {state} = stack, {parser} = stack.p, {data} = parser\n    for (let set = 0; set < 2; set++) {\n      for (let i = parser.stateSlot(state, set ? ParseState.Skip : ParseState.Actions);; i += 3) {\n        if (data[i] == Seq.End) {\n          if (data[i + 1] == Seq.Next) {\n            i = pair(data, i + 2)\n          } else {\n            if (index == 0 && data[i + 1] == Seq.Other)\n              index = this.putAction(pair(data, i + 1), token, end, index)\n            break\n          }\n        }\n        if (data[i] == token) index = this.putAction(pair(data, i + 1), token, end, index)\n      }\n    }\n    return index\n  }\n}\n\nconst enum Rec {\n  Distance = 5,\n  MaxRemainingPerStep = 3,\n  MinBufferLengthPrune = 200,\n  ForceReduceLimit = 10\n}\n\n/// A parse context can be used for step-by-step parsing. After\n/// creating it, you repeatedly call `.advance()` until it returns a\n/// tree to indicate it has reached the end of the parse.\nexport class Parse implements PartialParse {\n  // Active parse stacks.\n  stacks: Stack[]\n  // The position to which the parse has advanced.\n  pos = 0\n  recovering = 0\n  fragments: FragmentCursor | null\n  nextStackID = 0x2654\n  nested: PartialParse | null = null\n  nestEnd = 0\n  nestWrap: NodeType | null = null\n\n  reused: (Tree | TreeBuffer)[] = []\n  tokens: TokenCache\n  topTerm: number\n\n  constructor(\n    public parser: Parser,\n    public input: Input,\n    public startPos: number,\n    public context: ParseContext\n  ) {\n    this.tokens = new TokenCache(parser)\n    this.topTerm = parser.top[1]\n    this.stacks = [Stack.start(this, parser.top[0], this.startPos)]\n    let fragments = context?.fragments\n    this.fragments = fragments && fragments.length ? new FragmentCursor(fragments) : null\n  }\n\n  // Move the parser forward. This will process all parse stacks at\n  // `this.pos` and try to advance them to a further position. If no\n  // stack for such a position is found, it'll start error-recovery.\n  //\n  // When the parse is finished, this will return a syntax tree. When\n  // not, it returns `null`.\n  advance() {\n    if (this.nested) {\n      let result = this.nested.advance()\n      this.pos = this.nested.pos\n      if (result) {\n        this.finishNested(this.stacks[0], result)\n        this.nested = null\n      }\n      return null\n    }\n\n    let stacks = this.stacks, pos = this.pos\n    // This will hold stacks beyond `pos`.\n    let newStacks: Stack[] = this.stacks = []\n    let stopped: Stack[] | undefined, stoppedTokens: number[] | undefined\n    let maybeNest\n\n    // Keep advancing any stacks at `pos` until they either move\n    // forward or can't be advanced. Gather stacks that can't be\n    // advanced further in `stopped`.\n    for (let i = 0; i < stacks.length; i++) {\n      let stack = stacks[i], nest\n      for (;;) {\n        if (stack.pos > pos) {\n          newStacks.push(stack)\n        } else if (nest = this.checkNest(stack)) {\n          if (!maybeNest || maybeNest.stack.score < stack.score) maybeNest = nest\n        } else if (this.advanceStack(stack, newStacks, stacks)) {\n          continue\n        } else {\n          if (!stopped) { stopped = []; stoppedTokens = [] }\n          stopped.push(stack)\n          let tok = this.tokens.mainToken\n          stoppedTokens!.push(tok.value, tok.end)\n        }\n        break\n      }\n    }\n\n    if (maybeNest) {\n      this.startNested(maybeNest)\n      return null\n    }\n\n    if (!newStacks.length) {\n      let finished = stopped && findFinished(stopped)\n      if (finished) return this.stackToTree(finished)\n\n      if (this.parser.strict) {\n        if (verbose && stopped)\n          console.log(\"Stuck with token \" + this.parser.getName(this.tokens.mainToken.value))\n        throw new SyntaxError(\"No parse at \" + pos)\n      }\n      if (!this.recovering) this.recovering = Rec.Distance\n    }\n\n    if (this.recovering && stopped) {\n      let finished = this.runRecovery(stopped, stoppedTokens!, newStacks)\n      if (finished) return this.stackToTree(finished.forceAll())\n    }\n\n    if (this.recovering) {\n      let maxRemaining = this.recovering == 1 ? 1 : this.recovering * Rec.MaxRemainingPerStep\n      if (newStacks.length > maxRemaining) {\n        newStacks.sort((a, b) => b.score - a.score)\n        while (newStacks.length > maxRemaining) newStacks.pop()\n      }\n      if (newStacks.some(s => s.reducePos > pos)) this.recovering--\n    } else if (newStacks.length > 1) {\n      // Prune stacks that are in the same state, or that have been\n      // running without splitting for a while, to avoid getting stuck\n      // with multiple successful stacks running endlessly on.\n      outer: for (let i = 0; i < newStacks.length - 1; i++) {\n        let stack = newStacks[i]\n        for (let j = i + 1; j < newStacks.length; j++) {\n          let other = newStacks[j]\n          if (stack.sameState(other) ||\n              stack.buffer.length > Rec.MinBufferLengthPrune && other.buffer.length > Rec.MinBufferLengthPrune) {\n            if (((stack.score - other.score) || (stack.buffer.length - other.buffer.length)) > 0) {\n              newStacks.splice(j--, 1)\n            } else {\n              newStacks.splice(i--, 1)\n              continue outer\n            }\n          }\n        }\n      }\n    }\n\n    this.pos = newStacks[0].pos\n    for (let i = 1; i < newStacks.length; i++) if (newStacks[i].pos < this.pos) this.pos = newStacks[i].pos\n    return null\n  }\n\n  // Returns an updated version of the given stack, or null if the\n  // stack can't advance normally. When `split` and `stacks` are\n  // given, stacks split off by ambiguous operations will be pushed to\n  // `split`, or added to `stacks` if they move `pos` forward.\n  private advanceStack(stack: Stack, stacks: null | Stack[], split: null | Stack[]) {\n    let start = stack.pos, {input, parser} = this\n    let base = verbose ? this.stackID(stack) + \" -> \" : \"\"\n\n    if (this.fragments) {\n      let strictCx = stack.curContext && stack.curContext.tracker.strict, cxHash = strictCx ? stack.curContext!.hash : 0\n      for (let cached = this.fragments.nodeAt(start); cached;) {\n        let match = this.parser.nodeSet.types[cached.type.id] == cached.type ? parser.getGoto(stack.state, cached.type.id) : -1\n        if (match > -1 && cached.length && (!strictCx || ((cached as any).contextHash || 0) == cxHash)) {\n          stack.useNode(cached, match)\n          if (verbose) console.log(base + this.stackID(stack) + ` (via reuse of ${parser.getName(cached.type.id)})`)\n          return true\n        }\n        if (!(cached instanceof Tree) || cached.children.length == 0 || cached.positions[0] > 0) break\n        let inner = cached.children[0]\n        if (inner instanceof Tree) cached = inner\n        else break\n      }\n    }\n\n    let defaultReduce = parser.stateSlot(stack.state, ParseState.DefaultReduce)\n    if (defaultReduce > 0) {\n      stack.reduce(defaultReduce)\n      if (verbose)\n        console.log(base + this.stackID(stack) + ` (via always-reduce ${parser.getName(defaultReduce & Action.ValueMask)})`)\n      return true\n    }\n\n    let actions = this.tokens.getActions(stack, input)\n    for (let i = 0; i < actions.length;) {\n      let action = actions[i++], term = actions[i++], end = actions[i++]\n      let last = i == actions.length || !split\n      let localStack = last ? stack : stack.split()\n      localStack.apply(action, term, end)\n      if (verbose)\n        console.log(base + this.stackID(localStack) + ` (via ${(action & Action.ReduceFlag) == 0 ? \"shift\"\n                     : `reduce of ${parser.getName(action & Action.ValueMask)}`} for ${\n        parser.getName(term)} @ ${start}${localStack == stack ? \"\" : \", split\"})`)\n      if (last) return true\n      else if (localStack.pos > start) stacks!.push(localStack)\n      else split!.push(localStack)\n    }\n\n    return false\n  }\n\n  // Advance a given stack forward as far as it will go. Returns the\n  // (possibly updated) stack if it got stuck, or null if it moved\n  // forward and was given to `pushStackDedup`.\n  private advanceFully(stack: Stack, newStacks: Stack[]) {\n    let pos = stack.pos\n    for (;;) {\n      let nest = this.checkNest(stack)\n      if (nest) return nest\n      if (!this.advanceStack(stack, null, null)) return false\n      if (stack.pos > pos) {\n        pushStackDedup(stack, newStacks)\n        return true\n      }\n    }\n  }\n\n  private runRecovery(stacks: Stack[], tokens: number[], newStacks: Stack[]) {\n    let finished: Stack | null = null, restarted = false\n    let maybeNest\n    for (let i = 0; i < stacks.length; i++) {\n      let stack = stacks[i], token = tokens[i << 1], tokenEnd = tokens[(i << 1) + 1]\n      let base = verbose ? this.stackID(stack) + \" -> \" : \"\"\n\n      if (stack.deadEnd) {\n        if (restarted) continue\n        restarted = true\n        stack.restart()\n        if (verbose) console.log(base + this.stackID(stack) + \" (restarted)\")\n        let done = this.advanceFully(stack, newStacks)\n        if (done) {\n          if (done !== true) maybeNest = done\n          continue\n        }\n      }\n\n      let force = stack.split(), forceBase = base\n      for (let j = 0; force.forceReduce() && j < Rec.ForceReduceLimit; j++) {\n        if (verbose) console.log(forceBase + this.stackID(force) + \" (via force-reduce)\")\n        let done = this.advanceFully(force, newStacks)\n        if (done) {\n          if (done !== true) maybeNest = done\n          break\n        }\n        if (verbose) forceBase = this.stackID(force) + \" -> \"\n      }\n\n      for (let insert of stack.recoverByInsert(token)) {\n        if (verbose) console.log(base + this.stackID(insert) + \" (via recover-insert)\")\n        this.advanceFully(insert, newStacks)\n      }\n\n      if (this.input.length > stack.pos) {\n        if (tokenEnd == stack.pos) {\n          tokenEnd++\n          token = Term.Err\n        }\n        stack.recoverByDelete(token, tokenEnd)\n        if (verbose) console.log(base + this.stackID(stack) + ` (via recover-delete ${this.parser.getName(token)})`)\n        pushStackDedup(stack, newStacks)\n      } else if (!finished || finished.score < stack.score) {\n        finished = stack\n      }\n    }\n\n    if (finished) return finished\n\n    if (maybeNest) for (let s of this.stacks) if (s.score > maybeNest.stack.score) {\n      maybeNest = undefined\n      break\n    }\n    if (maybeNest) this.startNested(maybeNest)\n    return null\n  }\n\n  forceFinish() {\n    let stack = this.stacks[0].split()\n    if (this.nested) this.finishNested(stack, this.nested.forceFinish())\n    return this.stackToTree(stack.forceAll())\n  }\n\n  // Convert the stack's buffer to a syntax tree.\n  stackToTree(stack: Stack, pos: number = stack.pos): Tree {\n    if (this.parser.context) stack.emitContext()\n    return Tree.build({buffer: StackBufferCursor.create(stack),\n                       nodeSet: this.parser.nodeSet,\n                       topID: this.topTerm,\n                       maxBufferLength: this.parser.bufferLength,\n                       reused: this.reused,\n                       start: this.startPos,\n                       length: pos - this.startPos,\n                       minRepeatType: this.parser.minRepeatTerm})\n  }\n\n  private checkNest(stack: Stack) {\n    let info = this.parser.findNested(stack.state)\n    if (!info) return null\n    let spec: NestedParser | null = info.value\n    if (typeof spec == \"function\") spec = spec(this.input, stack)\n    return spec ? {stack, info, spec} : null\n  }\n\n  private startNested(nest: {stack: Stack, info: NestInfo, spec: NestedParserSpec}) {\n    let {stack, info, spec} = nest\n    this.stacks = [stack]\n    this.nestEnd = this.scanForNestEnd(stack, info.end, spec.filterEnd)\n    this.nestWrap = typeof spec.wrapType == \"number\" ? this.parser.nodeSet.types[spec.wrapType] : spec.wrapType || null\n    if (spec.startParse) {\n      this.nested = spec.startParse(this.input.clip(this.nestEnd), stack.pos, this.context)\n    } else {\n      this.finishNested(stack)\n    }\n  }\n\n  private scanForNestEnd(stack: Stack, endToken: TokenGroup, filter?: (token: string) => boolean) {\n    for (let pos = stack.pos; pos < this.input.length; pos++) {\n      dummyToken.start = pos\n      dummyToken.value = -1\n      endToken.token(this.input, dummyToken, stack)\n      if (dummyToken.value > -1 && (!filter || filter(this.input.read(pos, dummyToken.end)))) return pos\n    }\n    return this.input.length\n  }\n\n  private finishNested(stack: Stack, tree?: Tree) {\n    if (this.nestWrap) tree = new Tree(this.nestWrap, tree ? [tree] : [], tree ? [0] : [], this.nestEnd - stack.pos)\n    else if (!tree) tree = new Tree(NodeType.none, [], [], this.nestEnd - stack.pos)\n    let info = this.parser.findNested(stack.state)!\n    stack.useNode(tree, this.parser.getGoto(stack.state, info.placeholder, true))\n    if (verbose) console.log(this.stackID(stack) + ` (via unnest)`)\n  }\n\n  private stackID(stack: Stack) {\n    let id = (stackIDs || (stackIDs = new WeakMap)).get(stack)\n    if (!id) stackIDs.set(stack, id = String.fromCodePoint(this.nextStackID++))\n    return id + stack\n  }\n}\n\nfunction pushStackDedup(stack: Stack, newStacks: Stack[]) {\n  for (let i = 0; i < newStacks.length; i++) {\n    let other = newStacks[i]\n    if (other.pos == stack.pos && other.sameState(stack)) {\n      if (newStacks[i].score < stack.score) newStacks[i] = stack\n      return\n    }\n  }\n  newStacks.push(stack)\n}\n\nexport class Dialect {\n  constructor(readonly source: string | undefined,\n              readonly flags: readonly boolean[],\n              readonly disabled: null | Uint8Array) {}\n\n  allows(term: number) { return !this.disabled || this.disabled[term] == 0 }\n}\n\nconst id: <T>(x: T) => T = x => x\n\n/// Context trackers are used to track stateful context (such as\n/// indentation in the Python grammar, or parent elements in the XML\n/// grammar) needed by external tokenizers. You declare them in a\n/// grammar file as `@context exportName from \"module\"`.\n///\n/// Context values should be immutable, and can be updated (replaced)\n/// on shift or reduce actions.\nexport class ContextTracker<T> {\n  /// @internal\n  start: T\n  /// @internal\n  shift: (context: T, term: number, input: Input, stack: Stack) => T\n  /// @internal\n  reduce: (context: T, term: number, input: Input, stack: Stack) => T\n  /// @internal\n  reuse: (context: T, node: Tree | TreeBuffer, input: Input, stack: Stack) => T\n  /// @internal\n  hash: (context: T) => number\n  /// @internal\n  strict: boolean\n\n  /// The export used in a `@context` declaration should be of this\n  /// type.\n  constructor(spec: {\n    /// The initial value of the context.\n    start: T,\n    /// Update the context when the parser executes a\n    /// [shift](https://en.wikipedia.org/wiki/LR_parser#Shift_and_reduce_actions)\n    /// action.\n    shift?(context: T, term: number, input: Input, stack: Stack): T\n    /// Update the context when the parser executes a reduce action.\n    reduce?(context: T, term: number, input: Input, stack: Stack): T\n    /// Update the context when the parser reuses a node from a tree\n    /// fragment.\n    reuse?(context: T, node: Tree | TreeBuffer, input: Input, stack: Stack): T\n    /// Reduce a context value to a number (for cheap storage and\n    /// comparison).\n    hash(context: T): number\n    /// By default, nodes can only be reused during incremental\n    /// parsing if they were created in the same context as the one in\n    /// which they are reused. Set this to false to disable that\n    /// check.\n    strict?: boolean\n  }) {\n    this.start = spec.start\n    this.shift = spec.shift || id\n    this.reduce = spec.reduce || id\n    this.reuse = spec.reuse || id\n    this.hash = spec.hash\n    this.strict = spec.strict !== false\n  }\n}\n\ntype ParserSpec = {\n  version: number,\n  states: string | Uint32Array,\n  stateData: string | Uint16Array,\n  goto: string | Uint16Array,\n  nodeNames: string,\n  maxTerm: number,\n  repeatNodeCount: number,\n  nodeProps?: [NodeProp<any>, ...(string | number)[]][],\n  skippedNodes?: number[],\n  tokenData: string,\n  tokenizers: (Tokenizer | number)[],\n  topRules: {[name: string]: [number, number]},\n  context: ContextTracker<any> | null,\n  nested?: [string, NestedParser, string | Uint16Array, number][],\n  dialects?: {[name: string]: number},\n  dynamicPrecedences?: {[term: number]: number},\n  specialized?: {term: number, get: (value: string, stack: Stack) => number}[],\n  tokenPrec: number,\n  termNames?: {[id: number]: string}\n}\n\ntype NestInfo = {\n  // A name, used by `withNested`\n  name: string,\n  value: NestedParser,\n  // A token-recognizing automaton for the end of the nesting\n  end: TokenGroup,\n  // The id of the placeholder term that appears in the grammar at\n  // the position of this nesting\n  placeholder: number\n}\n\n/// Configuration options to pass to a parser.\nexport interface ParserConfig {\n  /// Node props to add to the parser's node set.\n  props?: readonly NodePropSource[],\n  /// The name of the @top declaration to parse from. If not\n  /// specified, the first @top declaration is used.\n  top?: string,\n  /// A space-separated string of dialects to enable.\n  dialect?: string,\n  /// The nested grammars to use. This can be used to, for example,\n  /// swap in a different language for a nested grammar or fill in a\n  /// nested grammar that was left blank by the original grammar.\n  nested?: {[name: string]: NestedParser},\n  /// Replace the given external tokenizers with new ones.\n  tokenizers?: {from: ExternalTokenizer, to: ExternalTokenizer}[],\n  /// When true, the parser will raise an exception, rather than run\n  /// its error-recovery strategies, when the input doesn't match the\n  /// grammar.\n  strict?: boolean\n  /// The maximum length of the TreeBuffers generated in the output\n  /// tree. Defaults to 1024.\n  bufferLength?: number\n}\n\n/// A parser holds the parse tables for a given grammar, as generated\n/// by `lezer-generator`.\nexport class Parser {\n  /// The parse states for this grammar @internal\n  readonly states: Readonly<Uint32Array>\n  /// A blob of data that the parse states, as well as some\n  /// of `Parser`'s fields, point into @internal\n  readonly data: Readonly<Uint16Array>\n  /// The goto table. See `computeGotoTable` in\n  /// lezer-generator for details on the format @internal\n  readonly goto: Readonly<Uint16Array>\n  /// A node set with the node types used by this parser.\n  readonly nodeSet: NodeSet\n  /// The highest term id @internal\n  readonly maxTerm: number\n  /// The first repeat-related term id @internal\n  readonly minRepeatTerm: number\n  /// The tokenizer objects used by the grammar @internal\n  readonly tokenizers: readonly Tokenizer[]\n  /// Maps top rule names to [state ID, top term ID] pairs. @internal\n  readonly topRules: {[name: string]: [number, number]}\n  /// @internal\n  readonly context: ContextTracker<unknown> | null\n  /// Metadata about nested grammars used in this grammar @internal\n  readonly nested: readonly NestInfo[]\n  /// A mapping from dialect names to the tokens that are exclusive\n  /// to them. @internal\n  readonly dialects: {[name: string]: number}\n  /// Null if there are no dynamic precedences, a map from term ids\n  /// to precedence otherwise. @internal\n  readonly dynamicPrecedences: {[term: number]: number} | null\n  /// The token types have specializers (in this.specializers) @internal\n  readonly specialized: Uint16Array\n  /// The specializer functions for the token types in specialized @internal\n  readonly specializers: ((value: string, stack: Stack) => number)[]\n  /// Points into this.data at an array that holds the\n  /// precedence order (higher precedence first) for ambiguous\n  /// tokens @internal\n  readonly tokenPrecTable: number\n  /// An optional object mapping term ids to name strings @internal\n  readonly termNames: null | {[id: number]: string}\n  /// @internal\n  readonly maxNode: number\n  /// @internal\n  readonly dialect: Dialect\n  /// @internal\n  readonly top: [number, number]\n  /// @internal\n  readonly bufferLength = DefaultBufferLength\n  /// @internal\n  readonly strict = false\n\n  private cachedDialect: Dialect | null = null\n\n  /// @internal\n  constructor(spec: ParserSpec) {\n    if (spec.version != File.Version)\n      throw new RangeError(`Parser version (${spec.version}) doesn't match runtime version (${File.Version})`)\n    let tokenArray = decodeArray<Uint16Array>(spec.tokenData)\n    let nodeNames = spec.nodeNames.split(\" \")\n    this.minRepeatTerm = nodeNames.length\n    this.context = spec.context\n    for (let i = 0; i < spec.repeatNodeCount; i++) nodeNames.push(\"\")\n    let nodeProps: [NodeProp<any>, any][][] = []\n    for (let i = 0; i < nodeNames.length; i++) nodeProps.push([])\n    function setProp(nodeID: number, prop: NodeProp<any>, value: any) {\n      nodeProps[nodeID].push([prop, prop.deserialize(String(value))])\n    }\n    if (spec.nodeProps) for (let propSpec of spec.nodeProps) {\n      let prop = propSpec[0]\n      for (let i = 1; i < propSpec.length;) {\n        let next = propSpec[i++]\n        if (next >= 0) {\n          setProp(next as number, prop, propSpec[i++] as string)\n        } else {\n          let value = propSpec[i + -next] as string\n          for (let j = -next; j > 0; j--) setProp(propSpec[i++] as number, prop, value)\n          i++\n        }\n      }\n    }\n    this.specialized = new Uint16Array(spec.specialized ? spec.specialized.length : 0)\n    this.specializers = []\n    if (spec.specialized) for (let i = 0; i < spec.specialized.length; i++) {\n      this.specialized[i] = spec.specialized[i].term\n      this.specializers[i] = spec.specialized[i].get\n    }\n\n    this.states = decodeArray(spec.states, Uint32Array)\n    this.data = decodeArray(spec.stateData)\n    this.goto = decodeArray(spec.goto)\n    let topTerms = Object.keys(spec.topRules).map(r => spec.topRules[r][1])\n    this.nodeSet = new NodeSet(nodeNames.map((name, i) => NodeType.define({\n      name: i >= this.minRepeatTerm ? undefined: name,\n      id: i,\n      props: nodeProps[i],\n      top: topTerms.indexOf(i) > -1,\n      error: i == 0,\n      skipped: spec.skippedNodes && spec.skippedNodes.indexOf(i) > -1\n    })))\n    this.maxTerm = spec.maxTerm\n    this.tokenizers = spec.tokenizers.map(value => typeof value == \"number\" ? new TokenGroup(tokenArray, value) : value)\n    this.topRules = spec.topRules\n    this.nested = (spec.nested || []).map(([name, value, endToken, placeholder]) => {\n      return {name, value, end: new TokenGroup(decodeArray(endToken), 0), placeholder}\n    })\n    this.dialects = spec.dialects || {}\n    this.dynamicPrecedences = spec.dynamicPrecedences || null\n    this.tokenPrecTable = spec.tokenPrec\n    this.termNames = spec.termNames || null\n    this.maxNode = this.nodeSet.types.length - 1\n\n    this.dialect = this.parseDialect()\n    this.top = this.topRules[Object.keys(this.topRules)[0]]\n  }\n\n  /// Parse a given string or stream.\n  parse(input: Input | string, startPos: number = 0, context: ParseContext = {}) {\n    if (typeof input == \"string\") input = stringInput(input)\n    let cx = new Parse(this, input, startPos, context)\n    for (;;) {\n      let done = cx.advance()\n      if (done) return done\n    }\n  }\n\n  /// Start an incremental parse.\n  startParse(input: Input | string, startPos: number = 0, context: ParseContext = {}): PartialParse {\n    if (typeof input == \"string\") input = stringInput(input)\n    return new Parse(this, input, startPos, context)\n  }\n\n  /// Get a goto table entry @internal\n  getGoto(state: number, term: number, loose = false) {\n    let table = this.goto\n    if (term >= table[0]) return -1\n    for (let pos = table[term + 1];;) {\n      let groupTag = table[pos++], last = groupTag & 1\n      let target = table[pos++]\n      if (last && loose) return target\n      for (let end = pos + (groupTag >> 1); pos < end; pos++)\n        if (table[pos] == state) return target\n      if (last) return -1\n    }\n  }\n\n  /// Check if this state has an action for a given terminal @internal\n  hasAction(state: number, terminal: number) {\n    let data = this.data\n    for (let set = 0; set < 2; set++) {\n      for (let i = this.stateSlot(state, set ? ParseState.Skip : ParseState.Actions), next;; i += 3) {\n        if ((next = data[i]) == Seq.End) {\n          if (data[i + 1] == Seq.Next) next = data[i = pair(data, i + 2)]\n          else if (data[i + 1] == Seq.Other) return pair(data, i + 2)\n          else break\n        }\n        if (next == terminal || next == Term.Err) return pair(data, i + 1)\n      }\n    }\n    return 0\n  }\n\n  /// @internal\n  stateSlot(state: number, slot: number) {\n    return this.states[(state * ParseState.Size) + slot]\n  }\n\n  /// @internal\n  stateFlag(state: number, flag: number) {\n    return (this.stateSlot(state, ParseState.Flags) & flag) > 0\n  }\n\n  /// @internal\n  findNested(state: number) {\n    let flags = this.stateSlot(state, ParseState.Flags)\n    return flags & StateFlag.StartNest ? this.nested[flags >> StateFlag.NestShift] : null\n  }\n\n  /// @internal\n  validAction(state: number, action: number) {\n    if (action == this.stateSlot(state, ParseState.DefaultReduce)) return true\n    for (let i = this.stateSlot(state, ParseState.Actions);; i += 3) {\n      if (this.data[i] == Seq.End) {\n        if (this.data[i + 1] == Seq.Next) i = pair(this.data, i + 2)\n        else return false\n      }\n      if (action == pair(this.data, i + 1)) return true\n    }\n  }\n\n  /// Get the states that can follow this one through shift actions or\n  /// goto jumps. @internal\n  nextStates(state: number): readonly number[] {\n    let result: number[] = []\n    for (let i = this.stateSlot(state, ParseState.Actions);; i += 3) {\n      if (this.data[i] == Seq.End) {\n        if (this.data[i + 1] == Seq.Next) i = pair(this.data, i + 2)\n        else break\n      }\n      if ((this.data[i + 2] & (Action.ReduceFlag >> 16)) == 0) {\n        let value = this.data[i + 1]\n        if (!result.some((v, i) => (i & 1) && v == value)) result.push(this.data[i], value)\n      }\n    }\n    return result\n  }\n\n  /// @internal\n  overrides(token: number, prev: number) {\n    let iPrev = findOffset(this.data, this.tokenPrecTable, prev)\n    return iPrev < 0 || findOffset(this.data, this.tokenPrecTable, token) < iPrev\n  }\n\n  /// Configure the parser. Returns a new parser instance that has the\n  /// given settings modified. Settings not provided in `config` are\n  /// kept from the original parser.\n  configure(config: ParserConfig) {\n    // Hideous reflection-based kludge to make it easy to create a\n    // slightly modified copy of a parser.\n    let copy = Object.assign(Object.create(Parser.prototype), this)\n    if (config.props)\n      copy.nodeSet = this.nodeSet.extend(...config.props)\n    if (config.top) {\n      let info = this.topRules[config.top!]\n      if (!info) throw new RangeError(`Invalid top rule name ${config.top}`)\n      copy.top = info\n    }\n    if (config.tokenizers)\n      copy.tokenizers = this.tokenizers.map(t => {\n        let found = config.tokenizers!.find(r => r.from == t)\n        return found ? found.to : t\n      })\n    if (config.dialect)\n      copy.dialect = this.parseDialect(config.dialect)\n    if (config.nested)\n      copy.nested = this.nested.map(obj => {\n        if (!Object.prototype.hasOwnProperty.call(config.nested, obj.name)) return obj\n        return {name: obj.name, value: config.nested![obj.name], end: obj.end, placeholder: obj.placeholder}\n      })\n    if (config.strict != null)\n      copy.strict = config.strict\n    if (config.bufferLength != null)\n      copy.bufferLength = config.bufferLength\n    return copy as Parser\n  }\n\n  /// Returns the name associated with a given term. This will only\n  /// work for all terms when the parser was generated with the\n  /// `--names` option. By default, only the names of tagged terms are\n  /// stored.\n  getName(term: number): string {\n    return this.termNames ? this.termNames[term] : String(term <= this.maxNode && this.nodeSet.types[term].name || term)\n  }\n\n  /// The eof term id is always allocated directly after the node\n  /// types. @internal\n  get eofTerm() { return this.maxNode + 1 }\n\n  /// Tells you whether this grammar has any nested grammars.\n  get hasNested() { return this.nested.length > 0 }\n\n  /// The type of top node produced by the parser.\n  get topNode() { return this.nodeSet.types[this.top[1]] }\n\n  /// @internal\n  dynamicPrecedence(term: number) {\n    let prec = this.dynamicPrecedences\n    return prec == null ? 0 : prec[term] || 0\n  }\n\n  /// @internal\n  parseDialect(dialect?: string) {\n    if (this.cachedDialect && this.cachedDialect.source == dialect) return this.cachedDialect\n    let values = Object.keys(this.dialects), flags = values.map(() => false)\n    if (dialect) for (let part of dialect.split(\" \")) {\n      let id = values.indexOf(part)\n      if (id >= 0) flags[id] = true\n    }\n    let disabled: Uint8Array | null = null\n    for (let i = 0; i < values.length; i++) if (!flags[i]) {\n      for (let j = this.dialects[values[i]], id; (id = this.data[j++]) != Seq.End;)\n        (disabled || (disabled = new Uint8Array(this.maxTerm + 1)))[id] = 1\n    }\n    return this.cachedDialect = new Dialect(dialect, flags, disabled)\n  }\n\n  /// (used by the output of the parser generator) @internal\n  static deserialize(spec: ParserSpec) {\n    return new Parser(spec)\n  }\n}\n\nfunction pair(data: Readonly<Uint16Array>, off: number) { return data[off] | (data[off + 1] << 16) }\n\nfunction findOffset(data: Readonly<Uint16Array>, start: number, term: number) {\n  for (let i = start, next; (next = data[i]) != Seq.End; i++)\n    if (next == term) return i - start\n  return -1\n}\n\nfunction findFinished(stacks: Stack[]) {\n  let best: Stack | null = null\n  for (let stack of stacks) {\n    if (stack.pos == stack.p.input.length &&\n        stack.p.parser.stateFlag(stack.state, StateFlag.Accepting) &&\n        (!best || best.score < stack.score))\n      best = stack\n  }\n  return best\n}\n","const C = \"\\u037c\"\nconst COUNT = typeof Symbol == \"undefined\" ? \"__\" + C : Symbol.for(C)\nconst SET = typeof Symbol == \"undefined\" ? \"__styleSet\" + Math.floor(Math.random() * 1e8) : Symbol(\"styleSet\")\nconst top = typeof globalThis != \"undefined\" ? globalThis : typeof window != \"undefined\" ? window : {}\n\n// :: - Style modules encapsulate a set of CSS rules defined from\n// JavaScript. Their definitions are only available in a given DOM\n// root after it has been _mounted_ there with `StyleModule.mount`.\n//\n// Style modules should be created once and stored somewhere, as\n// opposed to re-creating them every time you need them. The amount of\n// CSS rules generated for a given DOM root is bounded by the amount\n// of style modules that were used. So to avoid leaking rules, don't\n// create these dynamically, but treat them as one-time allocations.\nexport class StyleModule {\n  // :: (Object<Style>, ?{process: (string) → string, extend: (string, string) → string})\n  // Create a style module from the given spec.\n  //\n  // When `process` is given, it is called on regular (non-`@`)\n  // selector properties to provide the actual selector. When `extend`\n  // is given, it is called when a property containing an `&` is\n  // found, and should somehow combine the `&`-template (its first\n  // argument) with the selector (its second argument) to produce an\n  // extended selector.\n  constructor(spec, options) {\n    this.rules = []\n    let {process, extend} = options || {}\n\n    function processSelector(selector) {\n      if (/^@/.test(selector)) return [selector]\n      let selectors = selector.split(\",\")\n      return process ? selectors.map(process) : selectors\n    }\n\n    function render(selectors, spec, target) {\n      let local = [], isAt = /^@(\\w+)\\b/.exec(selectors[0])\n      if (isAt && spec == null) return target.push(selectors[0] + \";\")\n      for (let prop in spec) {\n        let value = spec[prop]\n        if (/&/.test(prop)) {\n          render(selectors.map(s => extend ? extend(prop, s) : prop.replace(/&/g, s)), value, target)\n        } else if (value && typeof value == \"object\") {\n          if (!isAt) throw new RangeError(\"The value of a property (\" + prop + \") should be a primitive value.\")\n          render(isAt[1] == \"keyframes\" ? [prop] : processSelector(prop), value, local)\n        } else if (value != null) {\n          local.push(prop.replace(/_.*/, \"\").replace(/[A-Z]/g, l => \"-\" + l.toLowerCase()) + \": \" + value + \";\")\n        }\n      }\n      if (local.length || isAt && isAt[1] == \"keyframes\") target.push(selectors.join(\",\") + \" {\" + local.join(\" \") + \"}\")\n    }\n\n    for (let prop in spec) render(processSelector(prop), spec[prop], this.rules)\n  }\n\n  // :: () → string\n  // Returns a string containing the module's CSS rules.\n  getRules() { return this.rules.join(\"\\n\") }\n\n  // :: () → string\n  // Generate a new unique CSS class name.\n  static newName() {\n    let id = top[COUNT] || 1\n    top[COUNT] = id + 1\n    return C + id.toString(36)\n  }\n\n  // :: (union<Document, ShadowRoot>, union<[StyleModule], StyleModule>)\n  //\n  // Mount the given set of modules in the given DOM root, which ensures\n  // that the CSS rules defined by the module are available in that\n  // context.\n  //\n  // Rules are only added to the document once per root.\n  //\n  // Rule order will follow the order of the modules, so that rules from\n  // modules later in the array take precedence of those from earlier\n  // modules. If you call this function multiple times for the same root\n  // in a way that changes the order of already mounted modules, the old\n  // order will be changed.\n  static mount(root, modules) {\n    (root[SET] || new StyleSet(root)).mount(Array.isArray(modules) ? modules : [modules])\n  }\n}\n\nlet adoptedSet = null\n\nclass StyleSet {\n  constructor(root) {\n    if (!root.head && root.adoptedStyleSheets && typeof CSSStyleSheet != \"undefined\") {\n      if (adoptedSet) {\n        root.adoptedStyleSheets = [adoptedSet.sheet].concat(root.adoptedStyleSheets)\n        return root[SET] = adoptedSet\n      }\n      this.sheet = new CSSStyleSheet\n      root.adoptedStyleSheets = [this.sheet].concat(root.adoptedStyleSheets)\n      adoptedSet = this\n    } else {\n      this.styleTag = (root.ownerDocument || root).createElement(\"style\")\n      let target = root.head || root\n      target.insertBefore(this.styleTag, target.firstChild)\n    }\n    this.modules = []\n    root[SET] = this\n  }\n\n  mount(modules) {\n    let sheet = this.sheet\n    let pos = 0 /* Current rule offset */, j = 0 /* Index into this.modules */\n    for (let i = 0; i < modules.length; i++) {\n      let mod = modules[i], index = this.modules.indexOf(mod)\n      if (index < j && index > -1) { // Ordering conflict\n        this.modules.splice(index, 1)\n        j--\n        index = -1\n      }\n      if (index == -1) {\n        this.modules.splice(j++, 0, mod)\n        if (sheet) for (let k = 0; k < mod.rules.length; k++)\n          sheet.insertRule(mod.rules[k], pos++)\n      } else {\n        while (j < index) pos += this.modules[j++].rules.length\n        pos += mod.rules.length\n        j++\n      }\n    }\n\n    if (!sheet) {\n      let text = \"\"\n      for (let i = 0; i < this.modules.length; i++)\n        text += this.modules[i].getRules() + \"\\n\"\n      this.styleTag.textContent = text\n    }\n  }\n}\n\n// Style::Object<union<Style,string>>\n//\n// A style is an object that, in the simple case, maps CSS property\n// names to strings holding their values, as in `{color: \"red\",\n// fontWeight: \"bold\"}`. The property names can be given in\n// camel-case—the library will insert a dash before capital letters\n// when converting them to CSS.\n//\n// If you include an underscore in a property name, it and everything\n// after it will be removed from the output, which can be useful when\n// providing a property multiple times, for browser compatibility\n// reasons.\n//\n// A property in a style object can also be a sub-selector, which\n// extends the current context to add a pseudo-selector or a child\n// selector. Such a property should contain a `&` character, which\n// will be replaced by the current selector. For example `{\"&:before\":\n// {content: '\"hi\"'}}`. Sub-selectors and regular properties can\n// freely be mixed in a given object. Any property containing a `&` is\n// assumed to be a sub-selector.\n//\n// Finally, a property can specify an @-block to be wrapped around the\n// styles defined inside the object that's the property's value. For\n// example to create a media query you can do `{\"@media screen and\n// (min-width: 400px)\": {...}}`.\n","export var base = {\n  8: \"Backspace\",\n  9: \"Tab\",\n  10: \"Enter\",\n  12: \"NumLock\",\n  13: \"Enter\",\n  16: \"Shift\",\n  17: \"Control\",\n  18: \"Alt\",\n  20: \"CapsLock\",\n  27: \"Escape\",\n  32: \" \",\n  33: \"PageUp\",\n  34: \"PageDown\",\n  35: \"End\",\n  36: \"Home\",\n  37: \"ArrowLeft\",\n  38: \"ArrowUp\",\n  39: \"ArrowRight\",\n  40: \"ArrowDown\",\n  44: \"PrintScreen\",\n  45: \"Insert\",\n  46: \"Delete\",\n  59: \";\",\n  61: \"=\",\n  91: \"Meta\",\n  92: \"Meta\",\n  106: \"*\",\n  107: \"+\",\n  108: \",\",\n  109: \"-\",\n  110: \".\",\n  111: \"/\",\n  144: \"NumLock\",\n  145: \"ScrollLock\",\n  160: \"Shift\",\n  161: \"Shift\",\n  162: \"Control\",\n  163: \"Control\",\n  164: \"Alt\",\n  165: \"Alt\",\n  173: \"-\",\n  186: \";\",\n  187: \"=\",\n  188: \",\",\n  189: \"-\",\n  190: \".\",\n  191: \"/\",\n  192: \"`\",\n  219: \"[\",\n  220: \"\\\\\",\n  221: \"]\",\n  222: \"'\",\n  229: \"q\"\n}\n\nexport var shift = {\n  48: \")\",\n  49: \"!\",\n  50: \"@\",\n  51: \"#\",\n  52: \"$\",\n  53: \"%\",\n  54: \"^\",\n  55: \"&\",\n  56: \"*\",\n  57: \"(\",\n  59: \":\",\n  61: \"+\",\n  173: \"_\",\n  186: \":\",\n  187: \"+\",\n  188: \"<\",\n  189: \"_\",\n  190: \">\",\n  191: \"?\",\n  192: \"~\",\n  219: \"{\",\n  220: \"|\",\n  221: \"}\",\n  222: \"\\\"\",\n  229: \"Q\"\n}\n\nvar chrome = typeof navigator != \"undefined\" && /Chrome\\/(\\d+)/.exec(navigator.userAgent)\nvar safari = typeof navigator != \"undefined\" && /Apple Computer/.test(navigator.vendor)\nvar gecko = typeof navigator != \"undefined\" && /Gecko\\/\\d+/.test(navigator.userAgent)\nvar mac = typeof navigator != \"undefined\" && /Mac/.test(navigator.platform)\nvar ie = typeof navigator != \"undefined\" && /MSIE \\d|Trident\\/(?:[7-9]|\\d{2,})\\..*rv:(\\d+)/.exec(navigator.userAgent)\nvar brokenModifierNames = chrome && (mac || +chrome[1] < 57) || gecko && mac\n\n// Fill in the digit keys\nfor (var i = 0; i < 10; i++) base[48 + i] = base[96 + i] = String(i)\n\n// The function keys\nfor (var i = 1; i <= 24; i++) base[i + 111] = \"F\" + i\n\n// And the alphabetic keys\nfor (var i = 65; i <= 90; i++) {\n  base[i] = String.fromCharCode(i + 32)\n  shift[i] = String.fromCharCode(i)\n}\n\n// For each code that doesn't have a shift-equivalent, copy the base name\nfor (var code in base) if (!shift.hasOwnProperty(code)) shift[code] = base[code]\n\nexport function keyName(event) {\n  // Don't trust event.key in Chrome when there are modifiers until\n  // they fix https://bugs.chromium.org/p/chromium/issues/detail?id=633838\n  var ignoreKey = brokenModifierNames && (event.ctrlKey || event.altKey || event.metaKey) ||\n    (safari || ie) && event.shiftKey && event.key && event.key.length == 1\n  var name = (!ignoreKey && event.key) ||\n    (event.shiftKey ? shift : base)[event.keyCode] ||\n    event.key || \"Unidentified\"\n  // Edge sometimes produces wrong names (Issue #3)\n  if (name == \"Esc\") name = \"Escape\"\n  if (name == \"Del\") name = \"Delete\"\n  // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/8860571/\n  if (name == \"Left\") name = \"ArrowLeft\"\n  if (name == \"Up\") name = \"ArrowUp\"\n  if (name == \"Right\") name = \"ArrowRight\"\n  if (name == \"Down\") name = \"ArrowDown\"\n  return name\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import { openLintPanel } from \"@codemirror/next/lint\"\nimport { EditorState } from \"@codemirror/next/state\"\nimport { EditorView } from \"@codemirror/next/view\"\nimport { editableConfig, makeLinter } from \"../lib/index.js\"\n\nconst initialValue = `# Welcome to the schema editor!\n# If you're new, you probably want to read\n# the schema language documentation here:\n# http://r1.underlay.org/docs/schemas\n\nnamespace ex http://example.com#\nnamespace ul http://underlay.org/ns/\n\ntype foo {\n  ex:a -> ? uri ;\n  ex:b -> string ;\n  ex:c -> dateTime ;\n}\n\nedge ex:cool ==/ ex:map /=> ex:wau\n\nclass ex:cool unit\n\nclass ex:wau {\n  ex:bar -> foo ;\n  ex:age -> integer ;\n  ex:self -> * ex:wau ;\n}\n\n\n\n\n\n\n`\n\nconst linter = makeLinter()\nconst extensions = [...editableConfig, linter]\n\nconst state = EditorState.create({\n\tdoc: initialValue,\n\textensions,\n})\n\nconst view = new EditorView({\n\tstate,\n\tparent: document.getElementById(\"editor\"),\n})\n\nopenLintPanel(view)\nview.focus()\n"],"sourceRoot":""}